{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Renovate documentation \u00b6 Automated dependency updates. Multi-platform and multi-language. Why use Renovate? \u00b6 Get pull requests to update your dependencies and lock files Reduce noise by scheduling when Renovate creates PRs Renovate finds relevant package files automatically, including in monorepos You can customize the bot's behavior with configuration files Share your configuration with ESLint-like config presets Get replacement PRs to migrate from a deprecated dependency to the community suggested replacement (npm packages only) Open source Supported Platforms \u00b6 Renovate works on these platforms: GitHub (.com and Enterprise Server) GitLab (.com and CE/EE) Bitbucket Cloud Bitbucket Server Azure DevOps Gitea Who Uses Renovate? \u00b6 Renovate is used by: Ways to run Renovate \u00b6 You can run Renovate as: an Open Source npm package a pre-built Open Source image on Docker Hub a free GitHub App that is hosted by Mend Install our GitHub app now","title":"Home"},{"location":"#renovate-documentation","text":"Automated dependency updates. Multi-platform and multi-language.","title":"Renovate documentation"},{"location":"#why-use-renovate","text":"Get pull requests to update your dependencies and lock files Reduce noise by scheduling when Renovate creates PRs Renovate finds relevant package files automatically, including in monorepos You can customize the bot's behavior with configuration files Share your configuration with ESLint-like config presets Get replacement PRs to migrate from a deprecated dependency to the community suggested replacement (npm packages only) Open source","title":"Why use Renovate?"},{"location":"#supported-platforms","text":"Renovate works on these platforms: GitHub (.com and Enterprise Server) GitLab (.com and CE/EE) Bitbucket Cloud Bitbucket Server Azure DevOps Gitea","title":"Supported Platforms"},{"location":"#who-uses-renovate","text":"Renovate is used by:","title":"Who Uses Renovate?"},{"location":"#ways-to-run-renovate","text":"You can run Renovate as: an Open Source npm package a pre-built Open Source image on Docker Hub a free GitHub App that is hosted by Mend Install our GitHub app now","title":"Ways to run Renovate"},{"location":"about-us/","text":"About us \u00b6 Renovate was created by Mend staff and they continue to work on Renovate. More than 600 outside contributors helped improve Renovate. Special thanks \u00b6 We want to highlight the work of these awesome people. Thank you for your time and effort! Maintainers \u00b6 Renovate is maintained by: @rarkins @viceice @JamieMagee Maintainers for features \u00b6 Next up, we have these people who help maintain parts of Renovate: @HonkingGoose master of the docs and community manager @zharinov focused on parsing, Gradle and Maven @secustor worked on Terraform and Helm @fgreinacher worked on NuGet @Turbo87 has helped in multiple areas, especially Cargo Valuable contributions \u00b6 We want to highlight these valuable contributions, even if they are one-offs. Some features made a lot of people happy, and efficient! @ikesyo regularly helpful @astellingwerf reviews PRs @danports worked on the Flux manager, and other managers. Feel free to ping @danports for any Flux-related issue or PR @shegox worked on the Go manager, and improved our docs Renovate development \u00b6 The source code for Renovate is available on GitHub at renovatebot/renovate . This is where we do most of the development. About these docs \u00b6 The Renovate docs are built from Markdown files in our renovatebot/renovate repository . Most of the source files can be found in the docs/usage/ directory .","title":"About Us"},{"location":"about-us/#about-us","text":"Renovate was created by Mend staff and they continue to work on Renovate. More than 600 outside contributors helped improve Renovate.","title":"About us"},{"location":"about-us/#special-thanks","text":"We want to highlight the work of these awesome people. Thank you for your time and effort!","title":"Special thanks"},{"location":"about-us/#maintainers","text":"Renovate is maintained by: @rarkins @viceice @JamieMagee","title":"Maintainers"},{"location":"about-us/#maintainers-for-features","text":"Next up, we have these people who help maintain parts of Renovate: @HonkingGoose master of the docs and community manager @zharinov focused on parsing, Gradle and Maven @secustor worked on Terraform and Helm @fgreinacher worked on NuGet @Turbo87 has helped in multiple areas, especially Cargo","title":"Maintainers for features"},{"location":"about-us/#valuable-contributions","text":"We want to highlight these valuable contributions, even if they are one-offs. Some features made a lot of people happy, and efficient! @ikesyo regularly helpful @astellingwerf reviews PRs @danports worked on the Flux manager, and other managers. Feel free to ping @danports for any Flux-related issue or PR @shegox worked on the Go manager, and improved our docs","title":"Valuable contributions"},{"location":"about-us/#renovate-development","text":"The source code for Renovate is available on GitHub at renovatebot/renovate . This is where we do most of the development.","title":"Renovate development"},{"location":"about-us/#about-these-docs","text":"The Renovate docs are built from Markdown files in our renovatebot/renovate repository . Most of the source files can be found in the docs/usage/ directory .","title":"About these docs"},{"location":"bazel/","text":"Bazel \u00b6 Renovate supports upgrading dependencies in Bazel WORKSPACE files. How it works \u00b6 Bazel support is enabled automatically Renovate will search repositories for any WORKSPACE files in the repository Existing dependencies will be extracted from git_repository and http_archive declarations Renovate will replace any old versions with the latest version available git_repository \u00b6 Renovate will update any git_repository declaration that has the following: name remote matching https://github.com/<owner>/<repo>.git tag using a valid SemVer e.g.: git_repository( name = \"build_bazel_rules_typescript\", remote = \"https://github.com/bazelbuild/rules_typescript.git\", tag = \"0.6.1\", ) Renovate uses the list of tags on the remote repository (GitHub) to detect a new version. http_archive and http_file \u00b6 Renovate will update any http_archive or http_file declaration that has the following: name url matching https://github.com/<owner>/<repo>/releases/download/<semver>/<repo>.tar.gz sha256 e.g.: http_archive( name = \"io_bazel_rules_go\", url = \"https://github.com/bazelbuild/rules_go/releases/download/0.7.1/rules_go-0.7.1.tar.gz\", sha256 = \"341d5eacef704415386974bc82a1783a8b7ffbff2ab6ba02375e1ca20d9b031c\", ) Renovate uses the list of releases that it finds at the url to detect a new version. Future work \u00b6 Contributions and/or feature requests are welcome to support more patterns or additional use cases.","title":"Bazel"},{"location":"bazel/#bazel","text":"Renovate supports upgrading dependencies in Bazel WORKSPACE files.","title":"Bazel"},{"location":"bazel/#how-it-works","text":"Bazel support is enabled automatically Renovate will search repositories for any WORKSPACE files in the repository Existing dependencies will be extracted from git_repository and http_archive declarations Renovate will replace any old versions with the latest version available","title":"How it works"},{"location":"bazel/#git_repository","text":"Renovate will update any git_repository declaration that has the following: name remote matching https://github.com/<owner>/<repo>.git tag using a valid SemVer e.g.: git_repository( name = \"build_bazel_rules_typescript\", remote = \"https://github.com/bazelbuild/rules_typescript.git\", tag = \"0.6.1\", ) Renovate uses the list of tags on the remote repository (GitHub) to detect a new version.","title":"git_repository"},{"location":"bazel/#http_archive-and-http_file","text":"Renovate will update any http_archive or http_file declaration that has the following: name url matching https://github.com/<owner>/<repo>/releases/download/<semver>/<repo>.tar.gz sha256 e.g.: http_archive( name = \"io_bazel_rules_go\", url = \"https://github.com/bazelbuild/rules_go/releases/download/0.7.1/rules_go-0.7.1.tar.gz\", sha256 = \"341d5eacef704415386974bc82a1783a8b7ffbff2ab6ba02375e1ca20d9b031c\", ) Renovate uses the list of releases that it finds at the url to detect a new version.","title":"http_archive and http_file"},{"location":"bazel/#future-work","text":"Contributions and/or feature requests are welcome to support more patterns or additional use cases.","title":"Future work"},{"location":"config-presets/","text":"Shareable Config Presets \u00b6 This document describes how to configure your shared presets. Read the Key concepts, presets page to learn more about presets in general. Shareable config presets can only be used with the JSON format, other formats are not supported. Warning default.json is intended for use with presets only! Also, do not use a renovate.json file as a preset. Info We've deprecated the use of a renovate.json file for presets as this can cause issues if the repository configuration uses a renovate.json file as well. Tip Describe what your preset is doing by using the \"description\" field. This way your configuration is self-documenting. Extending from a preset \u00b6 To use a preset put it in an extends array within your Renovate config. Presets can be nested. Preset Hosting \u00b6 Presets should be hosted in repositories, which usually means the same platform host as Renovate is running against. Warning npm-based presets are deprecated and support will be removed in a future major release. You can set a Git tag (like a SemVer) to use a specific release of your shared config. GitHub \u00b6 name example use preset resolves as filename Git tag GitHub default github>abc/foo default https://github.com/abc/foo default.json Default branch GitHub with preset name github>abc/foo:xyz xyz https://github.com/abc/foo xyz.json Default branch GitHub with preset name (JSON5) github>abc/foo:xyz.json5 xyz https://github.com/abc/foo xyz.json5 Default branch GitHub default with a tag github>abc/foo#1.5.4 default https://github.com/abc/foo default.json 1.5.4 GitHub with preset name with a tag github>abc/foo:xyz#1.5.4 xyz https://github.com/abc/foo xyz.json 1.5.4 GitHub with preset name and path with a tag github>abc/foo//path/xyz#1.5.4 xyz https://github.com/abc/foo path/xyz.json 1.5.4 GitHub with subpreset name and tag github>abc/foo:xyz/sub#1.5.4 sub https://github.com/abc/foo xyz.json 1.5.4 GitLab \u00b6 name example use preset resolves as filename Git tag GitLab default gitlab>abc/foo default https://gitlab.com/abc/foo default.json Default branch GitLab with preset name gitlab>abc/foo:xyz xyz https://gitlab.com/abc/foo xyz.json Default branch GitLab with preset name (JSON5) gitlab>abc/foo:xyz.json5 xyz https://gitlab.com/abc/foo xyz.json5 Default branch GitLab default with a tag gitlab>abc/foo#1.5.4 default https://gitlab.com/abc/foo default.json 1.5.4 GitLab with preset name with a tag gitlab>abc/foo:xyz#1.5.4 xyz https://gitlab.com/abc/foo xyz.json 1.5.4 GitLab with preset name and path with a tag gitlab>abc/foo//path/xyz#1.5.4 xyz https://gitlab.com/abc/foo path/xyz.json 1.5.4 GitLab with subpreset name and tag gitlab>abc/foo:xyz/sub#1.5.4 sub https://gitlab.com/abc/foo xyz.json 1.5.4 Gitea \u00b6 name example use preset resolves as filename Git tag Gitea default gitea>abc/foo default https://gitea.com/abc/foo default.json Default branch Gitea with preset name gitea>abc/foo:xyz xyz https://gitea.com/abc/foo xyz.json Default branch Gitea with preset name (JSON5) gitea>abc/foo:xyz.json5 xyz https://gitea.com/abc/foo xyz.json5 Default branch Gitea default with a tag gitea>abc/foo#1.5.4 default https://gitea.com/abc/foo default.json 1.5.4 Gitea with preset name with a tag gitea>abc/foo:xyz#1.5.4 xyz https://gitea.com/abc/foo xyz.json 1.5.4 Gitea with preset name and path with a tag gitea>abc/foo//path/xyz#1.5.4 xyz https://gitea.com/abc/foo path/xyz.json 1.5.4 Gitea with subpreset name and tag gitea>abc/foo:xyz/sub#1.5.4 sub https://gitea.com/abc/foo xyz.json 1.5.4 Self-hosted Git \u00b6 name example use preset resolves as filename Git tag Local default local>abc/foo default https://github.company.com/abc/foo default.json Default branch Local with preset path local>abc/foo:xyz xyz https://github.company.com/abc/foo xyz.json Default branch Local with preset path (JSON5) local>abc/foo:xyz.json5 xyz https://github.company.com/abc/foo xyz.json5 Default branch Local default with a tag local>abc/foo#1.5.4 default https://github.company.com/abc/foo default.json 1.5.4 Local with preset name with a tag local>abc/foo:xyz#1.5.4 xyz https://github.company.com/abc/foo xyz.json 1.5.4 Local with preset name and path with a tag local>abc/foo//path/xyz#1.5.4 xyz https://github.company.com/abc/foo path/xyz.json 1.5.4 Local with subpreset name and tag local>abc/foo:xyz/sub#1.5.4 sub https://github.company.com/abc/foo xyz.json 1.5.4 Tip You can't combine the path and sub-preset syntaxes. This means that anything in the form provider>owner/repo//path/to/file:subsubpreset is not supported. One workaround is to use distinct files instead of sub-presets. Example configs \u00b6 An example of a small rule is :preserveSemverRanges , which has the description \"Preserve (but continue to upgrade) any existing semver ranges\". It simply sets the configuration option rangeStrategy to replace . An example of a full config is config:base , which is Renovate's default configuration. It mostly uses Renovate config defaults but adds a few smart customisations such as grouping monorepo packages together. Note The :xyz naming convention (with : prefix) is a special shorthand for the default: presets. e.g. :xyz is equivalent to default:xyz . How to Use Preset Configs \u00b6 By default, the Renovate App's onboarding process will suggest [\"config:base]\" . If you are self hosting you must add \"onboardingConfig\": { \"extends\": [\"config:base\"] } to your bot's config. A typical onboarding renovate.json looks like this: { \"extends\" : [ \"config:base\" ] } Say you want to modify the default behavior, for example scheduling Renovate to process upgrades during non-office hours only. To do this you can modify the default renovate.json file like this: { \"extends\" : [ \"config:base\" , \"schedule:nonOfficeHours\" ] } This makes use of the schedules: presets. You can find the Renovate team's preset configs at the \"Config Presets\" section of Renovate Docs . Preset Parameters \u00b6 If you browse the \"default\" presets, you will see some that have parameters, e.g.: { \"labels\" : { \"description\" : \"Apply labels <code>{{arg0}}</code> and <code>{{arg1}}</code> to PRs\" , \"labels\" : [ \"{{arg0}}\" , \"{{arg1}}\" ] }, \"assignee\" : { \"description\" : \"Assign PRs to <code>{{arg0}}</code>\" , \"assignees\" : [ \"{{arg0}}\" ] } } Here is how you would use these in your Renovate config: { \"extends\" : [ \":labels(dependencies,devops)\" , \":assignee(rarkins)\" ] } In short, the number of {{argx}} parameters in the definition is how many parameters you need to provide. Parameters must be strings, non-quoted, and separated by commas if there are more than one. If you find that you are repeating config a lot, you might consider publishing one of these types of parameterised presets yourself. Or if you think your preset would be valuable for others, please contribute a PR to the Renovate repository. GitHub-hosted Presets \u00b6 To host your preset config on GitHub: Create a new repository. Normally you'd call it renovate-config but it can be named anything Add configuration files to this new repo for any presets you want to share. For the default preset, default.json will be checked. For named presets, <preset-name>.json will be loaded. For example, loading preset library would load library.json . No other files are necessary. In other repos, reference it in an extends array like \"github>owner/name\", for example: { \"extends\" : [ \"github>rarkins/renovate-config\" ] } From then on Renovate will use the Renovate config from the preset repo's default branch. You do not need to add it as a devDependency or add any other files to the preset repo. GitLab-hosted Presets \u00b6 For a private GitLab repository Renovate requires at least Reporter level access. To host your preset config on GitLab: Create a new repository on GitLab. Normally you'd call it renovate-config but it can be named anything Add a default.json to this new repo containing the preset config. No other files are necessary In other repos, reference it in an extends array like \"gitlab>owner/name\", e.g. \"gitlab>rarkins/renovate-config\" Gitea-hosted Presets \u00b6 To host your preset config on Gitea: Create a new repository on Gitea. Normally you'd call it renovate-config but you can use any name you want Add a default.json to this new repository containing the preset config. No other files are necessary In other repositories, reference it in an extends array like \"gitea>owner/name\" , e.g. \"gitea>rarkins/renovate-config\" Local presets \u00b6 Renovate also supports local presets, e.g. presets that are hosted on the same platform as the target repository. This is especially helpful in self-hosted scenarios where public presets cannot be used. Local presets are specified either by leaving out any prefix, e.g. owner/name , or explicitly by adding a local> prefix, e.g. local>owner/name . Renovate will determine the current platform and look up the preset from there. Contributing to presets \u00b6 Have you configured a rule that you think others might benefit from? Please consider contributing it to the Renovate repository so that it gains higher visibility and saves others from reinventing the same thing. Organization level presets \u00b6 Whenever repository onboarding happens, Renovate checks if the current user/group/org has a default config to extend. It looks for: A repository called renovate-config under the same user/group/org with a default.json file or A repository named like .{{platform}} (e.g. .github ) under the same user/group/org with renovate-config.json If found, that repository's preset will be suggested as the sole extended preset, and any existing onboardingConfig config will be ignored/overridden. For example the result may be: { \"$schema\" : \"https://docs.renovatebot.com/renovate-schema.json\" , \"extends\" : [ \"local>myorgname/.github:renovate-config\" ] } npm-hosted presets \u00b6 Warning Using npm-hosted presets is deprecated, we recommend you do not follow these instructions and instead use a local preset. If you manage multiple repositories using Renovate and want the same custom config across all or most of them, then you might want to consider publishing your own preset config so that you can \"extend\" it in every applicable repository. That way when you want to change your Renovate configuration you can make the change in one location rather than having to copy/paste it to every repository individually. Let's say that your username on npm and elsewhere is \"fastcore\". In that case, you can choose between publishing your preset config package as @fastcore/renovate-config or renovate-config-fastcore . Let's assume you choose renovate-config-fastcore as the package name. You then need to publish the renovate-config-fastcore package where the package.json has the field renovate-config and then put your config under the field default . For example: { \"name\" : \"renovate-config-fastcore\" , \"version\" : \"0.0.1\" , \"renovate-config\" : { \"default\" : { \"extends\" : [ \"config:base\" , \"schedule:nonOfficeHours\" ] } } } Then in each of your repositories you can add your Renovate config like: { \"extends\" : [ \"fastcore\" ] } Any repository including this config will then adopt the rules of the default library preset but schedule it on weeknights or weekends. If you prefer to publish using the namespace @fastcore/renovate-config then you would use the @ prefix instead: { \"extends\" : [ \"@fastcore\" ] }","title":"Presets"},{"location":"config-presets/#shareable-config-presets","text":"This document describes how to configure your shared presets. Read the Key concepts, presets page to learn more about presets in general. Shareable config presets can only be used with the JSON format, other formats are not supported. Warning default.json is intended for use with presets only! Also, do not use a renovate.json file as a preset. Info We've deprecated the use of a renovate.json file for presets as this can cause issues if the repository configuration uses a renovate.json file as well. Tip Describe what your preset is doing by using the \"description\" field. This way your configuration is self-documenting.","title":"Shareable Config Presets"},{"location":"config-presets/#extending-from-a-preset","text":"To use a preset put it in an extends array within your Renovate config. Presets can be nested.","title":"Extending from a preset"},{"location":"config-presets/#preset-hosting","text":"Presets should be hosted in repositories, which usually means the same platform host as Renovate is running against. Warning npm-based presets are deprecated and support will be removed in a future major release. You can set a Git tag (like a SemVer) to use a specific release of your shared config.","title":"Preset Hosting"},{"location":"config-presets/#github","text":"name example use preset resolves as filename Git tag GitHub default github>abc/foo default https://github.com/abc/foo default.json Default branch GitHub with preset name github>abc/foo:xyz xyz https://github.com/abc/foo xyz.json Default branch GitHub with preset name (JSON5) github>abc/foo:xyz.json5 xyz https://github.com/abc/foo xyz.json5 Default branch GitHub default with a tag github>abc/foo#1.5.4 default https://github.com/abc/foo default.json 1.5.4 GitHub with preset name with a tag github>abc/foo:xyz#1.5.4 xyz https://github.com/abc/foo xyz.json 1.5.4 GitHub with preset name and path with a tag github>abc/foo//path/xyz#1.5.4 xyz https://github.com/abc/foo path/xyz.json 1.5.4 GitHub with subpreset name and tag github>abc/foo:xyz/sub#1.5.4 sub https://github.com/abc/foo xyz.json 1.5.4","title":"GitHub"},{"location":"config-presets/#gitlab","text":"name example use preset resolves as filename Git tag GitLab default gitlab>abc/foo default https://gitlab.com/abc/foo default.json Default branch GitLab with preset name gitlab>abc/foo:xyz xyz https://gitlab.com/abc/foo xyz.json Default branch GitLab with preset name (JSON5) gitlab>abc/foo:xyz.json5 xyz https://gitlab.com/abc/foo xyz.json5 Default branch GitLab default with a tag gitlab>abc/foo#1.5.4 default https://gitlab.com/abc/foo default.json 1.5.4 GitLab with preset name with a tag gitlab>abc/foo:xyz#1.5.4 xyz https://gitlab.com/abc/foo xyz.json 1.5.4 GitLab with preset name and path with a tag gitlab>abc/foo//path/xyz#1.5.4 xyz https://gitlab.com/abc/foo path/xyz.json 1.5.4 GitLab with subpreset name and tag gitlab>abc/foo:xyz/sub#1.5.4 sub https://gitlab.com/abc/foo xyz.json 1.5.4","title":"GitLab"},{"location":"config-presets/#gitea","text":"name example use preset resolves as filename Git tag Gitea default gitea>abc/foo default https://gitea.com/abc/foo default.json Default branch Gitea with preset name gitea>abc/foo:xyz xyz https://gitea.com/abc/foo xyz.json Default branch Gitea with preset name (JSON5) gitea>abc/foo:xyz.json5 xyz https://gitea.com/abc/foo xyz.json5 Default branch Gitea default with a tag gitea>abc/foo#1.5.4 default https://gitea.com/abc/foo default.json 1.5.4 Gitea with preset name with a tag gitea>abc/foo:xyz#1.5.4 xyz https://gitea.com/abc/foo xyz.json 1.5.4 Gitea with preset name and path with a tag gitea>abc/foo//path/xyz#1.5.4 xyz https://gitea.com/abc/foo path/xyz.json 1.5.4 Gitea with subpreset name and tag gitea>abc/foo:xyz/sub#1.5.4 sub https://gitea.com/abc/foo xyz.json 1.5.4","title":"Gitea"},{"location":"config-presets/#self-hosted-git","text":"name example use preset resolves as filename Git tag Local default local>abc/foo default https://github.company.com/abc/foo default.json Default branch Local with preset path local>abc/foo:xyz xyz https://github.company.com/abc/foo xyz.json Default branch Local with preset path (JSON5) local>abc/foo:xyz.json5 xyz https://github.company.com/abc/foo xyz.json5 Default branch Local default with a tag local>abc/foo#1.5.4 default https://github.company.com/abc/foo default.json 1.5.4 Local with preset name with a tag local>abc/foo:xyz#1.5.4 xyz https://github.company.com/abc/foo xyz.json 1.5.4 Local with preset name and path with a tag local>abc/foo//path/xyz#1.5.4 xyz https://github.company.com/abc/foo path/xyz.json 1.5.4 Local with subpreset name and tag local>abc/foo:xyz/sub#1.5.4 sub https://github.company.com/abc/foo xyz.json 1.5.4 Tip You can't combine the path and sub-preset syntaxes. This means that anything in the form provider>owner/repo//path/to/file:subsubpreset is not supported. One workaround is to use distinct files instead of sub-presets.","title":"Self-hosted Git"},{"location":"config-presets/#example-configs","text":"An example of a small rule is :preserveSemverRanges , which has the description \"Preserve (but continue to upgrade) any existing semver ranges\". It simply sets the configuration option rangeStrategy to replace . An example of a full config is config:base , which is Renovate's default configuration. It mostly uses Renovate config defaults but adds a few smart customisations such as grouping monorepo packages together. Note The :xyz naming convention (with : prefix) is a special shorthand for the default: presets. e.g. :xyz is equivalent to default:xyz .","title":"Example configs"},{"location":"config-presets/#how-to-use-preset-configs","text":"By default, the Renovate App's onboarding process will suggest [\"config:base]\" . If you are self hosting you must add \"onboardingConfig\": { \"extends\": [\"config:base\"] } to your bot's config. A typical onboarding renovate.json looks like this: { \"extends\" : [ \"config:base\" ] } Say you want to modify the default behavior, for example scheduling Renovate to process upgrades during non-office hours only. To do this you can modify the default renovate.json file like this: { \"extends\" : [ \"config:base\" , \"schedule:nonOfficeHours\" ] } This makes use of the schedules: presets. You can find the Renovate team's preset configs at the \"Config Presets\" section of Renovate Docs .","title":"How to Use Preset Configs"},{"location":"config-presets/#preset-parameters","text":"If you browse the \"default\" presets, you will see some that have parameters, e.g.: { \"labels\" : { \"description\" : \"Apply labels <code>{{arg0}}</code> and <code>{{arg1}}</code> to PRs\" , \"labels\" : [ \"{{arg0}}\" , \"{{arg1}}\" ] }, \"assignee\" : { \"description\" : \"Assign PRs to <code>{{arg0}}</code>\" , \"assignees\" : [ \"{{arg0}}\" ] } } Here is how you would use these in your Renovate config: { \"extends\" : [ \":labels(dependencies,devops)\" , \":assignee(rarkins)\" ] } In short, the number of {{argx}} parameters in the definition is how many parameters you need to provide. Parameters must be strings, non-quoted, and separated by commas if there are more than one. If you find that you are repeating config a lot, you might consider publishing one of these types of parameterised presets yourself. Or if you think your preset would be valuable for others, please contribute a PR to the Renovate repository.","title":"Preset Parameters"},{"location":"config-presets/#github-hosted-presets","text":"To host your preset config on GitHub: Create a new repository. Normally you'd call it renovate-config but it can be named anything Add configuration files to this new repo for any presets you want to share. For the default preset, default.json will be checked. For named presets, <preset-name>.json will be loaded. For example, loading preset library would load library.json . No other files are necessary. In other repos, reference it in an extends array like \"github>owner/name\", for example: { \"extends\" : [ \"github>rarkins/renovate-config\" ] } From then on Renovate will use the Renovate config from the preset repo's default branch. You do not need to add it as a devDependency or add any other files to the preset repo.","title":"GitHub-hosted Presets"},{"location":"config-presets/#gitlab-hosted-presets","text":"For a private GitLab repository Renovate requires at least Reporter level access. To host your preset config on GitLab: Create a new repository on GitLab. Normally you'd call it renovate-config but it can be named anything Add a default.json to this new repo containing the preset config. No other files are necessary In other repos, reference it in an extends array like \"gitlab>owner/name\", e.g. \"gitlab>rarkins/renovate-config\"","title":"GitLab-hosted Presets"},{"location":"config-presets/#gitea-hosted-presets","text":"To host your preset config on Gitea: Create a new repository on Gitea. Normally you'd call it renovate-config but you can use any name you want Add a default.json to this new repository containing the preset config. No other files are necessary In other repositories, reference it in an extends array like \"gitea>owner/name\" , e.g. \"gitea>rarkins/renovate-config\"","title":"Gitea-hosted Presets"},{"location":"config-presets/#local-presets","text":"Renovate also supports local presets, e.g. presets that are hosted on the same platform as the target repository. This is especially helpful in self-hosted scenarios where public presets cannot be used. Local presets are specified either by leaving out any prefix, e.g. owner/name , or explicitly by adding a local> prefix, e.g. local>owner/name . Renovate will determine the current platform and look up the preset from there.","title":"Local presets"},{"location":"config-presets/#contributing-to-presets","text":"Have you configured a rule that you think others might benefit from? Please consider contributing it to the Renovate repository so that it gains higher visibility and saves others from reinventing the same thing.","title":"Contributing to presets"},{"location":"config-presets/#organization-level-presets","text":"Whenever repository onboarding happens, Renovate checks if the current user/group/org has a default config to extend. It looks for: A repository called renovate-config under the same user/group/org with a default.json file or A repository named like .{{platform}} (e.g. .github ) under the same user/group/org with renovate-config.json If found, that repository's preset will be suggested as the sole extended preset, and any existing onboardingConfig config will be ignored/overridden. For example the result may be: { \"$schema\" : \"https://docs.renovatebot.com/renovate-schema.json\" , \"extends\" : [ \"local>myorgname/.github:renovate-config\" ] }","title":"Organization level presets"},{"location":"config-presets/#npm-hosted-presets","text":"Warning Using npm-hosted presets is deprecated, we recommend you do not follow these instructions and instead use a local preset. If you manage multiple repositories using Renovate and want the same custom config across all or most of them, then you might want to consider publishing your own preset config so that you can \"extend\" it in every applicable repository. That way when you want to change your Renovate configuration you can make the change in one location rather than having to copy/paste it to every repository individually. Let's say that your username on npm and elsewhere is \"fastcore\". In that case, you can choose between publishing your preset config package as @fastcore/renovate-config or renovate-config-fastcore . Let's assume you choose renovate-config-fastcore as the package name. You then need to publish the renovate-config-fastcore package where the package.json has the field renovate-config and then put your config under the field default . For example: { \"name\" : \"renovate-config-fastcore\" , \"version\" : \"0.0.1\" , \"renovate-config\" : { \"default\" : { \"extends\" : [ \"config:base\" , \"schedule:nonOfficeHours\" ] } } } Then in each of your repositories you can add your Renovate config like: { \"extends\" : [ \"fastcore\" ] } Any repository including this config will then adopt the rules of the default library preset but schedule it on weeknights or weekends. If you prefer to publish using the namespace @fastcore/renovate-config then you would use the @ prefix instead: { \"extends\" : [ \"@fastcore\" ] }","title":"npm-hosted presets"},{"location":"configuration-options/","text":"Configuration Options \u00b6 This document describes all the configuration options you may configure in a Renovate configuration file. Any config you define applies to the whole repository (e.g. if you have a monorepo). You can store your Renovate configuration file in one of the following locations: renovate.json renovate.json5 .github/renovate.json .github/renovate.json5 .gitlab/renovate.json .gitlab/renovate.json5 .renovaterc .renovaterc.json package.json (within a \"renovate\" section) Warning Storing the Renovate configuration in a package.json file is deprecated and support may be removed in the future. When renovating a repository, Renovate tries to detect the configuration files in the order listed above, and stops after the first one is found. Renovate always uses the config from the repository's default branch, even if that configuration specifies multiple baseBranches . Renovate does not read/override the config from within each base branch if present. Also, be sure to check out Renovate's shareable config presets to save yourself from reinventing any wheels. Shareable config presets only work with the JSON format. If you have any questions about the config options, or want to get help/feedback about a config, go to the discussions tab in the Renovate repository and start a new \"config help\" discussion. We will do our best to answer your question(s). A subtype in the configuration table specifies what type you're allowed to use within the main element. If a config option has a parent defined, it means it's only allowed to configure it within an object with the parent name, such as packageRules or hostRules . When an array or object configuration option is mergeable , it means that values inside it will be added to any existing object or array that existed with the same name. Note Config options with type=string are always non-mergeable, so mergeable=false . addLabels \u00b6 Labels to add to Pull Request. Name Value type array subType string mergeable true cli --add-labels env RENOVATE_ADD_LABELS The labels field is non-mergeable, meaning that any config setting a list of PR labels will replace any existing list. If you want to append labels for matched rules, then define an addLabels array with one (or more) label strings. All matched addLabels strings will be attached to the PR. Consider this example: { \"labels\" : [ \"dependencies\" ], \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"eslint\" ], \"labels\" : [ \"linting\" ] }, { \"matchDepTypes\" : [ \"optionalDependencies\" ], \"addLabels\" : [ \"optional\" ] } ] } With the above config: Optional dependencies will have the labels dependencies and optional ESLint dependencies will have the label linting All other dependencies will have the label dependencies additionalBranchPrefix \u00b6 Additional string value to be appended to branchPrefix . Name Value type string default \"\" env RENOVATE_ADDITIONAL_BRANCH_PREFIX This value defaults to an empty string, and is typically not necessary. Some managers previously populated this field, but they no longer do so by default. You normally don't need to configure this, but one example where it can be useful is combining with parentDir in monorepos to split PRs based on where the package definition is located, e.g. { \"additionalBranchPrefix\" : \"{{parentDir}}-\" } additionalReviewers \u00b6 Additional reviewers for Pull Requests (in contrast to reviewers , this option adds to the existing reviewer list, rather than replacing it). Name Value type array subType string mergeable true cli --additional-reviewers env RENOVATE_ADDITIONAL_REVIEWERS In contrast to reviewers , this option adds to the existing reviewer list, rather than replacing it. This makes it suitable for augmenting a preset or base list without displacing the original, for example when adding focused reviewers for a specific package group. aliases \u00b6 Aliases for registries, package manager specific. Name Value type object additionalProperties [object Object] supportedManagers helm-requirements,helmv3,helmfile cli --aliases env RENOVATE_ALIASES The aliases object is used for configuring registry aliases. Currently it is needed/supported for the helm-requirements , helmv3 and helmfile managers only. The above managers include this default alias: { \"aliases\" : { \"stable\" : \"https://charts.helm.sh/stable\" } } Alias values must be properly formatted URIs. assignAutomerge \u00b6 Assign reviewers and assignees even if the PR is to be automerged. Name Value type boolean default false cli --assign-automerge env RENOVATE_ASSIGN_AUTOMERGE By default, Renovate will not assign reviewers and assignees to an automerge-enabled PR unless it fails status checks. By configuring this setting to true , Renovate will instead always assign reviewers and assignees for automerging PRs at time of creation. assignees \u00b6 Assignees for Pull Request (either username or email address depending on the platform). Name Value type array subType string cli --assignees env RENOVATE_ASSIGNEES Must be valid usernames on the platform in use. assigneesFromCodeOwners \u00b6 Determine assignees based on configured code owners and changes in PR. Name Value type boolean default false cli --assignees-from-code-owners env RENOVATE_ASSIGNEES_FROM_CODE_OWNERS If enabled Renovate tries to determine PR assignees by matching rules defined in a CODEOWNERS file against the changes in the PR. See GitHub or GitLab documentation for details on syntax and possible file locations. assigneesSampleSize \u00b6 Take a random sample of given size from assignees. Name Value type integer cli --assignees-sample-size env RENOVATE_ASSIGNEES_SAMPLE_SIZE If configured, Renovate will take a random sample of given size from assignees and assign them only, instead of assigning the entire list of assignees you have configured. automerge \u00b6 Whether to automerge branches/PRs automatically, without human intervention. Name Value type boolean default false cli --automerge env RENOVATE_AUTOMERGE By default, Renovate raises PRs but leaves them to someone or something else to merge them. By configuring this setting, you allow Renovate to automerge PRs or even branches. Using automerge reduces the amount of human intervention required. Usually you won't want to automerge all PRs, for example most people would want to leave major dependency updates to a human to review first. You could configure Renovate to automerge all but major this way: { \"packageRules\" : [ { \"matchUpdateTypes\" : [ \"minor\" , \"patch\" , \"pin\" , \"digest\" ], \"automerge\" : true } ] } Also note that this option can be combined with other nested settings, such as dependency type. So for example you could choose to automerge all (passing) devDependencies only this way: { \"packageRules\" : [ { \"matchDepTypes\" : [ \"devDependencies\" ], \"automerge\" : true } ] } Important: Renovate won't automerge on GitHub if a PR has a negative review outstanding. Note On Azure there can be a delay between a PR being set as completed by Renovate, and Azure merging the PR / finishing its tasks. Renovate tries to delay until Azure is in the expected state, but it will continue if it takes too long. In some cases this can result in a dependency not being merged, and a fresh PR being created for the dependency. automergeComment \u00b6 PR comment to add to trigger automerge. Only used if automergeType=pr-comment . Name Value type string default \"automergeComment\" cli --automerge-comment env RENOVATE_AUTOMERGE_COMMENT Use this only if you configure automergeType=\"pr-comment\" . Example use: { \"automerge\" : true , \"automergeType\" : \"pr-comment\" , \"automergeComment\" : \"bors: r+\" } automergeSchedule \u00b6 Limit automerge to these times of day or week. Name Value type array subType string cli --automerge-schedule default [\"at any time\"] Use the automergeSchedule option to define times of week or month during which Renovate may automerge its PRs. The default value for automergeSchedule is \"at any time\", which functions the same as setting a null schedule. To configure this option refer to schedule as the syntax is the same. automergeStrategy \u00b6 The merge strategy to use when automerging PRs. Used only if automergeType=pr . Name Value type string allowedValues auto,fast-forward,merge-commit,rebase,squash default \"auto\" supportedPlatforms bitbucket cli --automerge-strategy env RENOVATE_AUTOMERGE_STRATEGY This setting is only applicable if you opt-in by configuring automerge to true and automergeType to pr for any of your dependencies. The automerge strategy defaults to auto , in which Renovate will make its best guess as to how to merge pull requests. This generally results in Renovate respecting the strategy configured in the platform itself for the repository if possible. Acceptable values are: auto , in which the choice is left to Renovate fast-forward , which generally involves no new commits in the resultant tree, but \"fast-forwarding\" the main branch reference merge-commit , which generally involves synthesizing a new merge commit rebase , which generally involves rewriting history as part of the merge \u2014 but usually retaining the individual commits squash , which generally involves flattening the commits that are being merged into a single new commit Not all platforms support all pull request merge strategies. In cases where a merge strategy is not supported by the platform, Renovate will hold off on merging instead of silently merging in a way you didn't wish for. The only platform that supports automergeStrategy is Bitbucket Cloud. automergeType \u00b6 How to automerge, if enabled. Name Value type string allowedValues branch,pr,pr-comment default \"pr\" cli --automerge-type env RENOVATE_AUTOMERGE_TYPE This setting is only applicable if you opt in to configure automerge to true for any of your dependencies. Automerging defaults to using Pull Requests ( automergeType=\"pr\" ). In that case Renovate first creates a branch and associated Pull Request, and then automerges the PR on a subsequent run once it detects the PR's status checks are \"green\". If by the next run the PR is already behind the base branch it will be automatically rebased, because Renovate only automerges branches which are up-to-date and green. If Renovate is scheduled for hourly runs on the repository but commits are made every 15 minutes to the main branch, then an automerge like this will keep getting deferred with every rebase. Tip If you have no tests but still want Renovate to automerge, you need to add \"ignoreTests\": true to your configuration. If you prefer that Renovate more silently automerge without Pull Requests at all, you can configure \"automergeType\": \"branch\" . In this case Renovate will: Create the branch, wait for test results Rebase it any time it gets out of date with the base branch Automerge the branch commit if it's: (a) up-to-date with the base branch, and (b) passing all tests As a backup, raise a PR only if either: (a) tests fail, or (b) tests remain pending for too long (default: 24 hours) The final value for automergeType is \"pr-comment\" , intended only for users who already have a \"merge bot\" such as bors-ng and want Renovate to not actually automerge by itself and instead tell bors-ng to merge for it, by using a comment in the PR. If you're not already using bors-ng or similar, don't worry about this option. azureAutoApprove \u00b6 If set to true , Azure DevOps PRs will be automatically approved. Name Value type boolean default false supportedPlatforms azure cli --azure-auto-approve env RENOVATE_AZURE_AUTO_APPROVE Setting this to true will automatically approve the PRs in Azure DevOps. You can also configure this using packageRules if you want to use it selectively (e.g. per-package). azureWorkItemId \u00b6 The id of an existing work item on Azure Boards to link to each PR. Name Value type integer default 0 supportedPlatforms azure cli --azure-work-item-id env RENOVATE_AZURE_WORK_ITEM_ID When creating a PR in Azure DevOps, some branches can be protected with branch policies to check for linked work items . Creating a work item in Azure DevOps is beyond the scope of Renovate, but Renovate can link an already existing work item when creating PRs. baseBranches \u00b6 An array of one or more custom base branches to be processed. If left empty, the default branch will be chosen. Name Value type array env RENOVATE_BASE_BRANCHES By default, Renovate will detect and process only the repository's default branch. For most projects, this is the expected approach. Renovate also allows users to explicitly configure baseBranches , e.g. for use cases such as: You wish Renovate to process only a non-default branch, e.g. dev : \"baseBranches\": [\"dev\"] You have multiple release streams you need Renovate to keep up to date, e.g. in branches main and next : \"baseBranches\": [\"main\", \"next\"] It's possible to add this setting into the renovate.json file as part of the \"Configure Renovate\" onboarding PR. If so then Renovate will reflect this setting in its description and use package file contents from the custom base branch(es) instead of default. Note The baseBranches config option is not supported when forkMode is enabled, including in the Forking Renovate app. bbUseDefaultReviewers \u00b6 Use the default reviewers (Bitbucket only). Name Value type boolean default true supportedPlatforms bitbucket,bitbucket-server cli --bb-use-default-reviewers env RENOVATE_BB_USE_DEFAULT_REVIEWERS Configuring this to true means that Renovate will detect and apply the default reviewers rules to PRs (Bitbucket only). branchConcurrentLimit \u00b6 Limit to a maximum of x concurrent branches. 0 means no limit, null (default) inherits value from prConcurrentLimit . Name Value type integer cli --branch-concurrent-limit env RENOVATE_BRANCH_CONCURRENT_LIMIT By default, Renovate won't enforce any concurrent branch limits. The config:base preset that many extend from limits the number of concurrent branches to 10, but in many cases a limit as low as 3 or 5 can be most efficient for a repository. If you want the same limit for both concurrent branches and concurrent PRs, then just set a value for prConcurrentLimit and it will be reused for branch calculations too. But if you want to allow more concurrent branches than concurrent PRs, you can configure both values (e.g. branchConcurrentLimit=5 and prConcurrentLimit=3 ). This limit is enforced on a per-repository basis. Example config: { \"branchConcurrentLimit\" : 3 } Warning Leaving PRs/branches as unlimited or as a high number increases the time it takes for Renovate to process a repository. If you find that Renovate is too slow when rebasing out-of-date branches, decrease the branchConcurrentLimit . If you have too many concurrent branches which rebase themselves each run, Renovate can take a lot of time to rebase. Solutions: Decrease the concurrent branch limit (note: this won't go and delete any existing, so won't have an effect until you either merge or close existing ones manually) Remove automerge and/or automatic rebasing (set rebaseWhen to conflicted ). However if you have branch protection saying PRs must be up to date then it's not ideal to remove automatic rebasing branchName \u00b6 Branch name template. Name Value type string default \"{{{branchPrefix}}}{{{additionalBranchPrefix}}}{{{branchTopic}}}\" env RENOVATE_BRANCH_NAME Warning We strongly recommended that you do not configure this field directly. Use at your own risk. If you truly need to configure this then it probably means either: You are hopefully mistaken, and there's a better approach you should use, so open a new \"config help\" discussion at the Renovate discussions tab or You have a use case we didn't expect and we should have a feature request from you to add it to the project branchPrefix \u00b6 Prefix to use for all branch names. Name Value type string default \"renovate/\" cli --branch-prefix env RENOVATE_BRANCH_PREFIX You can modify this field if you want to change the prefix used. For example if you want branches to be like deps/eslint-4.x instead of renovate/eslint-4.x then you configure branchPrefix = deps/ . Or if you wish to avoid forward slashes in branch names then you could use renovate_ instead, for example. branchPrefix must be configured at the root of the configuration (e.g. not within any package rule) and is not allowed to use template values. e.g. instead of renovate/{{parentDir}}- , configure the template part in additionalBranchPrefix , like \"additionalBranchPrefix\": \"{{parentDir}}-\" . Note This setting does not change the default onboarding branch name, i.e. renovate/configure . If you wish to change that too, you need to also configure the field onboardingBranch in your global bot config. branchPrefixOld \u00b6 Old Prefix to check for existing PRs. Name Value type string default \"renovate/\" cli --branch-prefix-old env RENOVATE_BRANCH_PREFIX_OLD Renovate uses branch names as part of its checks to see if an update PR was created previously, and already merged or ignored. If you change branchPrefix , then no previously closed PRs will match, which could lead to Renovate recreating PRs in such cases. Instead, set the old branchPrefix value as branchPrefixOld to allow Renovate to look for those branches too, and avoid this happening. branchTopic \u00b6 Branch topic. Name Value type string default \"{{{depNameSanitized}}}-{{{newMajor}}}{{#if separateMinorPatch}}{{#if isPatch}}.{{{newMinor}}}{{/if}}{{/if}}.x{{#if isLockfileUpdate}}-lockfile{{/if}}\" env RENOVATE_BRANCH_TOPIC This field is combined with branchPrefix and additionalBranchPrefix to form the full branchName . branchName uniqueness is important for dependency update grouping or non-grouping so be cautious about ever editing this field manually. This is an advance field and it's recommend you seek a config review before applying it. bumpVersion \u00b6 Bump the version in the package file being updated. Name Value type string allowedValues major,minor,patch supportedManagers helmv3,npm,maven,sbt cli --bump-version env RENOVATE_BUMP_VERSION default null Currently this setting supports helmv3 , npm , maven and sbt only, so raise a feature request if you have a use for it with other package managers. Its purpose is if you want Renovate to update the version field within your package file any time it updates dependencies within. Usually this is for automatic release purposes, so that you don't need to add another step after Renovate before you can release a new version. Configure this value to \"patch\" , \"minor\" or \"major\" to have Renovate update the version in your edited package file. e.g. if you wish Renovate to always increase the target package.json version with a patch update, configure this to \"patch\" . For npm only you can also configure this field to \"mirror:x\" where x is the name of a package in the package.json . Doing so means that the package.json version field will mirror whatever the version is that x depended on. Make sure that version is a pinned version of course, as otherwise it won't be valid. For sbt note that Renovate will update the version string only for packages that have the version string in their project's built.sbt file. cloneSubmodules \u00b6 Set to true to enable initialization of submodules during repository clone. Name Value type boolean default false cli --clone-submodules env RENOVATE_CLONE_SUBMODULES Enabling this option will mean that any detected Git submodules will be cloned at time of repository clone. Important: private submodules aren't supported by Renovate, unless the underlying ssh layer already has the correct permissions. commitBody \u00b6 Commit message body template. Will be appended to commit message, separated by two line returns. Name Value type string env RENOVATE_COMMIT_BODY default null Configure this if you wish Renovate to add a commit body, otherwise Renovate just uses a regular single-line commit. For example, To add [skip ci] to every commit you could configure: { \"commitBody\" : \"[skip ci]\" } Another example would be if you want to configure a DCO signoff to each commit. commitBodyTable \u00b6 If enabled, append a table in the commit message body describing all updates in the commit. Name Value type boolean default false cli --commit-body-table env RENOVATE_COMMIT_BODY_TABLE commitMessage \u00b6 Message to use for commit messages and pull request titles. Name Value type string default \"{{{commitMessagePrefix}}} {{{commitMessageAction}}} {{{commitMessageTopic}}} {{{commitMessageExtra}}} {{{commitMessageSuffix}}}\" env RENOVATE_COMMIT_MESSAGE Warning Editing of commitMessage directly is now deprecated and not recommended. Please instead edit the fields such as commitMessageAction , commitMessageExtra , etc. commitMessageAction \u00b6 Action verb to use in commit messages and PR titles. Name Value type string default \"Update\" env RENOVATE_COMMIT_MESSAGE_ACTION This is used to alter commitMessage and prTitle without needing to copy/paste the whole string. Actions may be like Update , Pin , Roll back , Refresh , etc. Check out the default value for commitMessage to understand how this field is used. commitMessageExtra \u00b6 Extra description used after the commit message topic - typically the version. Name Value type string default [template] env RENOVATE_COMMIT_MESSAGE_EXTRA This is used to alter commitMessage and prTitle without needing to copy/paste the whole string. The \"extra\" is usually an identifier of the new version, e.g. \"to v1.3.2\" or \"to tag 9.2\". commitMessagePrefix \u00b6 Prefix to add to start of commit messages and PR titles. Uses a semantic prefix if semanticCommits is enabled. Name Value type string env RENOVATE_COMMIT_MESSAGE_PREFIX default null This is used to alter commitMessage and prTitle without needing to copy/paste the whole string. The \"prefix\" is usually an automatically applied semantic commit prefix, but it can also be statically configured. commitMessageSuffix \u00b6 Suffix to add to end of commit messages and PR titles. Name Value type string env RENOVATE_COMMIT_MESSAGE_SUFFIX default null This is used to add a suffix to commit messages. Usually left empty except for internal use (multiple base branches, and vulnerability alerts). commitMessageTopic \u00b6 The upgrade topic/noun used in commit messages and PR titles. Name Value type string default \"dependency {{depName}}\" env RENOVATE_COMMIT_MESSAGE_TOPIC This is used to alter commitMessage and prTitle without needing to copy/paste the whole string. The \"topic\" is usually refers to the dependency being updated, e.g. \"dependency react\" . composerIgnorePlatformReqs \u00b6 Configure use of --ignore-platform-reqs or --ignore-platform-req for the Composer package manager. Name Value type array subType string cli --composer-ignore-platform-reqs env RENOVATE_COMPOSER_IGNORE_PLATFORM_REQS By default, Renovate will ignore Composer platform requirements as the PHP platform used by Renovate most probably won't match the required PHP environment of your project as configured in your composer.json file. Composer 2.2 and up will be run with --ignore-platform-req='ext-*' --ignore-platform-req='lib-*' , which ignores extension and library platform requirements but not the PHP version itself and should work in most cases. Older Composer versions will be run with --ignore-platform-reqs , which means that all platform constraints (including the PHP version) will be ignored by default. This can result in updated dependencies that are not compatible with your platform. To customize this behaviour, you can explicitly ignore platform requirements (for example ext-zip ) by setting them separately in this array. Each item will be added to the Composer command with --ignore-platform-req , resulting in it being ignored during its invocation. Note that this requires your project to use Composer V2, as V1 doesn't support excluding single platform requirements. The used PHP version will be guessed automatically from your composer.json definition, so php should not be added as explicit dependency. If an empty array is configured, Renovate uses its default behaviour. Set to null (not recommended) to fully omit --ignore-platform-reqs/--ignore-platform-req during Composer invocation. This requires the Renovate image to be fully compatible with your Composer platform requirements in order for the Composer invocation to succeed, otherwise Renovate will fail to create the updated lock file. The Composer output should inform you about the reasons the update failed. confidential \u00b6 If enabled, issues created by Renovate are set as confidential. Name Value type boolean default false supportedPlatforms gitlab cli --confidential env RENOVATE_CONFIDENTIAL If enabled, all issues created by Renovate are set as confidential, even in a public repository. Note The Dependency Dashboard issue will also be confidential. By default issues created by Renovate are visible to all users. Note This option is applicable to GitLab only. configWarningReuseIssue \u00b6 Set this to false to make Renovate create a new issue for each config warning, instead of reopening or reusing an existing issue. Name Value type boolean default true cli --config-warning-reuse-issue env RENOVATE_CONFIG_WARNING_REUSE_ISSUE Renovate's default behavior is to reuse/reopen a single Config Warning issue in each repository so as to keep the \"noise\" down. However for some people this has the downside that the config warning won't be sorted near the top if you view issues by creation date. Configure this option to false if you prefer Renovate to open a new issue whenever there is a config warning. constraints \u00b6 Configuration object to define language or manager version constraints. Name Value type object mergeable true supportedManagers bundler,composer,gomod,npm,pipenv,poetry env RENOVATE_CONSTRAINTS Constraints are used in package managers which use third-party tools to update \"artifacts\" like lock files or checksum files. Typically, the constraint is detected automatically by Renovate from files within the repository and there is no need to manually configure it. Manually specifying constraints is supported for ruby , bundler , composer , go , npm , yarn , pnpm , python , pipenv , and poetry . Constraints are also used to manually restrict which datasource versions are possible to upgrade to based on their language support. For now this datasource constraint feature only supports python , other compatibility restrictions will be added in the future. { \"constraints\" : { \"python\" : \"2.7\" } } If you need to override constraints that Renovate detects from the repository, wrap it in the force object like so: { \"force\" : { \"constraints\" : { \"node\" : \"< 15.0.0\" } } } Note Make sure not to mix this up with the term compatibility , which Renovate uses in the context of version releases, e.g. if a Docker image is node:12.16.0-alpine then the -alpine suffix represents compatibility . defaultRegistryUrls \u00b6 List of registry URLs to use as the default for a datasource. Name Value type array subType string Override a datasource's default registries with this config option. The datasources's customRegistrySupport value must be true for the config option to work. Default registries are only used when both: The manager did not extract any registryUrls values, and No registryUrls values have been applied via config, such as packageRules Think of defaultRegistryUrls as a way to specify the \"fallback\" registries for a datasource, for use when no registryUrls are extracted or configured. Compare that to registryUrls , which are a way to override registries. dependencyDashboard \u00b6 Whether to create a \"Dependency Dashboard\" issue in the repository. Name Value type boolean default false cli --dependency-dashboard env RENOVATE_DEPENDENCY_DASHBOARD Starting from version v26.0.0 the \"Dependency Dashboard\" is enabled by default as part of the commonly-used config:base preset. To disable the Dependency Dashboard, add the preset :disableDependencyDashboard or set dependencyDashboard to false . { \"extends\" : [ \"config:base\" , \":disableDependencyDashboard\" ] } Configuring dependencyDashboard to true will lead to the creation of a \"Dependency Dashboard\" issue within the repository. This issue has a list of all PRs pending, open, closed (unmerged) or in error. The goal of this issue is to give visibility into all updates that Renovate is managing. Examples of what having a Dependency Dashboard will allow you to do: View all PRs in one place, rather than having to filter PRs by author Rebase/retry multiple PRs without having to open each individually Override any rate limiting (e.g. concurrent PRs) or scheduling to force Renovate to create a PR that would otherwise be suppressed Recreate an unmerged PR (e.g. for a major update that you postponed by closing the original PR) Tip Just enabling the Dependency Dashboard doesn't change the \"control flow\" of Renovate. Renovate still creates and manages PRs, and still follows your schedules and rate limits. The Dependency Dashboard gives you extra visibility and control over your updates. dependencyDashboardApproval \u00b6 Controls if updates need manual approval from the Dependency Dashboard issue before PRs are created. Name Value type boolean default false cli --dependency-dashboard-approval env RENOVATE_DEPENDENCY_DASHBOARD_APPROVAL This feature allows you to use Renovate's Dependency Dashboard to force approval of updates before they are created. By setting dependencyDashboardApproval to true in config (including within packageRules ), you can tell Renovate to wait for your approval from the Dependency Dashboard before creating a branch/PR. You can approve a pending PR by ticking the checkbox in the Dependency Dashboard issue. Tip When you set dependencyDashboardApproval to true the Dependency Dashboard issue will be created automatically, you do not need to turn on dependencyDashboard explicitly. You can configure Renovate to wait for approval for: all package upgrades major, minor, patch level upgrades specific package upgrades upgrades coming from specific package managers If you want to approve all upgrades, set dependencyDashboardApproval to true : { \"dependencyDashboardApproval\" : true } If you want to require approval for major updates, set dependencyDashboardApproval to true within a major object: { \"major\" : { \"dependencyDashboardApproval\" : true } } If you want to approve specific packages, set dependencyDashboardApproval to true within a packageRules entry where you have defined a specific package or pattern. { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"^@package-name\" ], \"dependencyDashboardApproval\" : true } ] } dependencyDashboardAutoclose \u00b6 Set to true to let Renovate close the Dependency Dashboard issue if there are no more updates. Name Value type boolean default false cli --dependency-dashboard-autoclose env RENOVATE_DEPENDENCY_DASHBOARD_AUTOCLOSE You can configure this to true if you prefer Renovate to close an existing Dependency Dashboard whenever there are no outstanding PRs left. dependencyDashboardFooter \u00b6 Any text added here will be placed last in the Dependency Dashboard issue body, with a divider separator before it. Name Value type string cli --dependency-dashboard-footer env RENOVATE_DEPENDENCY_DASHBOARD_FOOTER default null dependencyDashboardHeader \u00b6 Any text added here will be placed first in the Dependency Dashboard issue body. Name Value type string default \"This issue provides visibility into Renovate updates and their statuses. [Learn more](https://docs.renovatebot.com/key-concepts/dashboard/)\" cli --dependency-dashboard-header env RENOVATE_DEPENDENCY_DASHBOARD_HEADER dependencyDashboardLabels \u00b6 These labels will always be applied on the Dependency Dashboard issue, even when they have been removed manually. Name Value type array subType string cli --dependency-dashboard-labels env RENOVATE_DEPENDENCY_DASHBOARD_LABELS The labels only get updated when the Dependency Dashboard issue updates its content and/or title. It is pointless to edit the labels, as Renovate bot restores the labels on each run. dependencyDashboardTitle \u00b6 Title to use for the Dependency Dashboard issue. Name Value type string default \"Dependency Dashboard\" cli --dependency-dashboard-title env RENOVATE_DEPENDENCY_DASHBOARD_TITLE Configure this option if you prefer a different title for the Dependency Dashboard. description \u00b6 Plain text description for a config or preset. Name Value type array subType string mergeable true The description field can be used inside any configuration object to add a human-readable description of the object's config purpose. Descriptions fields embedded within presets are also collated as part of the onboarding description. digest \u00b6 Configuration to apply when updating a digest (no change in tag/version). Name Value type object default {\"branchTopic\":\"{{{depNameSanitized}}}-digest\",\"commitMessageExtra\":\"to {{newDigestShort}}\",\"commitMessageTopic\":\"{{{depName}}} digest\"} mergeable true env RENOVATE_DIGEST Add to this object if you wish to define rules that apply only to PRs that update digests. docker \u00b6 Configuration object for Docker language. Name Value type object default {\"versioning\":\"docker\"} mergeable true env RENOVATE_DOCKER Add config here if you wish it to apply to Docker package managers Dockerfile and Docker Compose. If instead you mean to apply settings to any package manager that updates using the Docker datasource , use a package rule instead, e.g. { \"packageRules\" : [ { \"matchDatasources\" : [ \"docker\" ], \"labels\" : [ \"docker-update\" ] } ] } dotnet \u00b6 Configuration object for .NET language. Name Value type object mergeable true env RENOVATE_DOTNET draftPR \u00b6 If set to true then Renovate creates draft PRs, instead of normal status PRs. Name Value type boolean default false supportedPlatforms github,gitlab,azure cli --draft-p-r env RENOVATE_DRAFT_P_R If you want the PRs created by Renovate to be considered as drafts rather than normal PRs, you could add this property to your renovate.json : { \"draftPR\" : true } This option is evaluated at PR/MR creation time and is only supported on the following platforms: GitHub, GitLab, Azure. Note GitLab implements draft status by checking whether the PR's title starts with certain strings. This means that draftPR on GitLab is incompatible with the legacy method of triggering Renovate to rebase a PR by renaming the PR to start with rebase! . enabled \u00b6 Enable or disable Renovate bot. Name Value type boolean default true The most common use of enabled is if you want to turn Renovate's functionality off, for some reason. For example, if you wanted to disable Renovate completely on a repository, you could make this your renovate.json : { \"enabled\" : false } To disable Renovate for all eslint packages, you can configure a package rule like: { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"^eslint\" ], \"enabled\" : false } ] } To disable Renovate for npm devDependencies but keep it for dependencies you could configure: { \"packageRules\" : [ { \"matchManagers\" : [ \"npm\" ], \"matchDepTypes\" : [ \"devDependencies\" ], \"enabled\" : false } ] } enabledManagers \u00b6 A list of package managers to enable. If defined, then all managers not on the list are disabled. Name Value type array cli --enabled-managers env RENOVATE_ENABLED_MANAGERS This is a way to allow only certain package managers and implicitly disable all others. Example: { \"enabledManagers\" : [ \"dockerfile\" , \"npm\" ] } For the full list of available managers, see the Supported Managers documentation. encrypted \u00b6 An object containing configuration encrypted with project key. Name Value type object cli --encrypted env RENOVATE_ENCRYPTED See Private module support for details on how this is used to encrypt npm tokens. Note Encrypted secrets must have at least an org/group scope, and optionally a repository scope. This means that Renovate will check if a secret's scope matches the current repository before applying it, and warn/discard if there is a mismatch. excludeCommitPaths \u00b6 A file that matches any of these glob patterns will not be committed, even if it has been updated. Name Value type array subType string cli --exclude-commit-paths env RENOVATE_EXCLUDE_COMMIT_PATHS Warning For advanced users only! Be careful you know what you're doing with this option. The initial intended use is to allow the user to exclude certain dependencies from being added/removed/modified when \"vendoring\" dependencies. Example: { \"excludeCommitPaths\" : [ \"vendor/golang.org/x/text/**\" ] } The above would mean Renovate would not include files matching the above glob pattern in the commit, even if it thinks they should be updated. extends \u00b6 Configuration presets to use or extend. Note: This config option does not work if you use a config.js file. Name Value type array subType string env RENOVATE_EXTENDS See shareable config presets for details. extractVersion \u00b6 A regex ( re2 ) to extract a version from a datasource's raw version string. Name Value type string format regex default null Only use this config option when the raw version strings from the datasource do not match the expected format that you need in your package file. You must define a \"named capture group\" called version like in the examples below. For example, to extract only the major.minor precision from a GitHub release, the following would work: { \"packageRules\" : [ { \"matchPackageNames\" : [ \"foo\" ], \"extractVersion\" : \"^(?<version>v\\\\d+\\\\.\\\\d+)\" } ] } The above will change a raw version of v1.31.5 to v1.31 , for example. Alternatively, to strip a release- prefix: { \"packageRules\" : [ { \"matchPackageNames\" : [ \"bar\" ], \"extractVersion\" : \"^release-(?<version>.*)$\" } ] } The above will change a raw version of release-2.0.0 to 2.0.0 , for example. A similar one could strip leading v prefixes: { \"packageRules\" : [ { \"matchPackageNames\" : [ \"baz\" ], \"extractVersion\" : \"^v(?<version>.*)$\" } ] } fetchReleaseNotes \u00b6 Controls if release notes are fetched. Name Value type boolean default true Set this to false if you want to disable release notes fetching. Renovate can fetch release notes when they are hosted on one of these platforms: GitHub (.com and Enterprise Server) GitLab (.com and CE/EE) Note Renovate can only show release notes from some platforms and some package managers. We're planning improvements so that Renovate can show more release notes. Read issue 14138 on GitHub to get a overview of the planned work. fileMatch \u00b6 RegEx ( re2 ) pattern for matching manager files. Name Value type array subType string format regex mergeable true fileMatch is used by Renovate to know which files in a repository to parse and extract, and it is possible to override the default values to customize for your project's needs. Sometimes file matches are really simple - for example with Go Modules Renovate looks for any go.mod file, and you probably don't need to change that default. At other times, the possible files is too vague for Renovate to have any default. For default, Kubernetes manifests can exist in any *.yaml file and we don't want Renovate to parse every single YAML file in every repository just in case some of them have a Kubernetes manifest, so Renovate's default fileMatch for manager kubernetes is actually empty ( [] ) and needs the user to tell Renovate what directories/files to look in. Finally, there are cases where Renovate's default fileMatch is good, but you may be using file patterns that a bot couldn't possibly guess about. For example, Renovate's default fileMatch for Dockerfile is ['(^|/|\\\\.)Dockerfile$', '(^|/)Dockerfile[^/]*$'] . This will catch files like backend/Dockerfile , prefix.Dockerfile or Dockerfile-suffix , but it will miss files like ACTUALLY_A_DOCKERFILE.template . Because fileMatch is mergeable, you don't need to duplicate the defaults and could just add the missing file like this: { \"dockerfile\" : { \"fileMatch\" : [ \"^ACTUALLY_A_DOCKERFILE\\\\.template$\" ] } } If you configure fileMatch then it must be within a manager object (e.g. dockerfile in the above example). The full list of supported managers can be found here . filterUnavailableUsers \u00b6 Filter reviewers and assignees based on their availability. Name Value type boolean default false supportedPlatforms gitlab cli --filter-unavailable-users env RENOVATE_FILTER_UNAVAILABLE_USERS When this option is enabled PRs are not assigned to users that are unavailable. This option only works on platforms that support the concept of user availability. For now, you can only use this option on the GitLab platform. followTag \u00b6 If defined, packages will follow this release tag exactly. Name Value type string default null Warning Advanced functionality. Only use this if you're sure you know what you're doing. This functionality requires that the datasource to support distribution streams/tags, such as npm does. The primary use case for this option is if you are following a pre-release tag of a certain dependency, e.g. typescript 's \"insiders\" build. If configured, Renovate bypasses its normal major/minor/patch upgrade logic and stable/unstable consistency logic and keeps your dependency version sync'd strictly to whatever version is in the tag. Beware that Renovate follows tags strictly. For example, if you are following a tag like next and then that stream is released as stable and next is no longer being updated then that means your dependencies also won't be getting updated. gitAuthor \u00b6 Author to use for Git commits. Must conform to RFC5322 . Name Value type string cli --git-author env RENOVATE_GIT_AUTHOR default null You can customize the Git author that's used whenever Renovate creates a commit. The gitAuthor option accepts a RFC5322-compliant string. Danger We strongly recommend that the Git author email you use is unique to Renovate. Otherwise, if another bot or human shares the same email and pushes to one of Renovate's branches then Renovate will mistake the branch as unmodified and potentially force push over the changes. gitIgnoredAuthors \u00b6 Additional Git authors which are ignored by Renovate. Must conform to RFC5322 . Name Value type array subType string cli --git-ignored-authors env RENOVATE_GIT_IGNORED_AUTHORS Specify commit authors ignored by Renovate. By default, Renovate will treat any PR as modified if another Git author has added to the branch. When a PR is considered modified, Renovate won't perform any further commits such as if it's conflicted or needs a version update. If you have other bots which commit on top of Renovate PRs, and don't want Renovate to treat these PRs as modified, then add the other Git author(s) to gitIgnoredAuthors . Example: { \"gitIgnoredAuthors\" : [ \"some-bot@example.org\" ] } gitLabIgnoreApprovals \u00b6 Ignore approval rules for MRs created by Renovate, which is useful for automerge. Name Value type boolean default false cli --git-lab-ignore-approvals env RENOVATE_GIT_LAB_IGNORE_APPROVALS Ignore the default project level approval(s), so that Renovate bot can automerge its merge requests, without needing approval(s). Under the hood, it creates a MR-level approval rule where approvals_required is set to 0 . This option works only when automerge=true , automergeType=pr or automergeType=branch and platformAutomerge=true . Also, approval rules overriding should not be prevented in GitLab settings . golang \u00b6 Configuration object for Go language. Name Value type object default {\"commitMessageTopic\":\"module {{depName}}\"} mergeable true env RENOVATE_GOLANG Configuration added here applies for all Go-related updates. The only supported package manager for Go is the native Go Modules (the gomod manager). For self-hosted users, GOPROXY , GONOPROXY and GOPRIVATE environment variables are supported ( reference ). Usage of direct will fallback to the Renovate-native release fetching mechanism. Also we support the off keyword which will stop any fetching immediately. group \u00b6 Config if groupName is enabled. Name Value type object default {\"branchTopic\":\"{{{groupSlug}}}\",\"commitMessageTopic\":\"{{{groupName}}}\"} mergeable true Warning Advanced functionality only. Do not use unless you know what you're doing. The default configuration for groups are essentially internal to Renovate and you normally shouldn't need to modify them. But you may add settings to any group by defining your own group configuration object. groupName \u00b6 Human understandable name for the dependency group. Name Value type string cli --group-name env RENOVATE_GROUP_NAME There are multiple cases where it can be useful to group multiple upgrades together. Internally Renovate uses this for branches such as \"Pin Dependencies\", \"Lock File Maintenance\", etc. Another example used previously is to group together all related eslint packages, or perhaps angular or babel . To enable grouping, you configure the groupName field to something non-null. The groupName field allows free text and does not have any semantic interpretation by Renovate. All updates sharing the same groupName will be placed into the same branch/PR. For example, to group all non-major devDependencies updates together into a single PR: { \"packageRules\" : [ { \"matchDepTypes\" : [ \"devDependencies\" ], \"matchUpdateTypes\" : [ \"patch\" , \"minor\" ], \"groupName\" : \"devDependencies (non-major)\" } ] } groupSlug \u00b6 Slug to use for group (e.g. in branch name). Will be calculated from groupName if null . Name Value type string By default, Renovate will \"slugify\" the groupName to determine the branch name. For example if you named your group \"devDependencies (non-major)\" then the branchName would be renovate/devdependencies-non-major . If you wished to override this then you could configure like this: { \"packageRules\" : [ { \"matchDepTypes\" : [ \"devDependencies\" ], \"matchUpdateTypes\" : [ \"patch\" , \"minor\" ], \"groupName\" : \"devDependencies (non-major)\" , \"groupSlug\" : \"dev-dependencies\" } ] } As a result of the above, the branchName would be renovate/dev-dependencies instead. Note You shouldn't usually need to configure this unless you really care about your branch names. hashedBranchLength \u00b6 If enabled, branch names will use a hashing function to ensure each branch has that length. Name Value type integer env RENOVATE_HASHED_BRANCH_LENGTH Some code hosting systems have restrictions on the branch name lengths, this option lets you get around these restrictions. You can set the hashedBranchLength option to a number of characters that works for your system and then Renovate will generate branch names with the correct length by hashing additionalBranchPrefix and branchTopic , and then truncating the hash so that the full branch name (including branchPrefix ) has the right number of characters. Example: If you have set branchPrefix: \"deps-\" and hashedBranchLength: 12 it will result in a branch name like deps-5bf36ec instead of the traditional pretty branch name like deps-react-17.x . hostRules \u00b6 Host rules/configuration including credentials. Name Value type array subType object default [{\"timeout\":60000}] cli --host-rules mergeable true env RENOVATE_HOST_RULES The primary purpose of hostRules is to configure credentials for host authentication. You tell Renovate how to match against the host you need authenticated, and then you also tell it which credentials to use. The lookup keys for hostRules are: hostType and matchHost , both of which are optional. Supported credential fields are token , username , password , timeout , enabled and insecureRegistry . Example for configuring docker auth: { \"hostRules\" : [ { \"matchHost\" : \"docker.io\" , \"username\" : \"<some-username>\" , \"password\" : \"<some-password>\" } ] } If multiple hostRules match a request, then they will be applied in the following order/priority: rules with only hostType specified rules with only matchHost specified (sorted by matchHost length if multiple match) rules with both matchHost and hostType specified (sorted by matchHost length if multiple match) To disable requests to a particular host, you can configure a rule like: { \"hostRules\" : [ { \"matchHost\" : \"registry.npmjs.org\" , \"enabled\" : false } ] } A preset alternative to the above is: { \"extends\" : [ \":disableHost(registry.npmjs.org)\" ] } Note Disabling a host is only 100% effective if added to self-hosted config. Renovate currently still checks its cache for results first before trying to connect, so if a public host is blocked in your repository config (e.g. renovate.json ) then it's possible you may get cached results from that host if another repository using the same bot has successfully queried for the same dependency recently. abortIgnoreStatusCodes \u00b6 A list of HTTP status codes safe to ignore even when abortOnError=true . Name Value type array subType number parent hostRules This field can be used to configure status codes that Renovate ignores and passes through when abortOnError is set to true . For example to also skip 404 responses then configure the following: { \"hostRules\" : [ { \"abortOnError\" : true , \"abortIgnoreStatusCodes\" : [ 404 ] } ] } Tip This field is not mergeable, so the last-applied host rule takes precedence. abortOnError \u00b6 If enabled, Renovate will abort its run when HTTP request errors occur. Name Value type boolean parent hostRules default false Use this field to configure Renovate to abort runs for custom hosts. By default, Renovate will only abort for known public hosts, which has the downside that transient errors for other hosts can cause autoclosing of PRs. To abort Renovate runs for http failures from any host: { \"hostRules\" : [ { \"abortOnError\" : true } ] } To abort Renovate runs for any docker datasource failures: { \"hostRules\" : [ { \"hostType\" : \"docker\" , \"abortOnError\" : true } ] } To abort Renovate for errors for a specific docker host: { \"hostRules\" : [ { \"matchHost\" : \"docker.company.com\" , \"abortOnError\" : true } ] } When this field is enabled, Renovate will abort its run if it encounters either (a) any low-level http error (e.g. ETIMEDOUT ) or (b) gets a response not matching any of the configured abortIgnoreStatusCodes (e.g. 500 Internal Error ); authType \u00b6 Authentication type for http header. e.g. \"Bearer\" or \"Basic\" . Use \"Token-Only\" to use only the token without an authorization type. Name Value type string parent hostRules default \"Bearer\" This can be used with token to create a custom http authorization header. An example for npm basic auth with token: { \"hostRules\" : [ { \"matchHost\" : \"npm.custom.org\" , \"token\" : \"<some-token>\" , \"authType\" : \"Basic\" } ] } This will generate the following header: authorization: Basic <some-token> . To use a bare token in the authorization header (required by e.g. Hex) - use the authType \"Token-Only\": { \"hostRules\" : [ { \"matchHost\" : \"https://hex.pm/api/repos/private_repo/\" , \"token\" : \"<some-token>\" , \"authType\" : \"Token-Only\" } ] } This will generate the header authorization: <some-token> . concurrentRequestLimit \u00b6 Limit concurrent requests per host. Name Value type integer parent hostRules Usually the default setting is fine, but you can use concurrentRequestLimit to limit the number of concurrent outstanding requests. You only need to adjust this setting if a datasource is rate limiting Renovate or has problems with the load. The limit will be set for any host it applies to. Example config: { \"hostRules\" : [ { \"matchHost\" : \"github.com\" , \"concurrentRequestLimit\" : 2 } ] } enableHttp2 \u00b6 Enable got HTTP/2 support. Name Value type boolean parent hostRules default false Enable got http2 support. hostType \u00b6 hostType for a package rule. Can be a platform name or a datasource name. Name Value type string parent hostRules default null hostType is another way to filter rules and can be either a platform such as github and bitbucket-server , or it can be a datasource such as docker and rubygems . You usually don't need to configure it in a host rule if you have already configured matchHost and only one host type is in use for those, as is usually the case. hostType can help for cases like an enterprise registry that serves multiple package types and has different authentication for each, although it's often the case that multiple matchHost rules could achieve the same thing. insecureRegistry \u00b6 Explicitly turn on insecure Docker registry access (HTTP). Name Value type boolean parent hostRules default true Warning Advanced config, use at your own risk. Enable this option to allow Renovate to connect to an insecure Docker registry that is http only. This is insecure and is not recommended. Example: { \"hostRules\" : [ { \"matchHost\" : \"reg.insecure.com\" , \"insecureRegistry\" : true } ] } matchHost \u00b6 A domain name, host name or base URL to match against. Name Value type string parent hostRules default null This can be a base URL (e.g. https://api.github.com ) or a hostname like github.com or api.github.com . If the value starts with http(s) then it will only match against URLs which start with the full base URL. Otherwise, it will be matched by checking if the URL's hostname matches the matchHost directly or ends with it. When checking the end of the hostname, a single dot is prefixed to the value of matchHost , if one is not already present, to ensure it can only match against whole domain segments. timeout \u00b6 Timeout (in milliseconds) for queries to external endpoints. Name Value type integer parent hostRules Use this figure to adjust the timeout for queries. The default is 60s, which is quite high. To adjust it down to 10s for all queries, do this: { \"hostRules\" : [ { \"timeout\" : 10000 } ] } ignoreDeprecated \u00b6 Avoid upgrading from a non-deprecated version to a deprecated one. Name Value type boolean default true cli --ignore-deprecated env RENOVATE_IGNORE_DEPRECATED By default, Renovate won't update a dependency version to a deprecated release unless the current version was itself deprecated. The goal of this is to make sure you don't upgrade from a non-deprecated version to a deprecated one just because it's higher than the current version. If for some reason you wish to force deprecated updates with Renovate, you can configure ignoreDeprecated to false , but this is not recommended for most situations. ignoreDeps \u00b6 Dependencies to ignore. Name Value type array subType string mergeable true cli --ignore-deps env RENOVATE_IGNORE_DEPS The ignoreDeps configuration field allows you to define a list of dependency names to be ignored by Renovate. Currently it supports only \"exact match\" dependency names and not any patterns. e.g. to ignore both eslint and eslint-config-base you would add this to your config: { \"ignoreDeps\" : [ \"eslint\" , \"eslint-config-base\" ] } The above is the same as if you wrote this package rule: { \"packageRules\" : [ { \"matchPackageNames\" : [ \"eslint\" , \"eslint-config-base\" ], \"enabled\" : false } ] } ignorePaths \u00b6 Skip any package file whose path matches one of these. Can be a string or glob pattern. Name Value type array mergeable false subType string default [\"**/node_modules/**\",\"**/bower_components/**\"] cli --ignore-paths env RENOVATE_IGNORE_PATHS Renovate will extract dependencies from every file it finds in a repository, unless that file is explicitly ignored. With this setting you can selectively ignore package files that would normally be \"autodiscovered\" and updated by Renovate. For instance if you have a project with an \"examples/\" directory you wish to ignore: { \"ignorePaths\" : [ \"**/examples/**\" ] } Renovate's default ignore is node_modules and bower_components only. If you are extending from the popular config:base preset then it adds ignore patterns for vendor , examples , test(s) and fixtures directories too. ignorePlugins \u00b6 Set this to true if allowPlugins=true but you wish to skip running plugins when updating lock files. Name Value type boolean default false cli --ignore-plugins env RENOVATE_IGNORE_PLUGINS Set this to true if running plugins causes problems. Applicable for Composer only for now. ignorePrAuthor \u00b6 Set to true to fetch the entire list of PRs instead of only those authored by the Renovate user. Name Value type boolean default false cli --ignore-pr-author env RENOVATE_IGNORE_PR_AUTHOR This is usually needed if someone needs to migrate bot accounts, including from hosted app to self-hosted. If ignorePrAuthor is configured to true, it means Renovate will fetch the entire list of repository PRs instead of optimizing to fetch only those PRs which it created itself. You should only want to enable this if you are changing the bot account (e.g. from @old-bot to @new-bot ) and want @new-bot to find and update any existing PRs created by @old-bot . It's recommended to revert this setting once that transition period is over and all old PRs are resolved. ignorePresets \u00b6 A list of presets to ignore, including any that are nested inside an extends array. Name Value type array subType string env RENOVATE_IGNORE_PRESETS Use this if you are extending a complex preset but don't want to use every \"sub preset\" that it includes. For example, consider this config: { \"extends\" : [ \"config:base\" ], \"ignorePresets\" : [ \":prHourlyLimit2\" ] } It would take the entire \"config:base\" preset - which has a lot of sub-presets - but ignore the \":prHourlyLimit2\" rule. ignoreScripts \u00b6 Set this to true if allowScripts=true but you wish to skip running scripts when updating lock files. Name Value type boolean default false supportedManagers npm,composer cli --ignore-scripts env RENOVATE_IGNORE_SCRIPTS Applicable for npm and Composer only for now. Set this to true if running scripts causes problems. ignoreTests \u00b6 Set to true to enable automerging without tests. Name Value type boolean default false cli --ignore-tests env RENOVATE_IGNORE_TESTS Currently Renovate's default behavior is to only automerge if every status check has succeeded. Setting this option to true means that Renovate will ignore all status checks. You can set this if you don't have any status checks but still want Renovate to automerge PRs. Beware: configuring Renovate to automerge without any tests can lead to broken builds on your base branch, please think again before enabling this! ignoreUnstable \u00b6 Ignore versions with unstable SemVer. Name Value type boolean cli --ignore-unstable env RENOVATE_IGNORE_UNSTABLE default true By default, Renovate won't update any package versions to unstable versions (e.g. 4.0.0-rc3 ) unless the current version has the same major.minor.patch and was already unstable (e.g. it was already on 4.0.0-rc2 ). Renovate will also not \"jump\" unstable versions automatically, e.g. if you are on 4.0.0-rc2 and newer versions 4.0.0 and 4.1.0-alpha.1 exist then Renovate will update you to 4.0.0 only. If you need to force permanent unstable updates for a package, you can add a package rule setting ignoreUnstable to false . Also check out the followTag configuration option above if you wish Renovate to keep you pinned to a particular release tag. includeForks \u00b6 Whether to process forked repositories. By default, all forked repositories are skipped. Name Value type boolean default false cli --include-forks env RENOVATE_INCLUDE_FORKS By default, Renovate will skip over any repositories that are forked. This includes if the forked repository has a Renovate config file, because Renovate can't tell if that file was added by the original repository or not. If you wish to enable processing of a forked repository by Renovate, you need to add \"includeForks\": true to your repository config or run the CLI command with --include-forks=true . If you are using the hosted Mend Renovate then this option will be configured to true automatically if you \"Selected\" repositories individually but remain as false if you installed for \"All\" repositories. includePaths \u00b6 Include package files only within these defined paths. Name Value type array subType string cli --include-paths env RENOVATE_INCLUDE_PATHS If you wish for Renovate to process only select paths in the repository, use includePaths . Alternatively, if you need to just exclude certain paths in the repository then consider ignorePaths instead. If you are more interested in including only certain package managers (e.g. npm ), then consider enabledManagers instead. internalChecksFilter \u00b6 When and how to filter based on internal checks. Name Value type string allowedValues strict,flexible,none default \"none\" cli --internal-checks-filter env RENOVATE_INTERNAL_CHECKS_FILTER This setting determines whether Renovate controls when and how filtering of internal checks are performed, particularly when multiple versions of the same update type are available. Currently this applies to the stabilityDays check only. none : No filtering will be performed, and the highest release will be used regardless of whether it's pending or not strict : All pending releases will be filtered. PRs will be skipped unless a non-pending version is available flexible : Similar to strict, but in the case where all versions are pending then a PR will be created with the highest pending version The flexible mode can result in \"flapping\" of Pull Requests, where e.g. a pending PR with version 1.0.3 is first released but then downgraded to 1.0.2 once it passes stabilityDays . We recommend that you use the strict mode, and enable the dependencyDashboard so that you have visibility into suppressed PRs. java \u00b6 Configuration object for all Java package managers. Name Value type object mergeable true env RENOVATE_JAVA Use this configuration option for shared config across all Java projects (Gradle and Maven). js \u00b6 Configuration object for JavaScript language. Name Value type object mergeable true cli --js env RENOVATE_JS Use this configuration option for shared config across npm/Yarn/pnpm and meteor package managers. labels \u00b6 Labels to set in Pull Request. Name Value type array subType string cli --labels env RENOVATE_LABELS By default, Renovate won't add any labels to its PRs. If you want Renovate to do so then define a labels array of one or more label strings. If you want the same label(s) for every PR then you can configure it at the top level of config. However you can also fully override them on a per-package basis. Consider this example: { \"labels\" : [ \"dependencies\" ], \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"eslint\" ], \"labels\" : [ \"linting\" ] } ] } With the above config, every PR raised by Renovate will have the label dependencies while PRs containing eslint -related packages will instead have the label linting . lockFileMaintenance \u00b6 Configuration for lock file maintenance. Name Value type object default {\"enabled\":false,\"recreateClosed\":true,\"rebaseStalePrs\":true,\"branchTopic\":\"lock-file-maintenance\",\"commitMessageAction\":\"Lock file maintenance\",\"commitMessageTopic\":null,\"commitMessageExtra\":null,\"schedule\":[\"before 5am on monday\"],\"groupName\":null,\"prBodyDefinitions\":{\"Change\":\"All locks refreshed\"}} mergeable true env RENOVATE_LOCK_FILE_MAINTENANCE This feature can be used to refresh lock files and keep them up-to-date. \"Maintaining\" a lock file means recreating it so that every dependency version within it is updated to the latest. Supported lock files are: package-lock.json yarn.lock composer.lock Gemfile.lock poetry.lock Cargo.lock jsonnetfile.lock.json Others may be added via feature request. This feature is disabled by default. If you wish to enable this feature then you could add this to your configuration: { \"lockFileMaintenance\" : { \"enabled\" : true } } To reduce \"noise\" in the repository, it defaults its schedule to \"before 5am on monday\" , i.e. to achieve once-per-week semantics. Depending on its running schedule, Renovate may run a few times within that time window - even possibly updating the lock file more than once - but it hopefully leaves enough time for tests to run and automerge to apply, if configured. major \u00b6 Configuration to apply when an update type is major . Name Value type object mergeable true env RENOVATE_MAJOR Add to this object if you wish to define rules that apply only to major updates. minor \u00b6 Configuration to apply when an update type is minor . Name Value type object mergeable true env RENOVATE_MINOR Add to this object if you wish to define rules that apply only to minor updates. node \u00b6 Configuration object for Node version renovation. Name Value type object default {\"commitMessageTopic\":\"Node.js\"} mergeable true env RENOVATE_NODE Using this configuration option allows you to apply common configuration and policies across all Node.js version updates even if managed by different package managers ( npm , yarn , etc.). Check out our Node.js documentation for a comprehensive explanation of how the node option can be used. npmToken \u00b6 npm token used to authenticate with the default registry. Name Value type string cli --npm-token env RENOVATE_NPM_TOKEN default null See Private npm module support for details on how this is used. Typically you would encrypt it and put it inside the encrypted object. npmrc \u00b6 String copy of .npmrc file. Use \\n instead of line breaks. Name Value type string cli --npmrc env RENOVATE_NPMRC default null See Private npm module support for details on how this is used. npmrcMerge \u00b6 Whether to merge config.npmrc with repo .npmrc content if both are found. Name Value type boolean default false cli --npmrc-merge env RENOVATE_NPMRC_MERGE This option exists to provide flexibility about whether npmrc strings in config should override .npmrc files in the repo, or be merged with them. In some situations you need the ability to force override .npmrc contents in a repo ( npmrcMerge=false ) while in others you might want to simply supplement the settings already in the .npmrc ( npmrcMerge=true ). A use case for the latter is if you are a Renovate bot admin and wish to provide a default token for npmjs.org without removing any other .npmrc settings which individual repositories have configured (such as scopes/registries). If false (default), it means that defining config.npmrc will result in any .npmrc file in the repo being overridden and its values ignored. If configured to true , it means that any .npmrc file in the repo will have config.npmrc prepended to it before running npm . packageRules \u00b6 Rules for matching package names. Name Value type array mergeable true packageRules is a powerful feature that lets you apply rules to individual packages or to groups of packages using regex pattern matching. Here is an example if you want to group together all packages starting with eslint into a single branch/PR: { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"^eslint\" ], \"groupName\" : \"eslint packages\" } ] } Note how the above uses matchPackagePatterns with a regex value. Here is an example where you might want to limit the \"noisy\" package aws-sdk to updates just once per week: { \"packageRules\" : [ { \"matchPackageNames\" : [ \"aws-sdk\" ], \"schedule\" : [ \"after 9pm on sunday\" ] } ] } For Maven dependencies, the package name is <groupId:artefactId> , e.g. \"matchPackageNames\": [\"com.thoughtworks.xstream:xstream\"] Note how the above uses matchPackageNames instead of matchPackagePatterns because it is an exact match package name. This is the equivalent of defining \"matchPackagePatterns\": [\"^aws\\-sdk$\"] and hence much simpler. However you can mix together both matchPackageNames and matchPackagePatterns in the same package rule and the rule will be applied if either match. Example: { \"packageRules\" : [ { \"matchPackageNames\" : [ \"neutrino\" ], \"matchPackagePatterns\" : [ \"^@neutrino/\" ], \"groupName\" : \"neutrino monorepo\" } ] } The above rule will group together the neutrino package and any package matching @neutrino/* . Path rules are convenient to use if you wish to apply configuration rules to certain package files using patterns. For example, if you have an examples directory and you want all updates to those examples to use the chore prefix instead of fix , then you could add this configuration: { \"packageRules\" : [ { \"matchPaths\" : [ \"examples/**\" ], \"extends\" : [ \":semanticCommitTypeAll(chore)\" ] } ] } If you wish to limit Renovate to apply configuration rules to certain files in the root repository directory, you have to use matchPaths with either a partial string match or a minimatch pattern. For example you have multiple package.json and want to use dependencyDashboardApproval only on the root package.json : { \"packageRules\" : [ { \"matchPaths\" : [ \"+(package.json)\" ], \"dependencyDashboardApproval\" : true } ] } Important to know: Renovate will evaluate all packageRules and not stop once it gets a first match. You should order your packageRules in order of importance so that later rules can override settings from earlier rules if needed. allowedVersions \u00b6 A version range or regex pattern capturing allowed versions for dependencies. Name Value type string parent packageRules default null Use this - usually within a packageRule - to limit how far to upgrade a dependency. For example, if you wish to upgrade to Angular v1.5 but not to angular v1.6 or higher, you could define this to be <= 1.5 or < 1.6.0 : { \"packageRules\" : [ { \"matchPackageNames\" : [ \"angular\" ], \"allowedVersions\" : \"<=1.5\" } ] } The valid syntax for this will be calculated at runtime because it depends on the versioning scheme, which is itself dynamic. This field also supports Regular Expressions if they begin and end with / . For example, the following will enforce that only 3 or 4-part versions are supported, without any prefixes: { \"packageRules\" : [ { \"matchPackageNames\" : [ \"com.thoughtworks.xstream:xstream\" ], \"allowedVersions\" : \"/^[0-9]+\\\\.[0-9]+\\\\.[0-9]+(\\\\.[0-9]+)?$/\" } ] } This field also supports a special negated regex syntax for ignoring certain versions. Use the syntax !/ / like the following: { \"packageRules\" : [ { \"matchPackageNames\" : [ \"chalk\" ], \"allowedVersions\" : \"!/java$/\" } ] } matchDepTypes \u00b6 List of depTypes to match (e.g. [ peerDependencies ]). Valid only within packageRules object. Name Value type array subType string parent packageRules mergeable true Use this field if you want to limit a packageRule to certain depType values. Invalid if used outside of a packageRule . excludePackageNames \u00b6 Package names to exclude. Valid only within a packageRules object. Name Value type array subType string parent packageRules mergeable true Important : Do not mix this up with the option ignoreDeps . Use ignoreDeps instead if all you want to do is have a list of package names for Renovate to ignore. Use excludePackageNames if you want to have one or more exact name matches excluded in your package rule. See also matchPackageNames . { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"^eslint\" ], \"excludePackageNames\" : [ \"eslint-foo\" ] } ] } The above will match all package names starting with eslint but exclude the specific package eslint-foo . excludePackagePatterns \u00b6 Package name patterns to exclude. Valid only within a packageRules object. Name Value type array subType string format regex parent packageRules mergeable true Use this field if you want to have one or more package name patterns excluded in your package rule. See also matchPackagePatterns . { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"^eslint\" ], \"excludePackagePatterns\" : [ \"^eslint-foo\" ] } ] } The above will match all package names starting with eslint but exclude ones starting with eslint-foo . excludePackagePrefixes \u00b6 Package name prefixes to exclude. Valid only within a packageRules object. Name Value type array subType string parent packageRules mergeable true Use this field if you want to have one or more package name prefixes excluded in your package rule, without needing to write a regex. See also matchPackagePrefixes . { \"packageRules\" : [ { \"matchPackagePrefixes\" : [ \"eslint\" ], \"excludePackagePrefixes\" : [ \"eslint-foo\" ] } ] } The above will match all package names starting with eslint but exclude ones starting with eslint-foo . matchLanguages \u00b6 List of languages to match (e.g. [\"python\"] ). Valid only within a packageRules object. Name Value type array subType string parent packageRules mergeable true Use this field to restrict rules to a particular language. e.g. { \"packageRules\" : [ { \"matchPackageNames\" : [ \"request\" ], \"matchLanguages\" : [ \"python\" ], \"enabled\" : false } ] } matchBaseBranches \u00b6 List of strings containing exact matches (e.g. [\"main\"] ) and/or regex expressions (e.g. [\"/^release\\/.*/\"] ). Valid only within a packageRules object. Name Value type array subType string parent packageRules mergeable true Use this field to restrict rules to a particular branch. e.g. { \"packageRules\" : [ { \"matchBaseBranches\" : [ \"main\" ], \"excludePackagePatterns\" : [ \"^eslint\" ], \"enabled\" : false } ] } This field also supports Regular Expressions if they begin and end with / . e.g. { \"packageRules\" : [ { \"matchBaseBranches\" : [ \"/^release\\\\/.*/\" ], \"excludePackagePatterns\" : [ \"^eslint\" ], \"enabled\" : false } ] } matchManagers \u00b6 List of package managers to match (e.g. [\"pipenv\"] ). Valid only within a packageRules object. Name Value type array subType string parent packageRules mergeable true Use this field to restrict rules to a particular package manager. e.g. { \"packageRules\" : [ { \"matchPackageNames\" : [ \"node\" ], \"matchManagers\" : [ \"dockerfile\" ], \"enabled\" : false } ] } matchDatasources \u00b6 List of datasources to match (e.g. [\"orb\"] ). Valid only within a packageRules object. Name Value type array subType string parent packageRules mergeable true Use this field to restrict rules to a particular datasource. e.g. { \"packageRules\" : [ { \"matchDatasources\" : [ \"orb\" ], \"labels\" : [ \"circleci-orb!!\" ] } ] } matchCurrentVersion \u00b6 A version or range of versions to match against the current version of a package. Valid only within a packageRules object. Name Value type string parent packageRules mergeable true default null matchCurrentVersion can be an exact SemVer version or a SemVer range: { \"packageRules\" : [ { \"matchCurrentVersion\" : \">=1.0.0\" , \"matchPackageNames\" : [ \"angular\" ] } ] } This field also supports Regular Expressions which must begin and end with / . For example, the following enforces that only 1.* versions will be used: { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"io.github.resilience4j\" ], \"matchCurrentVersion\" : \"/^1\\\\./\" } ] } This field also supports a special negated regex syntax to ignore certain versions. Use the syntax !/ / like this: { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"io.github.resilience4j\" ], \"matchCurrentVersion\" : \"!/^0\\\\./\" } ] } matchFiles \u00b6 List of strings to do an exact match against package files with full path. Will only work inside a packageRules object. Name Value type array subType string parent packageRules Renovate will compare matchFiles for an exact match against the dependency's package file or lock file. For example the following would match package.json but not package/frontend/package.json : \"matchFiles\": [\"package.json\"], Use matchPaths instead if you need more flexible matching. matchPackageNames \u00b6 Package names to match. Valid only within a packageRules object. Name Value type array subType string parent packageRules mergeable true Use this field if you want to have one or more exact name matches in your package rule. See also excludePackageNames . { \"packageRules\" : [ { \"matchPackageNames\" : [ \"angular\" ], \"rangeStrategy\" : \"pin\" } ] } The above will configure rangeStrategy to pin only for the package angular . matchPackagePatterns \u00b6 Package name patterns to match. Valid only within a packageRules object. Name Value type array subType string format regex parent packageRules mergeable true Use this field if you want to have one or more package names patterns in your package rule. See also excludePackagePatterns . { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"^angular\" ], \"rangeStrategy\" : \"replace\" } ] } The above will configure rangeStrategy to replace for any package starting with angular . matchPackagePrefixes \u00b6 Package name prefixes to match. Valid only within a packageRules object. Name Value type array subType string parent packageRules mergeable true Use this field to match a package prefix without needing to write a regex expression. See also excludePackagePrefixes . { \"packageRules\" : [ { \"matchPackagePrefixes\" : [ \"angular\" ], \"rangeStrategy\" : \"replace\" } ] } Just like the earlier matchPackagePatterns example, the above will configure rangeStrategy to replace for any package starting with angular . matchPaths \u00b6 List of strings or glob patterns to match against package files. Will only work inside a packageRules object. Name Value type array subType string parent packageRules Renovate will match matchPaths against both a partial string match or a minimatch glob pattern. If you want to avoid the partial string matching so that only glob matching is performed, wrap your string in +(...) like so: \"matchPaths\": [\"+(package.json)\"], The above will match only the root package.json , whereas the following would match any package.json in any subdirectory too: \"matchPaths\": [\"package.json\"], matchSourceUrlPrefixes \u00b6 A list of source URL prefixes to match against, commonly used to group monorepos or packages from the same organization. Name Value type array subType string parent packageRules mergeable true Here's an example of where you use this to group together all packages from the Vue monorepo: { \"packageRules\" : [ { \"matchSourceUrlPrefixes\" : [ \"https://github.com/vuejs/vue\" ], \"groupName\" : \"Vue monorepo packages\" } ] } Here's an example of where you use this to group together all packages from the renovatebot GitHub org: { \"packageRules\" : [ { \"matchSourceUrlPrefixes\" : [ \"https://github.com/renovatebot/\" ], \"groupName\" : \"All renovate packages\" } ] } matchSourceUrls \u00b6 A list of source URLs to exact match against. Name Value type array subType string parent packageRules mergeable true Here's an example of where you use this to match exact package urls: { \"packageRules\" : [ { \"matchSourceUrls\" : [ \"https://github.com/facebook/react\" ], \"groupName\" : \"React\" } ] } matchUpdateTypes \u00b6 Update types to match against ( major , minor , pin , pinDigest , etc). Valid only within packageRules object. Name Value type array subType string allowedValues major,minor,patch,pin,pinDigest,digest,lockFileMaintenance,rollback,bump parent packageRules mergeable true Use this field to match rules against types of updates. For example to apply a special label for Major updates: { \"packageRules\" : [ { \"matchUpdateTypes\" : [ \"major\" ], \"labels\" : [ \"UPDATE-MAJOR\" ] } ] } replacementName \u00b6 The name of the new dependency that replaces the old deprecated dependency. Name Value type string parent packageRules mergeable true default null This config option only works with the npm manager. We're working to support more managers, subscribe to issue renovatebot/renovate#14149 to follow our progress. Use this field to define the name of a replacement package. Must be used with replacementVersion (see example below). You can suggest a new community package rule by editing the replacements.ts file on the Renovate repository and opening a pull request. replacementVersion \u00b6 The version of the new dependency that replaces the old deprecated dependency. Name Value type string parent packageRules mergeable true default null This config option only works with the npm manager. We're working to support more managers, subscribe to issue renovatebot/renovate#14149 to follow our progress. Use this field to define the version of a replacement package. Must be used with replacementName . For example to replace the npm package jade with version 2.0.0 of the package pug : { \"packageRules\" : [ { \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"jade\" ], \"replacementName\" : \"pug\" , \"replacementVersion\" : \"2.0.0\" } ] } patch \u00b6 Configuration to apply when an update type is patch . Name Value type object mergeable true env RENOVATE_PATCH Add to this object if you wish to define rules that apply only to patch updates. php \u00b6 Configuration object for PHP. Name Value type object mergeable true env RENOVATE_PHP pin \u00b6 Configuration to apply when an update type is pin . Name Value type object default {\"rebaseWhen\":\"behind-base-branch\",\"groupName\":\"Pin Dependencies\",\"groupSlug\":\"pin-dependencies\",\"commitMessageAction\":\"Pin\",\"group\":{\"commitMessageTopic\":\"dependencies\",\"commitMessageExtra\":\"\"}} mergeable true env RENOVATE_PIN Add to this object if you wish to define rules that apply only to PRs that pin dependencies. pinDigest \u00b6 Configuration to apply when pinning a digest (no change in tag/version). Name Value type object default {\"groupName\":\"Pin Dependencies\",\"groupSlug\":\"pin-dependencies\",\"commitMessageAction\":\"Pin\",\"group\":{\"commitMessageTopic\":\"dependencies\",\"commitMessageExtra\":\"\"}} mergeable true env RENOVATE_PIN_DIGEST Add to this object if you wish to define rules that apply only to PRs that pin digests. pinDigests \u00b6 Whether to add digests to Dockerfile source images. Name Value type boolean default false cli --pin-digests env RENOVATE_PIN_DIGESTS If enabled Renovate will pin Docker images by means of their SHA256 digest and not only by tag so that they are immutable. platformAutomerge \u00b6 Controls if platform-native auto-merge is used. Name Value type boolean default false cli --platform-automerge env RENOVATE_PLATFORM_AUTOMERGE If you have enabled automerge and set automergeType=pr in the Renovate config, then you can also set platformAutomerge to true to speed up merging via the platform's native automerge functionality. Renovate tries platform-native automerge only when it initially creates the PR. Any PR that is being updated will be automerged with the Renovate-based automerge. platformAutomerge will configure PRs to be merged after all (if any) branch policies have been met. This option is available for Azure, GitHub and GitLab. It falls back to Renovate-based automerge if the platform-native automerge is not available. You can also fine-tune the behavior by setting packageRules if you want to use it selectively (e.g. per-package). Note that the outcome of rebaseWhen=auto can differ when platformAutomerge=true . Normally when you set rebaseWhen=auto Renovate rebases any branch that's behind the base branch automatically, and some people rely on that. This behavior is no longer guaranteed when you enable platformAutomerge because the platform might automerge a branch which is not up-to-date. For example, GitHub might automerge a Renovate branch even if it's behind the base branch at the time. platformCommit \u00b6 Use platform API to perform commits instead of using Git directly. Name Value type boolean default false supportedPlatforms github cli --platform-commit env RENOVATE_PLATFORM_COMMIT Only use this option if you run Renovate as a GitHub App . It does not apply when you use a Personal Access Token as credential. When platformCommit is enabled, Renovate will create commits with GitHub's API instead of using git directly. This way Renovate can use GitHub's Commit signing support for bots and other GitHub Apps feature. postUpdateOptions \u00b6 Enable post-update options to be run after package/artifact updating. Name Value type array allowedValues gomodMassage,gomodUpdateImportPaths,gomodTidy,gomodTidy1.17,npmDedupe,yarnDedupeFewer,yarnDedupeHighest mergeable true gomodMassage : Enable massaging replace directives before calling go commands gomodTidy : Run go mod tidy after Go module updates. This is implicitly enabled for major module updates when gomodUpdateImportPaths is enabled gomodTidy1.17 : Run go mod tidy -compat=1.17 after Go module updates. gomodUpdateImportPaths : Update source import paths on major module updates, using mod npmDedupe : Run npm dedupe after package-lock.json updates yarnDedupeFewer : Run yarn-deduplicate --strategy fewer after yarn.lock updates yarnDedupeHighest : Run yarn-deduplicate --strategy highest ( yarn dedupe --strategy highest for Yarn >=2.2.0) after yarn.lock updates postUpgradeTasks \u00b6 Post-upgrade tasks that are executed before a commit is made by Renovate. Name Value type object default {\"commands\":[],\"fileFilters\":[],\"executionMode\":\"update\"} cli --post-upgrade-tasks env RENOVATE_POST_UPGRADE_TASKS Note Post-upgrade tasks can only be used on self-hosted Renovate instances. Post-upgrade tasks are commands that are executed by Renovate after a dependency has been updated but before the commit is created. The intention is to run any additional command line tools that would modify existing files or generate new files when a dependency changes. Each command must match at least one of the patterns defined in allowedPostUpgradeCommands (a global-only configuration option) in order to be executed. If the list of allowed tasks is empty then no tasks will be executed. e.g. { \"postUpgradeTasks\" : { \"commands\" : [ \"tslint --fix\" ], \"fileFilters\" : [ \"yarn.lock\" , \"**/*.js\" ], \"executionMode\" : \"update\" } } The postUpgradeTasks configuration consists of three fields: commands \u00b6 A list of post-upgrade commands that are executed before a commit is made by Renovate. Name Value type array subType string parent postUpgradeTasks env RENOVATE_COMMANDS A list of commands that are executed after Renovate has updated a dependency but before the commit is made. fileFilters \u00b6 Files that match the glob pattern will be committed after running a post-upgrade task. Name Value type array subType string parent postUpgradeTasks env RENOVATE_FILE_FILTERS A list of glob-style matchers that determine which files will be included in the final commit made by Renovate. executionMode \u00b6 Controls when the post upgrade tasks run: on every update, or once per upgrade branch. Name Value type string parent postUpgradeTasks allowedValues update,branch default \"update\" env RENOVATE_EXECUTION_MODE Defaults to update , but can also be set to branch . This sets the level the postUpgradeTask runs on, if set to update the postUpgradeTask will be executed for every dependency on the branch. If set to branch the postUpgradeTask is executed for the whole branch. prBodyColumns \u00b6 List of columns to use in PR bodies. Name Value type array subType string default [\"Package\",\"Type\",\"Update\",\"Change\",\"Pending\"] cli --pr-body-columns env RENOVATE_PR_BODY_COLUMNS Use this array to provide a list of column names you wish to include in the PR tables. For example, if you wish to add the package file name to the table, you would add this to your config: { \"prBodyColumns\" : [ \"Package\" , \"Update\" , \"Type\" , \"New value\" , \"Package file\" , \"References\" ] } Note \"Package file\" is predefined in the default prBodyDefinitions object so does not require a definition before it can be used. prBodyDefinitions \u00b6 Table column definitions for use in PR tables. Name Value type object freeChoice true mergeable true default {\"Package\":\"{{{depNameLinked}}}\",\"Type\":\"{{{depType}}}\",\"Update\":\"{{{updateType}}}\",\"Current value\":\"{{{currentValue}}}\",\"New value\":\"{{{newValue}}}\",\"Change\":\" }} -> }} \",\"Pending\":\"{{{displayPending}}}\",\"References\":\"{{{references}}}\",\"Package file\":\"{{{packageFile}}}\"} cli --pr-body-definitions env RENOVATE_PR_BODY_DEFINITIONS You can configure this object to either (a) modify the template for an existing table column in PR bodies, or (b) you wish to add a definition for a new/additional column. Here is an example of modifying the default value for the \"Package\" column to put it inside a <code></code> block: { \"prBodyDefinitions\" : { \"Package\" : \"`{{{depName}}}`\" } } Here is an example of adding a custom \"Sourcegraph\" column definition: { \"prBodyDefinitions\" : { \"Sourcegraph\" : \"[![code search for \\\"{{{depName}}}\\\"](https://sourcegraph.com/search/badge?q=repo:%5Egithub%5C.com/{{{repository}}}%24+case:yes+-file:package%28-lock%29%3F%5C.json+{{{depName}}}&label=matches)](https://sourcegraph.com/search?q=repo:%5Egithub%5C.com/{{{repository}}}%24+case:yes+-file:package%28-lock%29%3F%5C.json+{{{depName}}})\" }, \"prBodyColumns\" : [ \"Package\" , \"Update\" , \"New value\" , \"References\" , \"Sourcegraph\" ] } Tip Columns must also be included in the prBodyColumns array in order to be used, so that's why it's included above in the example. prBodyNotes \u00b6 List of additional notes/templates to be included in the Pull Request bodies. Name Value type array subType string mergeable true cli --pr-body-notes env RENOVATE_PR_BODY_NOTES Use this field to add custom content inside PR bodies, including conditionally. e.g. if you wish to add an extra Warning to major updates: { \"prBodyNotes\" : [ \"{{#if isMajor}}:warning: MAJOR MAJOR MAJOR :warning:{{/if}}\" ] } prBodyTemplate \u00b6 Pull Request body template. Controls which sections are rendered in the body. Name Value type string default \"{{{header}}}{{{table}}}{{{notes}}}{{{changelogs}}}{{{configDescription}}}{{{controls}}}{{{footer}}}\" env RENOVATE_PR_BODY_TEMPLATE This setting controls which sections are rendered in the body of the pull request. The available sections are header, table, notes, changelogs, configDescription, controls, footer. prConcurrentLimit \u00b6 Limit to a maximum of x concurrent branches/PRs. 0 (default) means no limit. Name Value type integer default 0 cli --pr-concurrent-limit env RENOVATE_PR_CONCURRENT_LIMIT This setting - if enabled - limits Renovate to a maximum of x concurrent PRs open at any time. This limit is enforced on a per-repository basis. prCreation \u00b6 When to create the PR for a branch. Name Value type string allowedValues immediate,not-pending,status-success,approval default \"immediate\" cli --pr-creation env RENOVATE_PR_CREATION This setting tells Renovate when you would like it to raise PRs: immediate (default): Renovate will create PRs immediately after creating the corresponding branch not-pending : Renovate will wait until status checks have completed (passed or failed) before raising the PR status-success : Renovate won't raise PRs unless tests pass Renovate defaults to immediate but you might want to change this to not-pending instead. With prCreation set to immediate , you'll get a Pull Request and possible associated notification right away when a new update is available. Your test suite takes a bit of time to complete, so if you go look at the new PR right away, you don't know if your tests pass or fail. You're basically waiting until you have the test results, before you can decide if you want to merge the PR or not. With prCreation set to not-pending , Renovate waits until all tests have finished running, and only then creates the PR. When you get the PR notification, you can take action immediately, as you have the full test results. When you set prCreation to not-pending you're reducing the \"noise\" but get notified of new PRs a bit later. prFooter \u00b6 Text added here will be placed last in the PR body, with a divider separator before it. Name Value type string default \"This PR has been generated by [Renovate Bot](https://github.com/renovatebot/renovate).\" cli --pr-footer env RENOVATE_PR_FOOTER prHeader \u00b6 Text added here will be placed first in the PR body. Name Value type string cli --pr-header env RENOVATE_PR_HEADER default null prHourlyLimit \u00b6 Rate limit PRs to maximum x created per hour. 0 (default) means no limit. Name Value type integer default 0 cli --pr-hourly-limit env RENOVATE_PR_HOURLY_LIMIT This setting - if enabled - helps slow down Renovate, particularly during the onboarding phase. What may happen without this setting is: Onboarding PR is created User merges onboarding PR to activate Renovate Renovate creates a \"Pin Dependencies\" PR (if necessary) User merges Pin PR Renovate then creates every single upgrade PR necessary - potentially dozens The above can result in swamping CI systems, as well as a lot of retesting if branches need to be rebased every time one is merged. Instead, if prHourlyLimit is configure to a value like 1 or 2, it will mean that Renovate creates at most that many new PRs within each hourly period (:00-:59). So the project should still result in all PRs created perhaps within the first 24 hours maximum, but at a rate that may allow users to merge them once they pass tests. It does not place a limit on the number of concurrently open PRs - only on the rate they are created. This limit is enforced on a per-repository basis. prNotPendingHours \u00b6 Timeout in hours for when prCreation=not-pending . Name Value type integer default 25 cli --pr-not-pending-hours env RENOVATE_PR_NOT_PENDING_HOURS If you configure prCreation=not-pending , then Renovate will wait until tests are non-pending (all pass or at least one fails) before creating PRs. However there are cases where PRs may remain in pending state forever, e.g. absence of tests or status checks that are configure to pending indefinitely. This is why we configured an upper limit for how long we wait until creating a PR. Note If the option stabilityDays is non-zero then Renovate disables the prNotPendingHours functionality. prPriority \u00b6 Set sorting priority for PR creation. PRs with higher priority are created first, negative priority last. Name Value type integer default 0 Sometimes Renovate needs to rate limit its creation of PRs, e.g. hourly or concurrent PR limits. In such cases it sorts/prioritizes by default based on the update type (e.g. patches raised before minor, minor before major). If you have dependencies that are more or less important than others then you can use the prPriority field for PR sorting. The default value is 0, so setting a negative value will make dependencies sort last, while higher values sort first. Here's an example of how you would define PR priority so that devDependencies are raised last and react is raised first: { \"packageRules\" : [ { \"matchDepTypes\" : [ \"devDependencies\" ], \"prPriority\" : -1 }, { \"matchPackageNames\" : [ \"react\" ], \"prPriority\" : 5 } ] } prTitle \u00b6 Pull Request title template (deprecated). Inherits from commitMessage if null. Name Value type string env RENOVATE_PR_TITLE The PR title is important for some of Renovate's matching algorithms (e.g. determining whether to recreate a PR or not) so ideally don't modify it much. pruneBranchAfterAutomerge \u00b6 Set to true to enable branch pruning after automerging. Name Value type boolean default true cli --prune-branch-after-automerge env RENOVATE_PRUNE_BRANCH_AFTER_AUTOMERGE By default Renovate deletes, or \"prunes\", the branch after automerging. Set pruneBranchAfterAutomerge to false to keep the branch after automerging. pruneStaleBranches \u00b6 Set to false to disable pruning stale branches. Name Value type boolean default true cli --prune-stale-branches env RENOVATE_PRUNE_STALE_BRANCHES Configure to false to disable deleting orphan branches and autoclosing PRs. Defaults to true . python \u00b6 Configuration object for Python. Name Value type object mergeable true env RENOVATE_PYTHON Currently the only Python package manager is pip - specifically for requirements.txt and requirements.pip files - so adding any config to this python object is essentially the same as adding it to the pip_requirements object instead. rangeStrategy \u00b6 Determines how to modify or update existing ranges. Name Value type string default \"replace\" allowedValues auto,pin,bump,replace,widen,update-lockfile,in-range-only Behavior: auto = Renovate decides (this will be done on a manager-by-manager basis) pin = convert ranges to exact versions, e.g. ^1.0.0 -> 1.1.0 bump = e.g. bump the range even if the new version satisfies the existing range, e.g. ^1.0.0 -> ^1.1.0 replace = Replace the range with a newer one if the new version falls outside it, and update nothing otherwise widen = Widen the range with newer one, e.g. ^1.0.0 -> ^1.0.0 || ^2.0.0 update-lockfile = Update the lock file when in-range updates are available, otherwise replace for updates out of range. Works for bundler , composer , npm , yarn , terraform and poetry so far in-range-only = Update the lock file when in-range updates are available, ignore package file updates Renovate's \"auto\" strategy works like this for npm: Always pin devDependencies Pin dependencies if we detect that it's an app and not a library Widen peerDependencies If an existing range already ends with an \"or\" operator - e.g. \"^1.0.0 || ^2.0.0\" - then Renovate will widen it, e.g. making it into \"^1.0.0 || ^2.0.0 || ^3.0.0\" Otherwise, replace the range. e.g. \"^2.0.0\" would be replaced by \"^3.0.0\" By default, Renovate assumes that if you are using ranges then it's because you want them to be wide/open. Renovate won't deliberately \"narrow\" any range by increasing the semver value inside. For example, if your package.json specifies a value for left-pad of ^1.0.0 and the latest version on npmjs is 1.2.0 , then Renovate won't change anything because 1.2.0 satisfies the range. If instead you'd prefer to be updated to ^1.2.0 in cases like this, then configure rangeStrategy to bump in your Renovate config. This feature supports simple caret ( ^ ) and tilde ( ~ ) ranges only, like ^1.0.0 and ~1.0.0 . The in-range-only strategy may be useful if you want to leave the package file unchanged and only do update-lockfile within the existing range. The in-range-only strategy behaves like update-lockfile , but discards any updates where the new version of the dependency is not equal to the current version. We recommend you avoid using the in-range-only strategy unless you strictly need it. Using the in-range-only strategy may result in you being multiple releases behind without knowing it. rebaseLabel \u00b6 Label to request a rebase from Renovate bot. Name Value type string default \"rebase\" cli --rebase-label env RENOVATE_REBASE_LABEL On supported platforms it is possible to add a label to a PR to manually request Renovate to recreate/rebase it. By default this label is \"rebase\" but you can configure it to anything you want by changing this rebaseLabel field. rebaseWhen \u00b6 Controls when Renovate rebases an existing branch. Name Value type string allowedValues auto,never,conflicted,behind-base-branch default \"auto\" cli --rebase-when env RENOVATE_REBASE_WHEN Possible values and meanings: auto : Renovate will autodetect the best setting. It will use behind-base-branch if configured to automerge or repository has been set to require PRs to be up to date. Otherwise, conflicted will be used instead never : Renovate will never rebase the branch or update it unless manually requested conflicted : Renovate will rebase only if the branch is conflicted behind-base-branch : Renovate will rebase whenever the branch falls 1 or more commit behind its base branch rebaseWhen=conflicted is not recommended if you have enabled Renovate automerge, because: It could result in a broken base branch if two updates are merged one after another without testing the new versions together If you have enforced that PRs must be up-to-date before merging (e.g. using branch protection on GitHub), then automerge won't be possible as soon as a PR gets out-of-date but remains non-conflicted It is also recommended to avoid rebaseWhen=never as it can result in conflicted branches with outdated PR descriptions and/or status checks. Avoid setting rebaseWhen=never and then also setting prCreation=not-pending as this can prevent creation of PRs. recreateClosed \u00b6 Recreate PRs even if same ones were closed previously. Name Value type boolean default false cli --recreate-closed env RENOVATE_RECREATE_CLOSED By default, Renovate will detect if it has proposed an update to a project before and not propose the same one again. For example the Webpack 3.x case described above. This field lets you customise this behavior down to a per-package level. For example we override it to true in the following cases where branch names and PR titles need to be reused: Package groups When pinning versions Lock file maintenance Typically you shouldn't need to modify this setting. regexManagers \u00b6 Custom managers using regex matching. Name Value type array subType object cli --regex-managers mergeable true env RENOVATE_REGEX_MANAGERS Use regexManagers entries to configure the regex manager in Renovate. You can define custom managers for cases such as: Proprietary file formats or conventions Popular file formats not yet supported as a manager by Renovate The custom manager concept is based on using Regular Expression named capture groups. You must have a named capture group matching (e.g. (?<depName>.*) ) or configure it's corresponding template (e.g. depNameTemplate ) for these fields: datasource depName currentValue Use named capture group matching or set a corresponding template. We recommend you use only one of these methods, or you'll get confused. We recommend that you also tell Renovate what versioning to use. If the versioning field is missing, then Renovate defaults to using semver versioning. For more details and examples, see our documentation for the regex manager . For template fields, use the triple brace {{{ }}} notation to avoid Handlebars escaping any special characters. matchStrings \u00b6 Regex capture rule to use. Valid only within a regexManagers object. Name Value type array subType string format regex parent regexManagers matchStrings should each be a valid regular expression, optionally with named capture groups. Example: { \"matchStrings\" : [ \"ENV .*?_VERSION=(?<currentValue>.*) # (?<datasource>.*?)/(?<depName>.*?)\\\\s\" ] } matchStringsStrategy \u00b6 Strategy how to interpret matchStrings. Name Value type string default \"any\" allowedValues any,recursive,combination parent regexManagers matchStringsStrategy controls behavior when multiple matchStrings values are provided. Three options are available: any (default) recursive combination any \u00b6 Each provided matchString will be matched individually to the content of the packageFile . If a matchString has multiple matches in a file each will be interpreted as an independent dependency. As example the following configuration will update all 3 lines in the Dockerfile. renovate.json: { \"regexManagers\" : [ { \"fileMatch\" : [ \"^Dockerfile$\" ], \"matchStringsStrategy\" : \"any\" , \"matchStrings\" : [ \"ENV [A-Z]+_VERSION=(?<currentValue>.*) # (?<datasource>.*?)/(?<depName>.*?)(\\\\&versioning=(?<versioning>.*?))?\\\\s\" , \"FROM (?<depName>\\\\S*):(?<currentValue>\\\\S*)\" ], \"datasourceTemplate\" : \"docker\" } ] } a Dockerfile: FROM amd64/ubuntu:18.04 ENV GRADLE_VERSION = 6 .2 # gradle-version/gradle & versioning = maven ENV NODE_VERSION = 10 .19.0 # github-tags/nodejs/node & versioning = node recursive \u00b6 If using recursive the matchStrings will be looped through and the full match of the last will define the range of the next one. This can be used to narrow down the search area to prevent multiple matches. But the recursive strategy still allows the matching of multiple dependencies as described below. All matches of the first matchStrings pattern are detected, then each of these matches will used as basis be used as the input for the next matchStrings pattern, and so on. If the next matchStrings pattern has multiple matches then it will split again. This process will be followed as long there is a match plus a next matchingStrings pattern is available or a dependency is detected. Matched groups will be available in subsequent matching layers. This is an example how this can work. The first regex manager will only upgrade grafana/loki as looks for the backup key then looks for the test key and then uses this result for extraction of necessary attributes. But the second regex manager will upgrade both definitions as its first matchStrings matches both test keys. renovate.json: { \"regexManagers\" : [ { \"fileMatch\" : [ \"^example.json$\" ], \"matchStringsStrategy\" : \"recursive\" , \"matchStrings\" : [ \"\\\"backup\\\":\\\\s*{[^}]*}\" , \"\\\"test\\\":\\\\s*\\\\{[^}]*}\" , \"\\\"name\\\":\\\\s*\\\"(?<depName>.*)\\\"[^\\\"]*\\\"type\\\":\\\\s*\\\"(?<datasource>.*)\\\"[^\\\"]*\\\"value\\\":\\\\s*\\\"(?<currentValue>.*)\\\"\" ], \"datasourceTemplate\" : \"docker\" }, { \"fileMatch\" : [ \"^example.json$\" ], \"matchStringsStrategy\" : \"recursive\" , \"matchStrings\" : [ \"\\\"test\\\":\\\\s*\\\\{[^}]*}\" , \"\\\"name\\\":\\\\s*\\\"(?<depName>.*)\\\"[^\\\"]*\\\"type\\\":\\\\s*\\\"(?<datasource>.*)\\\"[^\\\"]*\\\"value\\\":\\\\s*\\\"(?<currentValue>.*)\\\"\" ], \"datasourceTemplate\" : \"docker\" } ] } example.json: { \"backup\" : { \"test\" : { \"name\" : \"grafana/loki\" , \"type\" : \"docker\" , \"value\" : \"1.6.1\" } }, \"setup\" : { \"test\" : { \"name\" : \"python\" , \"type\" : \"docker\" , \"value\" : \"3.9.0\" } } } combination \u00b6 This option allows the possibility to combine the values of multiple lines inside a file. While using multiple lines is also possible using both other matchStringStrategy values, the combination approach is less susceptible to white space or line breaks stopping a match. combination will only match at most one dependency per file, so if you want to update multiple dependencies using combination you have to define multiple regex managers. Matched group values will be merged to form a single dependency. renovate.json: { \"regexManagers\" : [ { \"fileMatch\" : [ \"^main.yml$\" ], \"matchStringsStrategy\" : \"combination\" , \"matchStrings\" : [ \"prometheus_image:\\\\s*\\\"(?<depName>.*)\\\"\\\\s*//\" , \"prometheus_version:\\\\s*\\\"(?<currentValue>.*)\\\"\\\\s*//\" ], \"datasourceTemplate\" : \"docker\" }, { \"fileMatch\" : [ \"^main.yml$\" ], \"matchStringsStrategy\" : \"combination\" , \"matchStrings\" : [ \"thanos_image:\\\\s*\\\"(?<depName>.*)\\\"\\\\s*//\" , \"thanos_version:\\\\s*\\\"(?<currentValue>.*)\\\"\\\\s*//\" ], \"datasourceTemplate\" : \"docker\" } ] } Ansible variable file ( yaml ): prometheus_image : \"prom/prometheus\" // a comment prometheus_version : \"v2.21.0\" // a comment ------ thanos_image : \"prom/prometheus\" // a comment thanos_version : \"0.15.0\" // a comment In the above example, each regex manager will match a single dependency each. depNameTemplate \u00b6 Optional depName for extracted dependencies. Valid only within a regexManagers object. Name Value type string parent regexManagers default null If depName cannot be captured with a named capture group in matchString then it can be defined manually using this field. It will be compiled using Handlebars and the regex groups result. extractVersionTemplate \u00b6 Optional extractVersion for extracted dependencies. Valid only within a regexManagers object. Name Value type string parent regexManagers default null If extractVersion cannot be captured with a named capture group in matchString then it can be defined manually using this field. It will be compiled using Handlebars and the regex groups result. packageNameTemplate \u00b6 Optional packageName for extracted dependencies, else defaults to depName value. Valid only within a regexManagers object. Name Value type string parent regexManagers default null packageName is used for looking up dependency versions. It will be compiled using Handlebars and the regex groups result. It will default to the value of depName if left unconfigured/undefined. currentValueTemplate \u00b6 Optional currentValue for extracted dependencies. Valid only within a regexManagers object. Name Value type string parent regexManagers default null If the currentValue for a dependency is not captured with a named group then it can be defined in config using this field. It will be compiled using Handlebars and the regex groups result. datasourceTemplate \u00b6 Optional datasource for extracted dependencies. Valid only within a regexManagers object. Name Value type string parent regexManagers default null If the datasource for a dependency is not captured with a named group then it can be defined in config using this field. It will be compiled using Handlebars and the regex groups result. depTypeTemplate \u00b6 Optional depType for extracted dependencies. Valid only within a regexManagers object. Name Value type string parent regexManagers default null If depType cannot be captured with a named capture group in matchString then it can be defined manually using this field. It will be compiled using Handlebars and the regex groups result. versioningTemplate \u00b6 Optional versioning for extracted dependencies. Valid only within a regexManagers object. Name Value type string parent regexManagers default null If the versioning for a dependency is not captured with a named group then it can be defined in config using this field. It will be compiled using Handlebars and the regex groups result. registryUrlTemplate \u00b6 Optional registry URL for extracted dependencies. Valid only within a regexManagers object. Name Value type string parent regexManagers default null If the registryUrls for a dependency is not captured with a named group then it can be defined in config using this field. It will be compiled using Handlebars and the regex groups result. autoReplaceStringTemplate \u00b6 Optional extractVersion for extracted dependencies. Valid only within a regexManagers object. Name Value type string parent regexManagers default null Allows overwriting how the matched string is replaced. This allows for some migration strategies. E.g. moving from one Docker image repository to another one. helm-values.yaml: # The image of the service <registry>/<repo>/<image>:<tag> image : my.old.registry/aRepository/andImage:1.18-alpine regex definition: { \"regexManagers\" : [ { \"fileMatch\" : [ \"values.yaml$\" ], \"matchStrings\" : [ \"image:\\\\s+(?<depName>my\\\\.old\\\\.registry\\\\/aRepository\\\\/andImage):(?<currentValue>[^\\\\s]+)\" ], \"depNameTemplate\" : \"my.new.registry/aRepository/andImage\" , \"autoReplaceStringTemplate\" : \"image: {{{depName}}}:{{{newValue}}}\" , \"datasourceTemplate\" : \"docker\" } ] } This will lead to following update where 1.21-alpine is the newest version of my.new.registry/aRepository/andImage : # The image of the service <registry>/<repo>/<image>:<tag> image : my.new.registry/aRepository/andImage:1.21-alpine registryUrls \u00b6 List of URLs to try for dependency lookup. Package manager specific. Name Value type array subType string Usually Renovate is able to either (a) use the default registries for a datasource, or (b) automatically detect during the manager extract phase which custom registries are in use. In case there is a need to configure them manually, it can be done using this registryUrls field, typically using packageRules like so: { \"packageRules\" : [ { \"matchDatasources\" : [ \"docker\" ], \"registryUrls\" : [ \"https://docker.mycompany.domain\" ] } ] } The field supports multiple URLs but it is datasource-dependent on whether only the first is used or multiple. replacement \u00b6 Configuration to apply when replacing a dependency. Name Value type object default {\"branchTopic\":\"{{{depNameSanitized}}}-replacement\",\"commitMessageAction\":\"Replace\",\"commitMessageExtra\":\"with {{newName}} {{#if isMajor}}v{{{newMajor}}}{{else}}{{#if isSingleVersion}}v{{{newVersion}}}{{else}}{{{newValue}}}{{/if}}{{/if}}\",\"prBodyNotes\":[\"This is a special PR that replaces }} with the community suggested minimal stable replacement version.\"]} mergeable true env RENOVATE_REPLACEMENT Add to this object if you wish to define rules that apply only to PRs that replace dependencies. respectLatest \u00b6 Ignore versions newer than npm \"latest\" version. Name Value type boolean cli --respect-latest env RENOVATE_RESPECT_LATEST default true Similar to ignoreUnstable , this option controls whether to update to versions that are greater than the version tagged as latest in the repository. By default, renovate will update to a version greater than latest only if the current version is itself past latest. reviewers \u00b6 Requested reviewers for Pull Requests (either username or email address depending on the platform). Name Value type array subType string cli --reviewers env RENOVATE_REVIEWERS Must be valid usernames. If on GitHub and assigning a team to review, you must use the prefix team: and add the last part of the team name. Say the full team name on GitHub is @organization/foo , then you'd set the config option like this: { \"reviewers\" : [ \"team:foo\" ] } reviewersFromCodeOwners \u00b6 Determine reviewers based on configured code owners and changes in PR. Name Value type boolean default false cli --reviewers-from-code-owners env RENOVATE_REVIEWERS_FROM_CODE_OWNERS If enabled Renovate tries to determine PR reviewers by matching rules defined in a CODEOWNERS file against the changes in the PR. See GitHub or GitLab documentation for details on syntax and possible file locations. reviewersSampleSize \u00b6 Take a random sample of given size from reviewers. Name Value type integer cli --reviewers-sample-size env RENOVATE_REVIEWERS_SAMPLE_SIZE rollback \u00b6 Configuration to apply when rolling back a version. Name Value type object default {\"branchTopic\":\"{{{depNameSanitized}}}-rollback\",\"commitMessageAction\":\"Roll back\",\"semanticCommitType\":\"fix\"} mergeable true env RENOVATE_ROLLBACK Add to this object if you wish to define rules that apply only to PRs that roll back versions. rollbackPrs \u00b6 Create PRs to roll back versions if the current version is not found in the registry. Name Value type boolean default false cli --rollback-prs env RENOVATE_ROLLBACK_PRS There are times when a dependency version in use by a project gets removed from the registry. For some registries, existing releases or even whole packages can be removed or \"yanked\" at any time, while for some registries only very new or unused releases can be removed. Renovate's \"rollback\" feature exists to propose a downgrade to the next-highest release if the current release is no longer found in the registry. Renovate does not create these rollback PRs by default, with one exception: npm packages get a rollback PR if needed. You can configure the rollbackPrs property globally, per-language, or per-package to override the default behavior. ruby \u00b6 Configuration object for Ruby language. Name Value type object mergeable true env RENOVATE_RUBY rust \u00b6 Configuration option for Rust package management. Name Value type object mergeable true env RENOVATE_RUST schedule \u00b6 Limit branch creation to these times of day or week. Name Value type array subType string cli --schedule default [\"at any time\"] The schedule option allows you to define times of week or month for Renovate updates. Running Renovate around the clock can be too \"noisy\" for some projects. To reduce the noise you can use the schedule config option to limit the time frame in which Renovate will perform actions on your repository. You can use the standard Cron syntax and Later syntax to define your schedule. The default value for schedule is \"at any time\", which is functionally the same as declaring a null schedule. i.e. Renovate will run on the repository around the clock. The easiest way to define a schedule is to use a preset if one of them fits your requirements. See Schedule presets for details and feel free to request a new one in the source repository if you think others would benefit from it too. Otherwise, here are some text schedules that are known to work: every weekend before 5:00am after 10pm and before 5:00am after 10pm and before 5am every weekday on friday and saturday every 3 months on the first day of the month * 0 2 * * Warning For Cron schedules, you must use the * wildcard for the minutes value, as Renovate doesn't support minute granularity. One example might be that you don't want Renovate to run during your typical business hours, so that your build machines don't get clogged up testing package.json updates. You could then configure a schedule like this at the repository level: { \"schedule\" : [ \"after 10pm and before 5am every weekday\" , \"every weekend\" ] } This would mean that Renovate can run for 7 hours each night plus all the time on weekends. This scheduling feature can also be particularly useful for \"noisy\" packages that are updated frequently, such as aws-sdk . To restrict aws-sdk to only monthly updates, you could add this package rule: { \"packageRules\" : [ { \"matchPackageNames\" : [ \"aws-sdk\" ], \"extends\" : [ \"schedule:monthly\" ] } ] } Technical details: We mostly rely on the text parsing of the library @breejs/later but only its concepts of \"days\", \"time_before\", and \"time_after\". Read the parser documentation at breejs.github.io/later/parsers.html#text . To parse Cron syntax, Renovate uses @cheap-glitch/mi-cron . Renovate does not support scheduled minutes or \"at an exact time\" granularity. Note Actions triggered via the Dependency Dashboard are not restricted by a configured schedule. semanticCommitScope \u00b6 Commit scope to use if Semantic Commits are enabled. Name Value type string default \"deps\" cli --semantic-commit-scope env RENOVATE_SEMANTIC_COMMIT_SCOPE By default you will see Angular-style commit prefixes like \"chore(deps):\" . If you wish to change it to something else like \"package\" then it will look like \"chore(package):\" . You can also use parentDir or baseDir to namespace your commits for monorepos e.g. \"{{parentDir}}\" . semanticCommitType \u00b6 Commit type to use if Semantic Commits is enabled. Name Value type string default \"chore\" cli --semantic-commit-type env RENOVATE_SEMANTIC_COMMIT_TYPE By default you will see Angular-style commit prefixes like \"chore(deps):\" . If you wish to change it to something else like \"ci\" then it will look like \"ci(deps):\" . semanticCommits \u00b6 Enable Semantic Commit prefixes for commits and PR titles. Name Value type string allowedValues auto,enabled,disabled default \"auto\" cli --semantic-commits env RENOVATE_SEMANTIC_COMMITS If you are using a semantic prefix for your commits, then you will want to enable this setting. Although it's configurable to a package-level, it makes most sense to configure it at a repository level. If configured to enabled , then the semanticCommitScope and semanticCommitType fields will be used for each commit message and PR title. Renovate autodetects if your repository is already using semantic commits or not and follows suit, so you only need to configure this if you wish to override Renovate's autodetected setting. separateMajorMinor \u00b6 If set to false , Renovate will upgrade dependencies to their latest release only. Renovate will not separate major or minor branches. Name Value type boolean cli --separate-major-minor env RENOVATE_SEPARATE_MAJOR_MINOR default true Renovate's default behavior is to create a separate branch/PR if both minor and major version updates exist (note that your choice of rangeStrategy value can influence which updates exist in the first place however). For example, if you were using Webpack 2.0.0 and versions 2.1.0 and 3.0.0 were both available, then Renovate would create two PRs so that you have the choice whether to apply the minor update to 2.x or the major update of 3.x. If you were to apply the minor update then Renovate would keep updating the 3.x branch for you as well, e.g. if Webpack 3.0.1 or 3.1.0 were released. If instead you applied the 3.0.0 update then Renovate would clean up the unneeded 2.x branch for you on the next run. It is recommended that you leave this option to true , because of the polite way that Renovate handles this. For example, let's say in the above example that you decided you wouldn't update to Webpack 3 for a long time and don't want to build/test every time a new 3.x version arrives. In that case, simply close the \"Update Webpack to version 3.x\" PR and it won't be recreated again even if subsequent Webpack 3.x versions are released. You can continue with Webpack 2.x for as long as you want and get any updates/patches that are made for it. Then eventually when you do want to update to Webpack 3.x you can make that update to package.json yourself and commit it to the base branch once it's tested. After that, Renovate will resume providing you updates to 3.x again! i.e. if you close a major upgrade PR then it won't come back again, but once you make the major upgrade yourself then Renovate will resume providing you with minor or patch updates. This option also has priority over package groups configured by packageRule . So Renovate will propose separate PRs for major and minor updates of packages even if they are grouped. If you want to enforce grouped package updates, you need to set this option to false within the packageRule . separateMinorPatch \u00b6 If set to true , Renovate will separate minor and patch updates into separate branches. Name Value type boolean default false cli --separate-minor-patch env RENOVATE_SEPARATE_MINOR_PATCH By default, Renovate won't distinguish between \"patch\" (e.g. 1.0.x) and \"minor\" (e.g. 1.x.0) releases - it groups them together. E.g., if you are running version 1.0.0 of a package and both versions 1.0.1 and 1.1.0 are available then Renovate will raise a single PR for version 1.1.0. If you wish to distinguish between patch and minor upgrades, for example if you wish to automerge patch but not minor, then you can configured this option to true . separateMultipleMajor \u00b6 If set to true , PRs will be raised separately for each available major upgrade version. Name Value type boolean default false cli --separate-multiple-major env RENOVATE_SEPARATE_MULTIPLE_MAJOR Configure this to true if you wish to get one PR for every separate major version upgrade of a dependency. e.g. if you are on webpack@v1 currently then default behavior is a PR for upgrading to webpack@v3 and not for webpack@v2. If this setting is true then you would get one PR for webpack@v2 and one for webpack@v3. stabilityDays \u00b6 Number of days required before a new release is considered stable. Name Value type integer default 0 cli --stability-days env RENOVATE_STABILITY_DAYS If this is set to a non-zero value, and an update has a release timestamp header, then Renovate will check if the \"stability days\" have passed. Note: Renovate will wait for the set number of stabilityDays to pass for each separate version. Renovate does not wait until the package has seen no releases for x stabilityDays . stabilityDays is not intended to help with slowing down fast releasing project updates. If you want to slow down PRs for a specific package, setup a custom schedule for that package. Read our selective-scheduling help to learn how to set the schedule. If the number of days since the release is less than the set stabilityDays a \"pending\" status check is added to the branch. If enough days have passed then the \"pending\" status is removed, and a \"passing\" status check is added. Some datasources do not provide a release timestamp (in which case this feature is not compatible), and other datasources may provide a release timestamp but it's not supported by Renovate (in which case a feature request needs to be implemented). Maven users: you cannot use stabilityDays if a Maven source returns unreliable last-modified headers. There are a couple of uses for stabilityDays : Suppress branch/PR creation for X days \u00b6 If you combine stabilityDays=3 and prCreation=\"not-pending\" then Renovate will hold back from creating branches until 3 or more days have elapsed since the version was released. It's recommended that you enable dependencyDashboard=true so you don't lose visibility of these pending PRs. Prevent holding broken npm packages \u00b6 npm packages less than 72 hours (3 days) old can be unpublished, which could result in a service impact if you have already updated to it. Set stabilityDays to 3 for npm packages to prevent relying on a package that can be removed from the registry: { \"packageRules\" : [ { \"matchDatasources\" : [ \"npm\" ], \"stabilityDays\" : 3 } ] } Await X days before Automerging \u00b6 If you have both automerge as well as stabilityDays enabled, it means that PRs will be created immediately but automerging will be delayed until X days have passed. This works because Renovate will add a \"renovate/stability-days\" pending status check to each branch/PR and that pending check will prevent the branch going green to automerge. stopUpdatingLabel \u00b6 Label to make Renovate stop updating a PR. Name Value type string default \"stop-updating\" supportedPlatforms azure,github,gitlab,gitea cli --stop-updating-label env RENOVATE_STOP_UPDATING_LABEL On supported platforms it is possible to add a label to a PR to request Renovate stop updating the PR. By default this label is \"stop-updating\" but you can configure it to anything you want by changing this stopUpdatingLabel field. suppressNotifications \u00b6 Options to suppress various types of warnings and other notifications. Name Value type array subType string default [\"deprecationWarningIssues\"] allowedValues prIgnoreNotification,branchAutomergeFailure,lockFileErrors,artifactErrors,deprecationWarningIssues,onboardingClose,configErrorIssue mergeable true Use this field to suppress various types of warnings and other notifications from Renovate. Example: { \"suppressNotifications\" : [ \"prIgnoreNotification\" ] } The above config will suppress the comment which is added to a PR whenever you close a PR unmerged. timezone \u00b6 IANA Time Zone Name Value type string cli --timezone env RENOVATE_TIMEZONE default null It is only recommended to configure this field if you wish to use the schedules feature and want to write them in your local timezone. Please see the above link for valid timezone names. transitiveRemediation \u00b6 Enable remediation of transitive dependencies. Name Value type boolean default false supportedManagers npm supportedPlatforms github cli --transitive-remediation env RENOVATE_TRANSITIVE_REMEDIATION When enabled, Renovate tries to remediate vulnerabilities even if they exist only in transitive dependencies. Applicable only for GitHub platform (with vulnerability alerts enabled) and npm manager. When the lockfileVersion is higher than 1 in package-lock.json , remediations are only possible when changes are made to package.json . This is considered a feature flag with the aim to remove it and default to this behavior once it has been more widely tested. updateInternalDeps \u00b6 Whether to update internal dep versions in a monorepo. Works on Lerna or Yarn Workspaces. Name Value type boolean default false cli --update-internal-deps env RENOVATE_UPDATE_INTERNAL_DEPS Renovate defaults to skipping any internal package dependencies within monorepos. In such case dependency versions won't be updated by Renovate. To opt in to letting Renovate update internal package versions normally, set this configuration option to true. updateLockFiles \u00b6 Set to false to disable lock file updating. Name Value type boolean cli --update-lock-files env RENOVATE_UPDATE_LOCK_FILES default true updateNotScheduled \u00b6 Whether to update branches when not scheduled. Renovate will not create branches outside of the schedule. Name Value type boolean cli --update-not-scheduled env RENOVATE_UPDATE_NOT_SCHEDULED default true When schedules are in use, it generally means \"no updates\". However there are cases where updates might be desirable - e.g. if you have configured prCreation=not-pending , or you have rebaseWhen=behind-base-branch and the base branch is updated so you want Renovate PRs to be rebased. This defaults to true , meaning that Renovate will perform certain \"desirable\" updates to existing PRs even when outside of schedule. If you wish to disable all updates outside of scheduled hours then configure this field to false . updatePinnedDependencies \u00b6 Whether to update pinned (single version) dependencies or not. Name Value type boolean default true cli --update-pinned-dependencies env RENOVATE_UPDATE_PINNED_DEPENDENCIES By default, Renovate will try to update all detected dependencies, regardless of whether they are defined using pinned single versions (e.g. 1.2.3 ) or constraints/ranges (e.g. ( ^1.2.3 ). You can set this option to false if you wish to disable updating for pinned (single version) dependencies specifically. useBaseBranchConfig \u00b6 Whether to read configuration from baseBranches instead of only the default branch. Name Value type string allowedValues merge,none default \"none\" cli --use-base-branch-config env RENOVATE_USE_BASE_BRANCH_CONFIG By default, Renovate will read config file from the default branch only and will ignore any config files in base branches. You can configure useBaseBranchConfig=merge to instruct Renovate to merge the config from each base branch over the top of the config in the default branch. The config file name in the base branch must be the same as in the default branch and cannot be package.json . This scenario may be useful for testing the config changes in base branches instantly. userStrings \u00b6 User-facing strings for the Renovate comment when a PR is closed. Name Value type object freeChoice true default {\"ignoreTopic\":\"Renovate Ignore Notification\",\"ignoreMajor\":\"As this PR has been closed unmerged, Renovate will ignore this upgrade and you will not receive PRs for *any* future {{{newMajor}}}.x releases. However, if you upgrade to {{{newMajor}}}.x manually then Renovate will reenable minor and patch updates automatically.\",\"ignoreDigest\":\"As this PR has been closed unmerged, Renovate will ignore this upgrade and you will not receive PRs for the }} }} update again.\",\"ignoreOther\":\"As this PR has been closed unmerged, Renovate will now ignore this update ({{{newValue}}}). You will still receive a PR once a newer version is released, so if you wish to permanently ignore this dependency, please add it to the ignoreDeps array of your renovate config.\"} cli --user-strings env RENOVATE_USER_STRINGS When a PR is closed, Renovate posts a comment to let users know that future updates will be ignored. If you want, you can change the text in the comment with the userStrings config option. You can edit these user-facing strings: ignoreDigest : Text of the PR comment for digest upgrades. ignoreMajor : Text of the PR comment for major upgrades. ignoreOther : Text of the PR comment for other (neither digest nor major) upgrades. ignoreTopic : Topic of the PR comment. Example: { \"userStrings\" : { \"ignoreTopic\" : \"Custom topic for PR comment\" , \"ignoreMajor\" : \"Custom text for major upgrades.\" , \"ignoreDigest\" : \"Custom text for digest upgrades.\" , \"ignoreOther\" : \"Custom text for other upgrades.\" } } versioning \u00b6 Versioning to use for filtering and comparisons. Name Value type string allowedValues aws-machine-image,cargo,composer,conan,debian,docker,git,gradle,hashicorp,helm,hex,ivy,loose,maven,node,npm,nuget,pep440,poetry,regex,rez,ruby,semver,semver-coerced,swift,ubuntu default null Usually, each language or package manager has a specific type of \"versioning\": JavaScript uses npm's SemVer implementation, Python uses pep440, etc. Renovate also uses custom versioning, like \"docker\" to address the most common way people tag versions using Docker, and \"loose\" as a fallback that tries SemVer first but otherwise just does its best to sort and compare. By exposing versioning to config, you can override the default versioning for a package manager if needed. We do not recommend overriding the default versioning, but there are some cases such as Docker or Gradle where versioning is not strictly defined and you may need to specify the versioning type per-package. Renovate supports 4-part versions (1.2.3.4) in full for the NuGet package manager. Other managers can use the \"loose\" versioning fallback: the first 3 parts are used as the version, all trailing parts are used for alphanumeric sorting. vulnerabilityAlerts \u00b6 Config to apply when a PR is needed due to a vulnerability in the existing package version. Name Value type object default {\"groupName\":null,\"schedule\":[],\"dependencyDashboardApproval\":false,\"rangeStrategy\":\"update-lockfile\",\"commitMessageSuffix\":\"[SECURITY]\",\"branchTopic\":\"{{{datasource}}}-{{{depName}}}-vulnerability\",\"prCreation\":\"immediate\"} mergeable true supportedPlatforms github Renovate can read from GitHub's Vulnerability Alerts and customize Pull Requests accordingly. For this to work, you must first ensure you have enabled \" Dependency graph \" and \" Dependabot alerts \" under the \"Security & analysis\" section of the repository's \"Settings\" tab. Additionally, if you are running Renovate in app mode then you must make sure that the app has been granted the permissions to read \"Vulnerability alerts\". If you are the account admin, browse to the app (e.g. https://github.com/apps/renovate ), select \"Configure\", and then scroll down to the \"Permissions\" section and verify that read access to \"vulnerability alerts\" is mentioned. Once the above conditions are met, and you got one or more vulnerability alerts from GitHub for this repository, then Renovate tries to raise fix PRs accordingly. Use the vulnerabilityAlerts configuration object if you want to customise vulnerability-fix PRs specifically. For example, to configure custom labels and assignees: { \"vulnerabilityAlerts\" : { \"labels\" : [ \"security\" ], \"automerge\" : true , \"assignees\" : [ \"@rarkins\" ] } } Warning There's a small chance that an incorrect vulnerability alert could result in flapping/looping vulnerability fixes, so observe carefully if enabling automerge . To disable the vulnerability alerts functionality completely, configure like this: { \"vulnerabilityAlerts\" : { \"enabled\" : false } }","title":"Repository"},{"location":"configuration-options/#configuration-options","text":"This document describes all the configuration options you may configure in a Renovate configuration file. Any config you define applies to the whole repository (e.g. if you have a monorepo). You can store your Renovate configuration file in one of the following locations: renovate.json renovate.json5 .github/renovate.json .github/renovate.json5 .gitlab/renovate.json .gitlab/renovate.json5 .renovaterc .renovaterc.json package.json (within a \"renovate\" section) Warning Storing the Renovate configuration in a package.json file is deprecated and support may be removed in the future. When renovating a repository, Renovate tries to detect the configuration files in the order listed above, and stops after the first one is found. Renovate always uses the config from the repository's default branch, even if that configuration specifies multiple baseBranches . Renovate does not read/override the config from within each base branch if present. Also, be sure to check out Renovate's shareable config presets to save yourself from reinventing any wheels. Shareable config presets only work with the JSON format. If you have any questions about the config options, or want to get help/feedback about a config, go to the discussions tab in the Renovate repository and start a new \"config help\" discussion. We will do our best to answer your question(s). A subtype in the configuration table specifies what type you're allowed to use within the main element. If a config option has a parent defined, it means it's only allowed to configure it within an object with the parent name, such as packageRules or hostRules . When an array or object configuration option is mergeable , it means that values inside it will be added to any existing object or array that existed with the same name. Note Config options with type=string are always non-mergeable, so mergeable=false .","title":"Configuration Options"},{"location":"configuration-options/#addlabels","text":"Labels to add to Pull Request. Name Value type array subType string mergeable true cli --add-labels env RENOVATE_ADD_LABELS The labels field is non-mergeable, meaning that any config setting a list of PR labels will replace any existing list. If you want to append labels for matched rules, then define an addLabels array with one (or more) label strings. All matched addLabels strings will be attached to the PR. Consider this example: { \"labels\" : [ \"dependencies\" ], \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"eslint\" ], \"labels\" : [ \"linting\" ] }, { \"matchDepTypes\" : [ \"optionalDependencies\" ], \"addLabels\" : [ \"optional\" ] } ] } With the above config: Optional dependencies will have the labels dependencies and optional ESLint dependencies will have the label linting All other dependencies will have the label dependencies","title":"addLabels"},{"location":"configuration-options/#additionalbranchprefix","text":"Additional string value to be appended to branchPrefix . Name Value type string default \"\" env RENOVATE_ADDITIONAL_BRANCH_PREFIX This value defaults to an empty string, and is typically not necessary. Some managers previously populated this field, but they no longer do so by default. You normally don't need to configure this, but one example where it can be useful is combining with parentDir in monorepos to split PRs based on where the package definition is located, e.g. { \"additionalBranchPrefix\" : \"{{parentDir}}-\" }","title":"additionalBranchPrefix"},{"location":"configuration-options/#additionalreviewers","text":"Additional reviewers for Pull Requests (in contrast to reviewers , this option adds to the existing reviewer list, rather than replacing it). Name Value type array subType string mergeable true cli --additional-reviewers env RENOVATE_ADDITIONAL_REVIEWERS In contrast to reviewers , this option adds to the existing reviewer list, rather than replacing it. This makes it suitable for augmenting a preset or base list without displacing the original, for example when adding focused reviewers for a specific package group.","title":"additionalReviewers"},{"location":"configuration-options/#aliases","text":"Aliases for registries, package manager specific. Name Value type object additionalProperties [object Object] supportedManagers helm-requirements,helmv3,helmfile cli --aliases env RENOVATE_ALIASES The aliases object is used for configuring registry aliases. Currently it is needed/supported for the helm-requirements , helmv3 and helmfile managers only. The above managers include this default alias: { \"aliases\" : { \"stable\" : \"https://charts.helm.sh/stable\" } } Alias values must be properly formatted URIs.","title":"aliases"},{"location":"configuration-options/#assignautomerge","text":"Assign reviewers and assignees even if the PR is to be automerged. Name Value type boolean default false cli --assign-automerge env RENOVATE_ASSIGN_AUTOMERGE By default, Renovate will not assign reviewers and assignees to an automerge-enabled PR unless it fails status checks. By configuring this setting to true , Renovate will instead always assign reviewers and assignees for automerging PRs at time of creation.","title":"assignAutomerge"},{"location":"configuration-options/#assignees","text":"Assignees for Pull Request (either username or email address depending on the platform). Name Value type array subType string cli --assignees env RENOVATE_ASSIGNEES Must be valid usernames on the platform in use.","title":"assignees"},{"location":"configuration-options/#assigneesfromcodeowners","text":"Determine assignees based on configured code owners and changes in PR. Name Value type boolean default false cli --assignees-from-code-owners env RENOVATE_ASSIGNEES_FROM_CODE_OWNERS If enabled Renovate tries to determine PR assignees by matching rules defined in a CODEOWNERS file against the changes in the PR. See GitHub or GitLab documentation for details on syntax and possible file locations.","title":"assigneesFromCodeOwners"},{"location":"configuration-options/#assigneessamplesize","text":"Take a random sample of given size from assignees. Name Value type integer cli --assignees-sample-size env RENOVATE_ASSIGNEES_SAMPLE_SIZE If configured, Renovate will take a random sample of given size from assignees and assign them only, instead of assigning the entire list of assignees you have configured.","title":"assigneesSampleSize"},{"location":"configuration-options/#automerge","text":"Whether to automerge branches/PRs automatically, without human intervention. Name Value type boolean default false cli --automerge env RENOVATE_AUTOMERGE By default, Renovate raises PRs but leaves them to someone or something else to merge them. By configuring this setting, you allow Renovate to automerge PRs or even branches. Using automerge reduces the amount of human intervention required. Usually you won't want to automerge all PRs, for example most people would want to leave major dependency updates to a human to review first. You could configure Renovate to automerge all but major this way: { \"packageRules\" : [ { \"matchUpdateTypes\" : [ \"minor\" , \"patch\" , \"pin\" , \"digest\" ], \"automerge\" : true } ] } Also note that this option can be combined with other nested settings, such as dependency type. So for example you could choose to automerge all (passing) devDependencies only this way: { \"packageRules\" : [ { \"matchDepTypes\" : [ \"devDependencies\" ], \"automerge\" : true } ] } Important: Renovate won't automerge on GitHub if a PR has a negative review outstanding. Note On Azure there can be a delay between a PR being set as completed by Renovate, and Azure merging the PR / finishing its tasks. Renovate tries to delay until Azure is in the expected state, but it will continue if it takes too long. In some cases this can result in a dependency not being merged, and a fresh PR being created for the dependency.","title":"automerge"},{"location":"configuration-options/#automergecomment","text":"PR comment to add to trigger automerge. Only used if automergeType=pr-comment . Name Value type string default \"automergeComment\" cli --automerge-comment env RENOVATE_AUTOMERGE_COMMENT Use this only if you configure automergeType=\"pr-comment\" . Example use: { \"automerge\" : true , \"automergeType\" : \"pr-comment\" , \"automergeComment\" : \"bors: r+\" }","title":"automergeComment"},{"location":"configuration-options/#automergeschedule","text":"Limit automerge to these times of day or week. Name Value type array subType string cli --automerge-schedule default [\"at any time\"] Use the automergeSchedule option to define times of week or month during which Renovate may automerge its PRs. The default value for automergeSchedule is \"at any time\", which functions the same as setting a null schedule. To configure this option refer to schedule as the syntax is the same.","title":"automergeSchedule"},{"location":"configuration-options/#automergestrategy","text":"The merge strategy to use when automerging PRs. Used only if automergeType=pr . Name Value type string allowedValues auto,fast-forward,merge-commit,rebase,squash default \"auto\" supportedPlatforms bitbucket cli --automerge-strategy env RENOVATE_AUTOMERGE_STRATEGY This setting is only applicable if you opt-in by configuring automerge to true and automergeType to pr for any of your dependencies. The automerge strategy defaults to auto , in which Renovate will make its best guess as to how to merge pull requests. This generally results in Renovate respecting the strategy configured in the platform itself for the repository if possible. Acceptable values are: auto , in which the choice is left to Renovate fast-forward , which generally involves no new commits in the resultant tree, but \"fast-forwarding\" the main branch reference merge-commit , which generally involves synthesizing a new merge commit rebase , which generally involves rewriting history as part of the merge \u2014 but usually retaining the individual commits squash , which generally involves flattening the commits that are being merged into a single new commit Not all platforms support all pull request merge strategies. In cases where a merge strategy is not supported by the platform, Renovate will hold off on merging instead of silently merging in a way you didn't wish for. The only platform that supports automergeStrategy is Bitbucket Cloud.","title":"automergeStrategy"},{"location":"configuration-options/#automergetype","text":"How to automerge, if enabled. Name Value type string allowedValues branch,pr,pr-comment default \"pr\" cli --automerge-type env RENOVATE_AUTOMERGE_TYPE This setting is only applicable if you opt in to configure automerge to true for any of your dependencies. Automerging defaults to using Pull Requests ( automergeType=\"pr\" ). In that case Renovate first creates a branch and associated Pull Request, and then automerges the PR on a subsequent run once it detects the PR's status checks are \"green\". If by the next run the PR is already behind the base branch it will be automatically rebased, because Renovate only automerges branches which are up-to-date and green. If Renovate is scheduled for hourly runs on the repository but commits are made every 15 minutes to the main branch, then an automerge like this will keep getting deferred with every rebase. Tip If you have no tests but still want Renovate to automerge, you need to add \"ignoreTests\": true to your configuration. If you prefer that Renovate more silently automerge without Pull Requests at all, you can configure \"automergeType\": \"branch\" . In this case Renovate will: Create the branch, wait for test results Rebase it any time it gets out of date with the base branch Automerge the branch commit if it's: (a) up-to-date with the base branch, and (b) passing all tests As a backup, raise a PR only if either: (a) tests fail, or (b) tests remain pending for too long (default: 24 hours) The final value for automergeType is \"pr-comment\" , intended only for users who already have a \"merge bot\" such as bors-ng and want Renovate to not actually automerge by itself and instead tell bors-ng to merge for it, by using a comment in the PR. If you're not already using bors-ng or similar, don't worry about this option.","title":"automergeType"},{"location":"configuration-options/#azureautoapprove","text":"If set to true , Azure DevOps PRs will be automatically approved. Name Value type boolean default false supportedPlatforms azure cli --azure-auto-approve env RENOVATE_AZURE_AUTO_APPROVE Setting this to true will automatically approve the PRs in Azure DevOps. You can also configure this using packageRules if you want to use it selectively (e.g. per-package).","title":"azureAutoApprove"},{"location":"configuration-options/#azureworkitemid","text":"The id of an existing work item on Azure Boards to link to each PR. Name Value type integer default 0 supportedPlatforms azure cli --azure-work-item-id env RENOVATE_AZURE_WORK_ITEM_ID When creating a PR in Azure DevOps, some branches can be protected with branch policies to check for linked work items . Creating a work item in Azure DevOps is beyond the scope of Renovate, but Renovate can link an already existing work item when creating PRs.","title":"azureWorkItemId"},{"location":"configuration-options/#basebranches","text":"An array of one or more custom base branches to be processed. If left empty, the default branch will be chosen. Name Value type array env RENOVATE_BASE_BRANCHES By default, Renovate will detect and process only the repository's default branch. For most projects, this is the expected approach. Renovate also allows users to explicitly configure baseBranches , e.g. for use cases such as: You wish Renovate to process only a non-default branch, e.g. dev : \"baseBranches\": [\"dev\"] You have multiple release streams you need Renovate to keep up to date, e.g. in branches main and next : \"baseBranches\": [\"main\", \"next\"] It's possible to add this setting into the renovate.json file as part of the \"Configure Renovate\" onboarding PR. If so then Renovate will reflect this setting in its description and use package file contents from the custom base branch(es) instead of default. Note The baseBranches config option is not supported when forkMode is enabled, including in the Forking Renovate app.","title":"baseBranches"},{"location":"configuration-options/#bbusedefaultreviewers","text":"Use the default reviewers (Bitbucket only). Name Value type boolean default true supportedPlatforms bitbucket,bitbucket-server cli --bb-use-default-reviewers env RENOVATE_BB_USE_DEFAULT_REVIEWERS Configuring this to true means that Renovate will detect and apply the default reviewers rules to PRs (Bitbucket only).","title":"bbUseDefaultReviewers"},{"location":"configuration-options/#branchconcurrentlimit","text":"Limit to a maximum of x concurrent branches. 0 means no limit, null (default) inherits value from prConcurrentLimit . Name Value type integer cli --branch-concurrent-limit env RENOVATE_BRANCH_CONCURRENT_LIMIT By default, Renovate won't enforce any concurrent branch limits. The config:base preset that many extend from limits the number of concurrent branches to 10, but in many cases a limit as low as 3 or 5 can be most efficient for a repository. If you want the same limit for both concurrent branches and concurrent PRs, then just set a value for prConcurrentLimit and it will be reused for branch calculations too. But if you want to allow more concurrent branches than concurrent PRs, you can configure both values (e.g. branchConcurrentLimit=5 and prConcurrentLimit=3 ). This limit is enforced on a per-repository basis. Example config: { \"branchConcurrentLimit\" : 3 } Warning Leaving PRs/branches as unlimited or as a high number increases the time it takes for Renovate to process a repository. If you find that Renovate is too slow when rebasing out-of-date branches, decrease the branchConcurrentLimit . If you have too many concurrent branches which rebase themselves each run, Renovate can take a lot of time to rebase. Solutions: Decrease the concurrent branch limit (note: this won't go and delete any existing, so won't have an effect until you either merge or close existing ones manually) Remove automerge and/or automatic rebasing (set rebaseWhen to conflicted ). However if you have branch protection saying PRs must be up to date then it's not ideal to remove automatic rebasing","title":"branchConcurrentLimit"},{"location":"configuration-options/#branchname","text":"Branch name template. Name Value type string default \"{{{branchPrefix}}}{{{additionalBranchPrefix}}}{{{branchTopic}}}\" env RENOVATE_BRANCH_NAME Warning We strongly recommended that you do not configure this field directly. Use at your own risk. If you truly need to configure this then it probably means either: You are hopefully mistaken, and there's a better approach you should use, so open a new \"config help\" discussion at the Renovate discussions tab or You have a use case we didn't expect and we should have a feature request from you to add it to the project","title":"branchName"},{"location":"configuration-options/#branchprefix","text":"Prefix to use for all branch names. Name Value type string default \"renovate/\" cli --branch-prefix env RENOVATE_BRANCH_PREFIX You can modify this field if you want to change the prefix used. For example if you want branches to be like deps/eslint-4.x instead of renovate/eslint-4.x then you configure branchPrefix = deps/ . Or if you wish to avoid forward slashes in branch names then you could use renovate_ instead, for example. branchPrefix must be configured at the root of the configuration (e.g. not within any package rule) and is not allowed to use template values. e.g. instead of renovate/{{parentDir}}- , configure the template part in additionalBranchPrefix , like \"additionalBranchPrefix\": \"{{parentDir}}-\" . Note This setting does not change the default onboarding branch name, i.e. renovate/configure . If you wish to change that too, you need to also configure the field onboardingBranch in your global bot config.","title":"branchPrefix"},{"location":"configuration-options/#branchprefixold","text":"Old Prefix to check for existing PRs. Name Value type string default \"renovate/\" cli --branch-prefix-old env RENOVATE_BRANCH_PREFIX_OLD Renovate uses branch names as part of its checks to see if an update PR was created previously, and already merged or ignored. If you change branchPrefix , then no previously closed PRs will match, which could lead to Renovate recreating PRs in such cases. Instead, set the old branchPrefix value as branchPrefixOld to allow Renovate to look for those branches too, and avoid this happening.","title":"branchPrefixOld"},{"location":"configuration-options/#branchtopic","text":"Branch topic. Name Value type string default \"{{{depNameSanitized}}}-{{{newMajor}}}{{#if separateMinorPatch}}{{#if isPatch}}.{{{newMinor}}}{{/if}}{{/if}}.x{{#if isLockfileUpdate}}-lockfile{{/if}}\" env RENOVATE_BRANCH_TOPIC This field is combined with branchPrefix and additionalBranchPrefix to form the full branchName . branchName uniqueness is important for dependency update grouping or non-grouping so be cautious about ever editing this field manually. This is an advance field and it's recommend you seek a config review before applying it.","title":"branchTopic"},{"location":"configuration-options/#bumpversion","text":"Bump the version in the package file being updated. Name Value type string allowedValues major,minor,patch supportedManagers helmv3,npm,maven,sbt cli --bump-version env RENOVATE_BUMP_VERSION default null Currently this setting supports helmv3 , npm , maven and sbt only, so raise a feature request if you have a use for it with other package managers. Its purpose is if you want Renovate to update the version field within your package file any time it updates dependencies within. Usually this is for automatic release purposes, so that you don't need to add another step after Renovate before you can release a new version. Configure this value to \"patch\" , \"minor\" or \"major\" to have Renovate update the version in your edited package file. e.g. if you wish Renovate to always increase the target package.json version with a patch update, configure this to \"patch\" . For npm only you can also configure this field to \"mirror:x\" where x is the name of a package in the package.json . Doing so means that the package.json version field will mirror whatever the version is that x depended on. Make sure that version is a pinned version of course, as otherwise it won't be valid. For sbt note that Renovate will update the version string only for packages that have the version string in their project's built.sbt file.","title":"bumpVersion"},{"location":"configuration-options/#clonesubmodules","text":"Set to true to enable initialization of submodules during repository clone. Name Value type boolean default false cli --clone-submodules env RENOVATE_CLONE_SUBMODULES Enabling this option will mean that any detected Git submodules will be cloned at time of repository clone. Important: private submodules aren't supported by Renovate, unless the underlying ssh layer already has the correct permissions.","title":"cloneSubmodules"},{"location":"configuration-options/#commitbody","text":"Commit message body template. Will be appended to commit message, separated by two line returns. Name Value type string env RENOVATE_COMMIT_BODY default null Configure this if you wish Renovate to add a commit body, otherwise Renovate just uses a regular single-line commit. For example, To add [skip ci] to every commit you could configure: { \"commitBody\" : \"[skip ci]\" } Another example would be if you want to configure a DCO signoff to each commit.","title":"commitBody"},{"location":"configuration-options/#commitbodytable","text":"If enabled, append a table in the commit message body describing all updates in the commit. Name Value type boolean default false cli --commit-body-table env RENOVATE_COMMIT_BODY_TABLE","title":"commitBodyTable"},{"location":"configuration-options/#commitmessage","text":"Message to use for commit messages and pull request titles. Name Value type string default \"{{{commitMessagePrefix}}} {{{commitMessageAction}}} {{{commitMessageTopic}}} {{{commitMessageExtra}}} {{{commitMessageSuffix}}}\" env RENOVATE_COMMIT_MESSAGE Warning Editing of commitMessage directly is now deprecated and not recommended. Please instead edit the fields such as commitMessageAction , commitMessageExtra , etc.","title":"commitMessage"},{"location":"configuration-options/#commitmessageaction","text":"Action verb to use in commit messages and PR titles. Name Value type string default \"Update\" env RENOVATE_COMMIT_MESSAGE_ACTION This is used to alter commitMessage and prTitle without needing to copy/paste the whole string. Actions may be like Update , Pin , Roll back , Refresh , etc. Check out the default value for commitMessage to understand how this field is used.","title":"commitMessageAction"},{"location":"configuration-options/#commitmessageextra","text":"Extra description used after the commit message topic - typically the version. Name Value type string default [template] env RENOVATE_COMMIT_MESSAGE_EXTRA This is used to alter commitMessage and prTitle without needing to copy/paste the whole string. The \"extra\" is usually an identifier of the new version, e.g. \"to v1.3.2\" or \"to tag 9.2\".","title":"commitMessageExtra"},{"location":"configuration-options/#commitmessageprefix","text":"Prefix to add to start of commit messages and PR titles. Uses a semantic prefix if semanticCommits is enabled. Name Value type string env RENOVATE_COMMIT_MESSAGE_PREFIX default null This is used to alter commitMessage and prTitle without needing to copy/paste the whole string. The \"prefix\" is usually an automatically applied semantic commit prefix, but it can also be statically configured.","title":"commitMessagePrefix"},{"location":"configuration-options/#commitmessagesuffix","text":"Suffix to add to end of commit messages and PR titles. Name Value type string env RENOVATE_COMMIT_MESSAGE_SUFFIX default null This is used to add a suffix to commit messages. Usually left empty except for internal use (multiple base branches, and vulnerability alerts).","title":"commitMessageSuffix"},{"location":"configuration-options/#commitmessagetopic","text":"The upgrade topic/noun used in commit messages and PR titles. Name Value type string default \"dependency {{depName}}\" env RENOVATE_COMMIT_MESSAGE_TOPIC This is used to alter commitMessage and prTitle without needing to copy/paste the whole string. The \"topic\" is usually refers to the dependency being updated, e.g. \"dependency react\" .","title":"commitMessageTopic"},{"location":"configuration-options/#composerignoreplatformreqs","text":"Configure use of --ignore-platform-reqs or --ignore-platform-req for the Composer package manager. Name Value type array subType string cli --composer-ignore-platform-reqs env RENOVATE_COMPOSER_IGNORE_PLATFORM_REQS By default, Renovate will ignore Composer platform requirements as the PHP platform used by Renovate most probably won't match the required PHP environment of your project as configured in your composer.json file. Composer 2.2 and up will be run with --ignore-platform-req='ext-*' --ignore-platform-req='lib-*' , which ignores extension and library platform requirements but not the PHP version itself and should work in most cases. Older Composer versions will be run with --ignore-platform-reqs , which means that all platform constraints (including the PHP version) will be ignored by default. This can result in updated dependencies that are not compatible with your platform. To customize this behaviour, you can explicitly ignore platform requirements (for example ext-zip ) by setting them separately in this array. Each item will be added to the Composer command with --ignore-platform-req , resulting in it being ignored during its invocation. Note that this requires your project to use Composer V2, as V1 doesn't support excluding single platform requirements. The used PHP version will be guessed automatically from your composer.json definition, so php should not be added as explicit dependency. If an empty array is configured, Renovate uses its default behaviour. Set to null (not recommended) to fully omit --ignore-platform-reqs/--ignore-platform-req during Composer invocation. This requires the Renovate image to be fully compatible with your Composer platform requirements in order for the Composer invocation to succeed, otherwise Renovate will fail to create the updated lock file. The Composer output should inform you about the reasons the update failed.","title":"composerIgnorePlatformReqs"},{"location":"configuration-options/#confidential","text":"If enabled, issues created by Renovate are set as confidential. Name Value type boolean default false supportedPlatforms gitlab cli --confidential env RENOVATE_CONFIDENTIAL If enabled, all issues created by Renovate are set as confidential, even in a public repository. Note The Dependency Dashboard issue will also be confidential. By default issues created by Renovate are visible to all users. Note This option is applicable to GitLab only.","title":"confidential"},{"location":"configuration-options/#configwarningreuseissue","text":"Set this to false to make Renovate create a new issue for each config warning, instead of reopening or reusing an existing issue. Name Value type boolean default true cli --config-warning-reuse-issue env RENOVATE_CONFIG_WARNING_REUSE_ISSUE Renovate's default behavior is to reuse/reopen a single Config Warning issue in each repository so as to keep the \"noise\" down. However for some people this has the downside that the config warning won't be sorted near the top if you view issues by creation date. Configure this option to false if you prefer Renovate to open a new issue whenever there is a config warning.","title":"configWarningReuseIssue"},{"location":"configuration-options/#constraints","text":"Configuration object to define language or manager version constraints. Name Value type object mergeable true supportedManagers bundler,composer,gomod,npm,pipenv,poetry env RENOVATE_CONSTRAINTS Constraints are used in package managers which use third-party tools to update \"artifacts\" like lock files or checksum files. Typically, the constraint is detected automatically by Renovate from files within the repository and there is no need to manually configure it. Manually specifying constraints is supported for ruby , bundler , composer , go , npm , yarn , pnpm , python , pipenv , and poetry . Constraints are also used to manually restrict which datasource versions are possible to upgrade to based on their language support. For now this datasource constraint feature only supports python , other compatibility restrictions will be added in the future. { \"constraints\" : { \"python\" : \"2.7\" } } If you need to override constraints that Renovate detects from the repository, wrap it in the force object like so: { \"force\" : { \"constraints\" : { \"node\" : \"< 15.0.0\" } } } Note Make sure not to mix this up with the term compatibility , which Renovate uses in the context of version releases, e.g. if a Docker image is node:12.16.0-alpine then the -alpine suffix represents compatibility .","title":"constraints"},{"location":"configuration-options/#defaultregistryurls","text":"List of registry URLs to use as the default for a datasource. Name Value type array subType string Override a datasource's default registries with this config option. The datasources's customRegistrySupport value must be true for the config option to work. Default registries are only used when both: The manager did not extract any registryUrls values, and No registryUrls values have been applied via config, such as packageRules Think of defaultRegistryUrls as a way to specify the \"fallback\" registries for a datasource, for use when no registryUrls are extracted or configured. Compare that to registryUrls , which are a way to override registries.","title":"defaultRegistryUrls"},{"location":"configuration-options/#dependencydashboard","text":"Whether to create a \"Dependency Dashboard\" issue in the repository. Name Value type boolean default false cli --dependency-dashboard env RENOVATE_DEPENDENCY_DASHBOARD Starting from version v26.0.0 the \"Dependency Dashboard\" is enabled by default as part of the commonly-used config:base preset. To disable the Dependency Dashboard, add the preset :disableDependencyDashboard or set dependencyDashboard to false . { \"extends\" : [ \"config:base\" , \":disableDependencyDashboard\" ] } Configuring dependencyDashboard to true will lead to the creation of a \"Dependency Dashboard\" issue within the repository. This issue has a list of all PRs pending, open, closed (unmerged) or in error. The goal of this issue is to give visibility into all updates that Renovate is managing. Examples of what having a Dependency Dashboard will allow you to do: View all PRs in one place, rather than having to filter PRs by author Rebase/retry multiple PRs without having to open each individually Override any rate limiting (e.g. concurrent PRs) or scheduling to force Renovate to create a PR that would otherwise be suppressed Recreate an unmerged PR (e.g. for a major update that you postponed by closing the original PR) Tip Just enabling the Dependency Dashboard doesn't change the \"control flow\" of Renovate. Renovate still creates and manages PRs, and still follows your schedules and rate limits. The Dependency Dashboard gives you extra visibility and control over your updates.","title":"dependencyDashboard"},{"location":"configuration-options/#dependencydashboardapproval","text":"Controls if updates need manual approval from the Dependency Dashboard issue before PRs are created. Name Value type boolean default false cli --dependency-dashboard-approval env RENOVATE_DEPENDENCY_DASHBOARD_APPROVAL This feature allows you to use Renovate's Dependency Dashboard to force approval of updates before they are created. By setting dependencyDashboardApproval to true in config (including within packageRules ), you can tell Renovate to wait for your approval from the Dependency Dashboard before creating a branch/PR. You can approve a pending PR by ticking the checkbox in the Dependency Dashboard issue. Tip When you set dependencyDashboardApproval to true the Dependency Dashboard issue will be created automatically, you do not need to turn on dependencyDashboard explicitly. You can configure Renovate to wait for approval for: all package upgrades major, minor, patch level upgrades specific package upgrades upgrades coming from specific package managers If you want to approve all upgrades, set dependencyDashboardApproval to true : { \"dependencyDashboardApproval\" : true } If you want to require approval for major updates, set dependencyDashboardApproval to true within a major object: { \"major\" : { \"dependencyDashboardApproval\" : true } } If you want to approve specific packages, set dependencyDashboardApproval to true within a packageRules entry where you have defined a specific package or pattern. { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"^@package-name\" ], \"dependencyDashboardApproval\" : true } ] }","title":"dependencyDashboardApproval"},{"location":"configuration-options/#dependencydashboardautoclose","text":"Set to true to let Renovate close the Dependency Dashboard issue if there are no more updates. Name Value type boolean default false cli --dependency-dashboard-autoclose env RENOVATE_DEPENDENCY_DASHBOARD_AUTOCLOSE You can configure this to true if you prefer Renovate to close an existing Dependency Dashboard whenever there are no outstanding PRs left.","title":"dependencyDashboardAutoclose"},{"location":"configuration-options/#dependencydashboardfooter","text":"Any text added here will be placed last in the Dependency Dashboard issue body, with a divider separator before it. Name Value type string cli --dependency-dashboard-footer env RENOVATE_DEPENDENCY_DASHBOARD_FOOTER default null","title":"dependencyDashboardFooter"},{"location":"configuration-options/#dependencydashboardheader","text":"Any text added here will be placed first in the Dependency Dashboard issue body. Name Value type string default \"This issue provides visibility into Renovate updates and their statuses. [Learn more](https://docs.renovatebot.com/key-concepts/dashboard/)\" cli --dependency-dashboard-header env RENOVATE_DEPENDENCY_DASHBOARD_HEADER","title":"dependencyDashboardHeader"},{"location":"configuration-options/#dependencydashboardlabels","text":"These labels will always be applied on the Dependency Dashboard issue, even when they have been removed manually. Name Value type array subType string cli --dependency-dashboard-labels env RENOVATE_DEPENDENCY_DASHBOARD_LABELS The labels only get updated when the Dependency Dashboard issue updates its content and/or title. It is pointless to edit the labels, as Renovate bot restores the labels on each run.","title":"dependencyDashboardLabels"},{"location":"configuration-options/#dependencydashboardtitle","text":"Title to use for the Dependency Dashboard issue. Name Value type string default \"Dependency Dashboard\" cli --dependency-dashboard-title env RENOVATE_DEPENDENCY_DASHBOARD_TITLE Configure this option if you prefer a different title for the Dependency Dashboard.","title":"dependencyDashboardTitle"},{"location":"configuration-options/#description","text":"Plain text description for a config or preset. Name Value type array subType string mergeable true The description field can be used inside any configuration object to add a human-readable description of the object's config purpose. Descriptions fields embedded within presets are also collated as part of the onboarding description.","title":"description"},{"location":"configuration-options/#digest","text":"Configuration to apply when updating a digest (no change in tag/version). Name Value type object default {\"branchTopic\":\"{{{depNameSanitized}}}-digest\",\"commitMessageExtra\":\"to {{newDigestShort}}\",\"commitMessageTopic\":\"{{{depName}}} digest\"} mergeable true env RENOVATE_DIGEST Add to this object if you wish to define rules that apply only to PRs that update digests.","title":"digest"},{"location":"configuration-options/#docker","text":"Configuration object for Docker language. Name Value type object default {\"versioning\":\"docker\"} mergeable true env RENOVATE_DOCKER Add config here if you wish it to apply to Docker package managers Dockerfile and Docker Compose. If instead you mean to apply settings to any package manager that updates using the Docker datasource , use a package rule instead, e.g. { \"packageRules\" : [ { \"matchDatasources\" : [ \"docker\" ], \"labels\" : [ \"docker-update\" ] } ] }","title":"docker"},{"location":"configuration-options/#dotnet","text":"Configuration object for .NET language. Name Value type object mergeable true env RENOVATE_DOTNET","title":"dotnet"},{"location":"configuration-options/#draftpr","text":"If set to true then Renovate creates draft PRs, instead of normal status PRs. Name Value type boolean default false supportedPlatforms github,gitlab,azure cli --draft-p-r env RENOVATE_DRAFT_P_R If you want the PRs created by Renovate to be considered as drafts rather than normal PRs, you could add this property to your renovate.json : { \"draftPR\" : true } This option is evaluated at PR/MR creation time and is only supported on the following platforms: GitHub, GitLab, Azure. Note GitLab implements draft status by checking whether the PR's title starts with certain strings. This means that draftPR on GitLab is incompatible with the legacy method of triggering Renovate to rebase a PR by renaming the PR to start with rebase! .","title":"draftPR"},{"location":"configuration-options/#enabled","text":"Enable or disable Renovate bot. Name Value type boolean default true The most common use of enabled is if you want to turn Renovate's functionality off, for some reason. For example, if you wanted to disable Renovate completely on a repository, you could make this your renovate.json : { \"enabled\" : false } To disable Renovate for all eslint packages, you can configure a package rule like: { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"^eslint\" ], \"enabled\" : false } ] } To disable Renovate for npm devDependencies but keep it for dependencies you could configure: { \"packageRules\" : [ { \"matchManagers\" : [ \"npm\" ], \"matchDepTypes\" : [ \"devDependencies\" ], \"enabled\" : false } ] }","title":"enabled"},{"location":"configuration-options/#enabledmanagers","text":"A list of package managers to enable. If defined, then all managers not on the list are disabled. Name Value type array cli --enabled-managers env RENOVATE_ENABLED_MANAGERS This is a way to allow only certain package managers and implicitly disable all others. Example: { \"enabledManagers\" : [ \"dockerfile\" , \"npm\" ] } For the full list of available managers, see the Supported Managers documentation.","title":"enabledManagers"},{"location":"configuration-options/#encrypted","text":"An object containing configuration encrypted with project key. Name Value type object cli --encrypted env RENOVATE_ENCRYPTED See Private module support for details on how this is used to encrypt npm tokens. Note Encrypted secrets must have at least an org/group scope, and optionally a repository scope. This means that Renovate will check if a secret's scope matches the current repository before applying it, and warn/discard if there is a mismatch.","title":"encrypted"},{"location":"configuration-options/#excludecommitpaths","text":"A file that matches any of these glob patterns will not be committed, even if it has been updated. Name Value type array subType string cli --exclude-commit-paths env RENOVATE_EXCLUDE_COMMIT_PATHS Warning For advanced users only! Be careful you know what you're doing with this option. The initial intended use is to allow the user to exclude certain dependencies from being added/removed/modified when \"vendoring\" dependencies. Example: { \"excludeCommitPaths\" : [ \"vendor/golang.org/x/text/**\" ] } The above would mean Renovate would not include files matching the above glob pattern in the commit, even if it thinks they should be updated.","title":"excludeCommitPaths"},{"location":"configuration-options/#extends","text":"Configuration presets to use or extend. Note: This config option does not work if you use a config.js file. Name Value type array subType string env RENOVATE_EXTENDS See shareable config presets for details.","title":"extends"},{"location":"configuration-options/#extractversion","text":"A regex ( re2 ) to extract a version from a datasource's raw version string. Name Value type string format regex default null Only use this config option when the raw version strings from the datasource do not match the expected format that you need in your package file. You must define a \"named capture group\" called version like in the examples below. For example, to extract only the major.minor precision from a GitHub release, the following would work: { \"packageRules\" : [ { \"matchPackageNames\" : [ \"foo\" ], \"extractVersion\" : \"^(?<version>v\\\\d+\\\\.\\\\d+)\" } ] } The above will change a raw version of v1.31.5 to v1.31 , for example. Alternatively, to strip a release- prefix: { \"packageRules\" : [ { \"matchPackageNames\" : [ \"bar\" ], \"extractVersion\" : \"^release-(?<version>.*)$\" } ] } The above will change a raw version of release-2.0.0 to 2.0.0 , for example. A similar one could strip leading v prefixes: { \"packageRules\" : [ { \"matchPackageNames\" : [ \"baz\" ], \"extractVersion\" : \"^v(?<version>.*)$\" } ] }","title":"extractVersion"},{"location":"configuration-options/#fetchreleasenotes","text":"Controls if release notes are fetched. Name Value type boolean default true Set this to false if you want to disable release notes fetching. Renovate can fetch release notes when they are hosted on one of these platforms: GitHub (.com and Enterprise Server) GitLab (.com and CE/EE) Note Renovate can only show release notes from some platforms and some package managers. We're planning improvements so that Renovate can show more release notes. Read issue 14138 on GitHub to get a overview of the planned work.","title":"fetchReleaseNotes"},{"location":"configuration-options/#filematch","text":"RegEx ( re2 ) pattern for matching manager files. Name Value type array subType string format regex mergeable true fileMatch is used by Renovate to know which files in a repository to parse and extract, and it is possible to override the default values to customize for your project's needs. Sometimes file matches are really simple - for example with Go Modules Renovate looks for any go.mod file, and you probably don't need to change that default. At other times, the possible files is too vague for Renovate to have any default. For default, Kubernetes manifests can exist in any *.yaml file and we don't want Renovate to parse every single YAML file in every repository just in case some of them have a Kubernetes manifest, so Renovate's default fileMatch for manager kubernetes is actually empty ( [] ) and needs the user to tell Renovate what directories/files to look in. Finally, there are cases where Renovate's default fileMatch is good, but you may be using file patterns that a bot couldn't possibly guess about. For example, Renovate's default fileMatch for Dockerfile is ['(^|/|\\\\.)Dockerfile$', '(^|/)Dockerfile[^/]*$'] . This will catch files like backend/Dockerfile , prefix.Dockerfile or Dockerfile-suffix , but it will miss files like ACTUALLY_A_DOCKERFILE.template . Because fileMatch is mergeable, you don't need to duplicate the defaults and could just add the missing file like this: { \"dockerfile\" : { \"fileMatch\" : [ \"^ACTUALLY_A_DOCKERFILE\\\\.template$\" ] } } If you configure fileMatch then it must be within a manager object (e.g. dockerfile in the above example). The full list of supported managers can be found here .","title":"fileMatch"},{"location":"configuration-options/#filterunavailableusers","text":"Filter reviewers and assignees based on their availability. Name Value type boolean default false supportedPlatforms gitlab cli --filter-unavailable-users env RENOVATE_FILTER_UNAVAILABLE_USERS When this option is enabled PRs are not assigned to users that are unavailable. This option only works on platforms that support the concept of user availability. For now, you can only use this option on the GitLab platform.","title":"filterUnavailableUsers"},{"location":"configuration-options/#followtag","text":"If defined, packages will follow this release tag exactly. Name Value type string default null Warning Advanced functionality. Only use this if you're sure you know what you're doing. This functionality requires that the datasource to support distribution streams/tags, such as npm does. The primary use case for this option is if you are following a pre-release tag of a certain dependency, e.g. typescript 's \"insiders\" build. If configured, Renovate bypasses its normal major/minor/patch upgrade logic and stable/unstable consistency logic and keeps your dependency version sync'd strictly to whatever version is in the tag. Beware that Renovate follows tags strictly. For example, if you are following a tag like next and then that stream is released as stable and next is no longer being updated then that means your dependencies also won't be getting updated.","title":"followTag"},{"location":"configuration-options/#gitauthor","text":"Author to use for Git commits. Must conform to RFC5322 . Name Value type string cli --git-author env RENOVATE_GIT_AUTHOR default null You can customize the Git author that's used whenever Renovate creates a commit. The gitAuthor option accepts a RFC5322-compliant string. Danger We strongly recommend that the Git author email you use is unique to Renovate. Otherwise, if another bot or human shares the same email and pushes to one of Renovate's branches then Renovate will mistake the branch as unmodified and potentially force push over the changes.","title":"gitAuthor"},{"location":"configuration-options/#gitignoredauthors","text":"Additional Git authors which are ignored by Renovate. Must conform to RFC5322 . Name Value type array subType string cli --git-ignored-authors env RENOVATE_GIT_IGNORED_AUTHORS Specify commit authors ignored by Renovate. By default, Renovate will treat any PR as modified if another Git author has added to the branch. When a PR is considered modified, Renovate won't perform any further commits such as if it's conflicted or needs a version update. If you have other bots which commit on top of Renovate PRs, and don't want Renovate to treat these PRs as modified, then add the other Git author(s) to gitIgnoredAuthors . Example: { \"gitIgnoredAuthors\" : [ \"some-bot@example.org\" ] }","title":"gitIgnoredAuthors"},{"location":"configuration-options/#gitlabignoreapprovals","text":"Ignore approval rules for MRs created by Renovate, which is useful for automerge. Name Value type boolean default false cli --git-lab-ignore-approvals env RENOVATE_GIT_LAB_IGNORE_APPROVALS Ignore the default project level approval(s), so that Renovate bot can automerge its merge requests, without needing approval(s). Under the hood, it creates a MR-level approval rule where approvals_required is set to 0 . This option works only when automerge=true , automergeType=pr or automergeType=branch and platformAutomerge=true . Also, approval rules overriding should not be prevented in GitLab settings .","title":"gitLabIgnoreApprovals"},{"location":"configuration-options/#golang","text":"Configuration object for Go language. Name Value type object default {\"commitMessageTopic\":\"module {{depName}}\"} mergeable true env RENOVATE_GOLANG Configuration added here applies for all Go-related updates. The only supported package manager for Go is the native Go Modules (the gomod manager). For self-hosted users, GOPROXY , GONOPROXY and GOPRIVATE environment variables are supported ( reference ). Usage of direct will fallback to the Renovate-native release fetching mechanism. Also we support the off keyword which will stop any fetching immediately.","title":"golang"},{"location":"configuration-options/#group","text":"Config if groupName is enabled. Name Value type object default {\"branchTopic\":\"{{{groupSlug}}}\",\"commitMessageTopic\":\"{{{groupName}}}\"} mergeable true Warning Advanced functionality only. Do not use unless you know what you're doing. The default configuration for groups are essentially internal to Renovate and you normally shouldn't need to modify them. But you may add settings to any group by defining your own group configuration object.","title":"group"},{"location":"configuration-options/#groupname","text":"Human understandable name for the dependency group. Name Value type string cli --group-name env RENOVATE_GROUP_NAME There are multiple cases where it can be useful to group multiple upgrades together. Internally Renovate uses this for branches such as \"Pin Dependencies\", \"Lock File Maintenance\", etc. Another example used previously is to group together all related eslint packages, or perhaps angular or babel . To enable grouping, you configure the groupName field to something non-null. The groupName field allows free text and does not have any semantic interpretation by Renovate. All updates sharing the same groupName will be placed into the same branch/PR. For example, to group all non-major devDependencies updates together into a single PR: { \"packageRules\" : [ { \"matchDepTypes\" : [ \"devDependencies\" ], \"matchUpdateTypes\" : [ \"patch\" , \"minor\" ], \"groupName\" : \"devDependencies (non-major)\" } ] }","title":"groupName"},{"location":"configuration-options/#groupslug","text":"Slug to use for group (e.g. in branch name). Will be calculated from groupName if null . Name Value type string By default, Renovate will \"slugify\" the groupName to determine the branch name. For example if you named your group \"devDependencies (non-major)\" then the branchName would be renovate/devdependencies-non-major . If you wished to override this then you could configure like this: { \"packageRules\" : [ { \"matchDepTypes\" : [ \"devDependencies\" ], \"matchUpdateTypes\" : [ \"patch\" , \"minor\" ], \"groupName\" : \"devDependencies (non-major)\" , \"groupSlug\" : \"dev-dependencies\" } ] } As a result of the above, the branchName would be renovate/dev-dependencies instead. Note You shouldn't usually need to configure this unless you really care about your branch names.","title":"groupSlug"},{"location":"configuration-options/#hashedbranchlength","text":"If enabled, branch names will use a hashing function to ensure each branch has that length. Name Value type integer env RENOVATE_HASHED_BRANCH_LENGTH Some code hosting systems have restrictions on the branch name lengths, this option lets you get around these restrictions. You can set the hashedBranchLength option to a number of characters that works for your system and then Renovate will generate branch names with the correct length by hashing additionalBranchPrefix and branchTopic , and then truncating the hash so that the full branch name (including branchPrefix ) has the right number of characters. Example: If you have set branchPrefix: \"deps-\" and hashedBranchLength: 12 it will result in a branch name like deps-5bf36ec instead of the traditional pretty branch name like deps-react-17.x .","title":"hashedBranchLength"},{"location":"configuration-options/#hostrules","text":"Host rules/configuration including credentials. Name Value type array subType object default [{\"timeout\":60000}] cli --host-rules mergeable true env RENOVATE_HOST_RULES The primary purpose of hostRules is to configure credentials for host authentication. You tell Renovate how to match against the host you need authenticated, and then you also tell it which credentials to use. The lookup keys for hostRules are: hostType and matchHost , both of which are optional. Supported credential fields are token , username , password , timeout , enabled and insecureRegistry . Example for configuring docker auth: { \"hostRules\" : [ { \"matchHost\" : \"docker.io\" , \"username\" : \"<some-username>\" , \"password\" : \"<some-password>\" } ] } If multiple hostRules match a request, then they will be applied in the following order/priority: rules with only hostType specified rules with only matchHost specified (sorted by matchHost length if multiple match) rules with both matchHost and hostType specified (sorted by matchHost length if multiple match) To disable requests to a particular host, you can configure a rule like: { \"hostRules\" : [ { \"matchHost\" : \"registry.npmjs.org\" , \"enabled\" : false } ] } A preset alternative to the above is: { \"extends\" : [ \":disableHost(registry.npmjs.org)\" ] } Note Disabling a host is only 100% effective if added to self-hosted config. Renovate currently still checks its cache for results first before trying to connect, so if a public host is blocked in your repository config (e.g. renovate.json ) then it's possible you may get cached results from that host if another repository using the same bot has successfully queried for the same dependency recently.","title":"hostRules"},{"location":"configuration-options/#abortignorestatuscodes","text":"A list of HTTP status codes safe to ignore even when abortOnError=true . Name Value type array subType number parent hostRules This field can be used to configure status codes that Renovate ignores and passes through when abortOnError is set to true . For example to also skip 404 responses then configure the following: { \"hostRules\" : [ { \"abortOnError\" : true , \"abortIgnoreStatusCodes\" : [ 404 ] } ] } Tip This field is not mergeable, so the last-applied host rule takes precedence.","title":"abortIgnoreStatusCodes"},{"location":"configuration-options/#abortonerror","text":"If enabled, Renovate will abort its run when HTTP request errors occur. Name Value type boolean parent hostRules default false Use this field to configure Renovate to abort runs for custom hosts. By default, Renovate will only abort for known public hosts, which has the downside that transient errors for other hosts can cause autoclosing of PRs. To abort Renovate runs for http failures from any host: { \"hostRules\" : [ { \"abortOnError\" : true } ] } To abort Renovate runs for any docker datasource failures: { \"hostRules\" : [ { \"hostType\" : \"docker\" , \"abortOnError\" : true } ] } To abort Renovate for errors for a specific docker host: { \"hostRules\" : [ { \"matchHost\" : \"docker.company.com\" , \"abortOnError\" : true } ] } When this field is enabled, Renovate will abort its run if it encounters either (a) any low-level http error (e.g. ETIMEDOUT ) or (b) gets a response not matching any of the configured abortIgnoreStatusCodes (e.g. 500 Internal Error );","title":"abortOnError"},{"location":"configuration-options/#authtype","text":"Authentication type for http header. e.g. \"Bearer\" or \"Basic\" . Use \"Token-Only\" to use only the token without an authorization type. Name Value type string parent hostRules default \"Bearer\" This can be used with token to create a custom http authorization header. An example for npm basic auth with token: { \"hostRules\" : [ { \"matchHost\" : \"npm.custom.org\" , \"token\" : \"<some-token>\" , \"authType\" : \"Basic\" } ] } This will generate the following header: authorization: Basic <some-token> . To use a bare token in the authorization header (required by e.g. Hex) - use the authType \"Token-Only\": { \"hostRules\" : [ { \"matchHost\" : \"https://hex.pm/api/repos/private_repo/\" , \"token\" : \"<some-token>\" , \"authType\" : \"Token-Only\" } ] } This will generate the header authorization: <some-token> .","title":"authType"},{"location":"configuration-options/#concurrentrequestlimit","text":"Limit concurrent requests per host. Name Value type integer parent hostRules Usually the default setting is fine, but you can use concurrentRequestLimit to limit the number of concurrent outstanding requests. You only need to adjust this setting if a datasource is rate limiting Renovate or has problems with the load. The limit will be set for any host it applies to. Example config: { \"hostRules\" : [ { \"matchHost\" : \"github.com\" , \"concurrentRequestLimit\" : 2 } ] }","title":"concurrentRequestLimit"},{"location":"configuration-options/#enablehttp2","text":"Enable got HTTP/2 support. Name Value type boolean parent hostRules default false Enable got http2 support.","title":"enableHttp2"},{"location":"configuration-options/#hosttype","text":"hostType for a package rule. Can be a platform name or a datasource name. Name Value type string parent hostRules default null hostType is another way to filter rules and can be either a platform such as github and bitbucket-server , or it can be a datasource such as docker and rubygems . You usually don't need to configure it in a host rule if you have already configured matchHost and only one host type is in use for those, as is usually the case. hostType can help for cases like an enterprise registry that serves multiple package types and has different authentication for each, although it's often the case that multiple matchHost rules could achieve the same thing.","title":"hostType"},{"location":"configuration-options/#insecureregistry","text":"Explicitly turn on insecure Docker registry access (HTTP). Name Value type boolean parent hostRules default true Warning Advanced config, use at your own risk. Enable this option to allow Renovate to connect to an insecure Docker registry that is http only. This is insecure and is not recommended. Example: { \"hostRules\" : [ { \"matchHost\" : \"reg.insecure.com\" , \"insecureRegistry\" : true } ] }","title":"insecureRegistry"},{"location":"configuration-options/#matchhost","text":"A domain name, host name or base URL to match against. Name Value type string parent hostRules default null This can be a base URL (e.g. https://api.github.com ) or a hostname like github.com or api.github.com . If the value starts with http(s) then it will only match against URLs which start with the full base URL. Otherwise, it will be matched by checking if the URL's hostname matches the matchHost directly or ends with it. When checking the end of the hostname, a single dot is prefixed to the value of matchHost , if one is not already present, to ensure it can only match against whole domain segments.","title":"matchHost"},{"location":"configuration-options/#timeout","text":"Timeout (in milliseconds) for queries to external endpoints. Name Value type integer parent hostRules Use this figure to adjust the timeout for queries. The default is 60s, which is quite high. To adjust it down to 10s for all queries, do this: { \"hostRules\" : [ { \"timeout\" : 10000 } ] }","title":"timeout"},{"location":"configuration-options/#ignoredeprecated","text":"Avoid upgrading from a non-deprecated version to a deprecated one. Name Value type boolean default true cli --ignore-deprecated env RENOVATE_IGNORE_DEPRECATED By default, Renovate won't update a dependency version to a deprecated release unless the current version was itself deprecated. The goal of this is to make sure you don't upgrade from a non-deprecated version to a deprecated one just because it's higher than the current version. If for some reason you wish to force deprecated updates with Renovate, you can configure ignoreDeprecated to false , but this is not recommended for most situations.","title":"ignoreDeprecated"},{"location":"configuration-options/#ignoredeps","text":"Dependencies to ignore. Name Value type array subType string mergeable true cli --ignore-deps env RENOVATE_IGNORE_DEPS The ignoreDeps configuration field allows you to define a list of dependency names to be ignored by Renovate. Currently it supports only \"exact match\" dependency names and not any patterns. e.g. to ignore both eslint and eslint-config-base you would add this to your config: { \"ignoreDeps\" : [ \"eslint\" , \"eslint-config-base\" ] } The above is the same as if you wrote this package rule: { \"packageRules\" : [ { \"matchPackageNames\" : [ \"eslint\" , \"eslint-config-base\" ], \"enabled\" : false } ] }","title":"ignoreDeps"},{"location":"configuration-options/#ignorepaths","text":"Skip any package file whose path matches one of these. Can be a string or glob pattern. Name Value type array mergeable false subType string default [\"**/node_modules/**\",\"**/bower_components/**\"] cli --ignore-paths env RENOVATE_IGNORE_PATHS Renovate will extract dependencies from every file it finds in a repository, unless that file is explicitly ignored. With this setting you can selectively ignore package files that would normally be \"autodiscovered\" and updated by Renovate. For instance if you have a project with an \"examples/\" directory you wish to ignore: { \"ignorePaths\" : [ \"**/examples/**\" ] } Renovate's default ignore is node_modules and bower_components only. If you are extending from the popular config:base preset then it adds ignore patterns for vendor , examples , test(s) and fixtures directories too.","title":"ignorePaths"},{"location":"configuration-options/#ignoreplugins","text":"Set this to true if allowPlugins=true but you wish to skip running plugins when updating lock files. Name Value type boolean default false cli --ignore-plugins env RENOVATE_IGNORE_PLUGINS Set this to true if running plugins causes problems. Applicable for Composer only for now.","title":"ignorePlugins"},{"location":"configuration-options/#ignoreprauthor","text":"Set to true to fetch the entire list of PRs instead of only those authored by the Renovate user. Name Value type boolean default false cli --ignore-pr-author env RENOVATE_IGNORE_PR_AUTHOR This is usually needed if someone needs to migrate bot accounts, including from hosted app to self-hosted. If ignorePrAuthor is configured to true, it means Renovate will fetch the entire list of repository PRs instead of optimizing to fetch only those PRs which it created itself. You should only want to enable this if you are changing the bot account (e.g. from @old-bot to @new-bot ) and want @new-bot to find and update any existing PRs created by @old-bot . It's recommended to revert this setting once that transition period is over and all old PRs are resolved.","title":"ignorePrAuthor"},{"location":"configuration-options/#ignorepresets","text":"A list of presets to ignore, including any that are nested inside an extends array. Name Value type array subType string env RENOVATE_IGNORE_PRESETS Use this if you are extending a complex preset but don't want to use every \"sub preset\" that it includes. For example, consider this config: { \"extends\" : [ \"config:base\" ], \"ignorePresets\" : [ \":prHourlyLimit2\" ] } It would take the entire \"config:base\" preset - which has a lot of sub-presets - but ignore the \":prHourlyLimit2\" rule.","title":"ignorePresets"},{"location":"configuration-options/#ignorescripts","text":"Set this to true if allowScripts=true but you wish to skip running scripts when updating lock files. Name Value type boolean default false supportedManagers npm,composer cli --ignore-scripts env RENOVATE_IGNORE_SCRIPTS Applicable for npm and Composer only for now. Set this to true if running scripts causes problems.","title":"ignoreScripts"},{"location":"configuration-options/#ignoretests","text":"Set to true to enable automerging without tests. Name Value type boolean default false cli --ignore-tests env RENOVATE_IGNORE_TESTS Currently Renovate's default behavior is to only automerge if every status check has succeeded. Setting this option to true means that Renovate will ignore all status checks. You can set this if you don't have any status checks but still want Renovate to automerge PRs. Beware: configuring Renovate to automerge without any tests can lead to broken builds on your base branch, please think again before enabling this!","title":"ignoreTests"},{"location":"configuration-options/#ignoreunstable","text":"Ignore versions with unstable SemVer. Name Value type boolean cli --ignore-unstable env RENOVATE_IGNORE_UNSTABLE default true By default, Renovate won't update any package versions to unstable versions (e.g. 4.0.0-rc3 ) unless the current version has the same major.minor.patch and was already unstable (e.g. it was already on 4.0.0-rc2 ). Renovate will also not \"jump\" unstable versions automatically, e.g. if you are on 4.0.0-rc2 and newer versions 4.0.0 and 4.1.0-alpha.1 exist then Renovate will update you to 4.0.0 only. If you need to force permanent unstable updates for a package, you can add a package rule setting ignoreUnstable to false . Also check out the followTag configuration option above if you wish Renovate to keep you pinned to a particular release tag.","title":"ignoreUnstable"},{"location":"configuration-options/#includeforks","text":"Whether to process forked repositories. By default, all forked repositories are skipped. Name Value type boolean default false cli --include-forks env RENOVATE_INCLUDE_FORKS By default, Renovate will skip over any repositories that are forked. This includes if the forked repository has a Renovate config file, because Renovate can't tell if that file was added by the original repository or not. If you wish to enable processing of a forked repository by Renovate, you need to add \"includeForks\": true to your repository config or run the CLI command with --include-forks=true . If you are using the hosted Mend Renovate then this option will be configured to true automatically if you \"Selected\" repositories individually but remain as false if you installed for \"All\" repositories.","title":"includeForks"},{"location":"configuration-options/#includepaths","text":"Include package files only within these defined paths. Name Value type array subType string cli --include-paths env RENOVATE_INCLUDE_PATHS If you wish for Renovate to process only select paths in the repository, use includePaths . Alternatively, if you need to just exclude certain paths in the repository then consider ignorePaths instead. If you are more interested in including only certain package managers (e.g. npm ), then consider enabledManagers instead.","title":"includePaths"},{"location":"configuration-options/#internalchecksfilter","text":"When and how to filter based on internal checks. Name Value type string allowedValues strict,flexible,none default \"none\" cli --internal-checks-filter env RENOVATE_INTERNAL_CHECKS_FILTER This setting determines whether Renovate controls when and how filtering of internal checks are performed, particularly when multiple versions of the same update type are available. Currently this applies to the stabilityDays check only. none : No filtering will be performed, and the highest release will be used regardless of whether it's pending or not strict : All pending releases will be filtered. PRs will be skipped unless a non-pending version is available flexible : Similar to strict, but in the case where all versions are pending then a PR will be created with the highest pending version The flexible mode can result in \"flapping\" of Pull Requests, where e.g. a pending PR with version 1.0.3 is first released but then downgraded to 1.0.2 once it passes stabilityDays . We recommend that you use the strict mode, and enable the dependencyDashboard so that you have visibility into suppressed PRs.","title":"internalChecksFilter"},{"location":"configuration-options/#java","text":"Configuration object for all Java package managers. Name Value type object mergeable true env RENOVATE_JAVA Use this configuration option for shared config across all Java projects (Gradle and Maven).","title":"java"},{"location":"configuration-options/#js","text":"Configuration object for JavaScript language. Name Value type object mergeable true cli --js env RENOVATE_JS Use this configuration option for shared config across npm/Yarn/pnpm and meteor package managers.","title":"js"},{"location":"configuration-options/#labels","text":"Labels to set in Pull Request. Name Value type array subType string cli --labels env RENOVATE_LABELS By default, Renovate won't add any labels to its PRs. If you want Renovate to do so then define a labels array of one or more label strings. If you want the same label(s) for every PR then you can configure it at the top level of config. However you can also fully override them on a per-package basis. Consider this example: { \"labels\" : [ \"dependencies\" ], \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"eslint\" ], \"labels\" : [ \"linting\" ] } ] } With the above config, every PR raised by Renovate will have the label dependencies while PRs containing eslint -related packages will instead have the label linting .","title":"labels"},{"location":"configuration-options/#lockfilemaintenance","text":"Configuration for lock file maintenance. Name Value type object default {\"enabled\":false,\"recreateClosed\":true,\"rebaseStalePrs\":true,\"branchTopic\":\"lock-file-maintenance\",\"commitMessageAction\":\"Lock file maintenance\",\"commitMessageTopic\":null,\"commitMessageExtra\":null,\"schedule\":[\"before 5am on monday\"],\"groupName\":null,\"prBodyDefinitions\":{\"Change\":\"All locks refreshed\"}} mergeable true env RENOVATE_LOCK_FILE_MAINTENANCE This feature can be used to refresh lock files and keep them up-to-date. \"Maintaining\" a lock file means recreating it so that every dependency version within it is updated to the latest. Supported lock files are: package-lock.json yarn.lock composer.lock Gemfile.lock poetry.lock Cargo.lock jsonnetfile.lock.json Others may be added via feature request. This feature is disabled by default. If you wish to enable this feature then you could add this to your configuration: { \"lockFileMaintenance\" : { \"enabled\" : true } } To reduce \"noise\" in the repository, it defaults its schedule to \"before 5am on monday\" , i.e. to achieve once-per-week semantics. Depending on its running schedule, Renovate may run a few times within that time window - even possibly updating the lock file more than once - but it hopefully leaves enough time for tests to run and automerge to apply, if configured.","title":"lockFileMaintenance"},{"location":"configuration-options/#major","text":"Configuration to apply when an update type is major . Name Value type object mergeable true env RENOVATE_MAJOR Add to this object if you wish to define rules that apply only to major updates.","title":"major"},{"location":"configuration-options/#minor","text":"Configuration to apply when an update type is minor . Name Value type object mergeable true env RENOVATE_MINOR Add to this object if you wish to define rules that apply only to minor updates.","title":"minor"},{"location":"configuration-options/#node","text":"Configuration object for Node version renovation. Name Value type object default {\"commitMessageTopic\":\"Node.js\"} mergeable true env RENOVATE_NODE Using this configuration option allows you to apply common configuration and policies across all Node.js version updates even if managed by different package managers ( npm , yarn , etc.). Check out our Node.js documentation for a comprehensive explanation of how the node option can be used.","title":"node"},{"location":"configuration-options/#npmtoken","text":"npm token used to authenticate with the default registry. Name Value type string cli --npm-token env RENOVATE_NPM_TOKEN default null See Private npm module support for details on how this is used. Typically you would encrypt it and put it inside the encrypted object.","title":"npmToken"},{"location":"configuration-options/#npmrc","text":"String copy of .npmrc file. Use \\n instead of line breaks. Name Value type string cli --npmrc env RENOVATE_NPMRC default null See Private npm module support for details on how this is used.","title":"npmrc"},{"location":"configuration-options/#npmrcmerge","text":"Whether to merge config.npmrc with repo .npmrc content if both are found. Name Value type boolean default false cli --npmrc-merge env RENOVATE_NPMRC_MERGE This option exists to provide flexibility about whether npmrc strings in config should override .npmrc files in the repo, or be merged with them. In some situations you need the ability to force override .npmrc contents in a repo ( npmrcMerge=false ) while in others you might want to simply supplement the settings already in the .npmrc ( npmrcMerge=true ). A use case for the latter is if you are a Renovate bot admin and wish to provide a default token for npmjs.org without removing any other .npmrc settings which individual repositories have configured (such as scopes/registries). If false (default), it means that defining config.npmrc will result in any .npmrc file in the repo being overridden and its values ignored. If configured to true , it means that any .npmrc file in the repo will have config.npmrc prepended to it before running npm .","title":"npmrcMerge"},{"location":"configuration-options/#packagerules","text":"Rules for matching package names. Name Value type array mergeable true packageRules is a powerful feature that lets you apply rules to individual packages or to groups of packages using regex pattern matching. Here is an example if you want to group together all packages starting with eslint into a single branch/PR: { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"^eslint\" ], \"groupName\" : \"eslint packages\" } ] } Note how the above uses matchPackagePatterns with a regex value. Here is an example where you might want to limit the \"noisy\" package aws-sdk to updates just once per week: { \"packageRules\" : [ { \"matchPackageNames\" : [ \"aws-sdk\" ], \"schedule\" : [ \"after 9pm on sunday\" ] } ] } For Maven dependencies, the package name is <groupId:artefactId> , e.g. \"matchPackageNames\": [\"com.thoughtworks.xstream:xstream\"] Note how the above uses matchPackageNames instead of matchPackagePatterns because it is an exact match package name. This is the equivalent of defining \"matchPackagePatterns\": [\"^aws\\-sdk$\"] and hence much simpler. However you can mix together both matchPackageNames and matchPackagePatterns in the same package rule and the rule will be applied if either match. Example: { \"packageRules\" : [ { \"matchPackageNames\" : [ \"neutrino\" ], \"matchPackagePatterns\" : [ \"^@neutrino/\" ], \"groupName\" : \"neutrino monorepo\" } ] } The above rule will group together the neutrino package and any package matching @neutrino/* . Path rules are convenient to use if you wish to apply configuration rules to certain package files using patterns. For example, if you have an examples directory and you want all updates to those examples to use the chore prefix instead of fix , then you could add this configuration: { \"packageRules\" : [ { \"matchPaths\" : [ \"examples/**\" ], \"extends\" : [ \":semanticCommitTypeAll(chore)\" ] } ] } If you wish to limit Renovate to apply configuration rules to certain files in the root repository directory, you have to use matchPaths with either a partial string match or a minimatch pattern. For example you have multiple package.json and want to use dependencyDashboardApproval only on the root package.json : { \"packageRules\" : [ { \"matchPaths\" : [ \"+(package.json)\" ], \"dependencyDashboardApproval\" : true } ] } Important to know: Renovate will evaluate all packageRules and not stop once it gets a first match. You should order your packageRules in order of importance so that later rules can override settings from earlier rules if needed.","title":"packageRules"},{"location":"configuration-options/#allowedversions","text":"A version range or regex pattern capturing allowed versions for dependencies. Name Value type string parent packageRules default null Use this - usually within a packageRule - to limit how far to upgrade a dependency. For example, if you wish to upgrade to Angular v1.5 but not to angular v1.6 or higher, you could define this to be <= 1.5 or < 1.6.0 : { \"packageRules\" : [ { \"matchPackageNames\" : [ \"angular\" ], \"allowedVersions\" : \"<=1.5\" } ] } The valid syntax for this will be calculated at runtime because it depends on the versioning scheme, which is itself dynamic. This field also supports Regular Expressions if they begin and end with / . For example, the following will enforce that only 3 or 4-part versions are supported, without any prefixes: { \"packageRules\" : [ { \"matchPackageNames\" : [ \"com.thoughtworks.xstream:xstream\" ], \"allowedVersions\" : \"/^[0-9]+\\\\.[0-9]+\\\\.[0-9]+(\\\\.[0-9]+)?$/\" } ] } This field also supports a special negated regex syntax for ignoring certain versions. Use the syntax !/ / like the following: { \"packageRules\" : [ { \"matchPackageNames\" : [ \"chalk\" ], \"allowedVersions\" : \"!/java$/\" } ] }","title":"allowedVersions"},{"location":"configuration-options/#matchdeptypes","text":"List of depTypes to match (e.g. [ peerDependencies ]). Valid only within packageRules object. Name Value type array subType string parent packageRules mergeable true Use this field if you want to limit a packageRule to certain depType values. Invalid if used outside of a packageRule .","title":"matchDepTypes"},{"location":"configuration-options/#excludepackagenames","text":"Package names to exclude. Valid only within a packageRules object. Name Value type array subType string parent packageRules mergeable true Important : Do not mix this up with the option ignoreDeps . Use ignoreDeps instead if all you want to do is have a list of package names for Renovate to ignore. Use excludePackageNames if you want to have one or more exact name matches excluded in your package rule. See also matchPackageNames . { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"^eslint\" ], \"excludePackageNames\" : [ \"eslint-foo\" ] } ] } The above will match all package names starting with eslint but exclude the specific package eslint-foo .","title":"excludePackageNames"},{"location":"configuration-options/#excludepackagepatterns","text":"Package name patterns to exclude. Valid only within a packageRules object. Name Value type array subType string format regex parent packageRules mergeable true Use this field if you want to have one or more package name patterns excluded in your package rule. See also matchPackagePatterns . { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"^eslint\" ], \"excludePackagePatterns\" : [ \"^eslint-foo\" ] } ] } The above will match all package names starting with eslint but exclude ones starting with eslint-foo .","title":"excludePackagePatterns"},{"location":"configuration-options/#excludepackageprefixes","text":"Package name prefixes to exclude. Valid only within a packageRules object. Name Value type array subType string parent packageRules mergeable true Use this field if you want to have one or more package name prefixes excluded in your package rule, without needing to write a regex. See also matchPackagePrefixes . { \"packageRules\" : [ { \"matchPackagePrefixes\" : [ \"eslint\" ], \"excludePackagePrefixes\" : [ \"eslint-foo\" ] } ] } The above will match all package names starting with eslint but exclude ones starting with eslint-foo .","title":"excludePackagePrefixes"},{"location":"configuration-options/#matchlanguages","text":"List of languages to match (e.g. [\"python\"] ). Valid only within a packageRules object. Name Value type array subType string parent packageRules mergeable true Use this field to restrict rules to a particular language. e.g. { \"packageRules\" : [ { \"matchPackageNames\" : [ \"request\" ], \"matchLanguages\" : [ \"python\" ], \"enabled\" : false } ] }","title":"matchLanguages"},{"location":"configuration-options/#matchbasebranches","text":"List of strings containing exact matches (e.g. [\"main\"] ) and/or regex expressions (e.g. [\"/^release\\/.*/\"] ). Valid only within a packageRules object. Name Value type array subType string parent packageRules mergeable true Use this field to restrict rules to a particular branch. e.g. { \"packageRules\" : [ { \"matchBaseBranches\" : [ \"main\" ], \"excludePackagePatterns\" : [ \"^eslint\" ], \"enabled\" : false } ] } This field also supports Regular Expressions if they begin and end with / . e.g. { \"packageRules\" : [ { \"matchBaseBranches\" : [ \"/^release\\\\/.*/\" ], \"excludePackagePatterns\" : [ \"^eslint\" ], \"enabled\" : false } ] }","title":"matchBaseBranches"},{"location":"configuration-options/#matchmanagers","text":"List of package managers to match (e.g. [\"pipenv\"] ). Valid only within a packageRules object. Name Value type array subType string parent packageRules mergeable true Use this field to restrict rules to a particular package manager. e.g. { \"packageRules\" : [ { \"matchPackageNames\" : [ \"node\" ], \"matchManagers\" : [ \"dockerfile\" ], \"enabled\" : false } ] }","title":"matchManagers"},{"location":"configuration-options/#matchdatasources","text":"List of datasources to match (e.g. [\"orb\"] ). Valid only within a packageRules object. Name Value type array subType string parent packageRules mergeable true Use this field to restrict rules to a particular datasource. e.g. { \"packageRules\" : [ { \"matchDatasources\" : [ \"orb\" ], \"labels\" : [ \"circleci-orb!!\" ] } ] }","title":"matchDatasources"},{"location":"configuration-options/#matchcurrentversion","text":"A version or range of versions to match against the current version of a package. Valid only within a packageRules object. Name Value type string parent packageRules mergeable true default null matchCurrentVersion can be an exact SemVer version or a SemVer range: { \"packageRules\" : [ { \"matchCurrentVersion\" : \">=1.0.0\" , \"matchPackageNames\" : [ \"angular\" ] } ] } This field also supports Regular Expressions which must begin and end with / . For example, the following enforces that only 1.* versions will be used: { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"io.github.resilience4j\" ], \"matchCurrentVersion\" : \"/^1\\\\./\" } ] } This field also supports a special negated regex syntax to ignore certain versions. Use the syntax !/ / like this: { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"io.github.resilience4j\" ], \"matchCurrentVersion\" : \"!/^0\\\\./\" } ] }","title":"matchCurrentVersion"},{"location":"configuration-options/#matchfiles","text":"List of strings to do an exact match against package files with full path. Will only work inside a packageRules object. Name Value type array subType string parent packageRules Renovate will compare matchFiles for an exact match against the dependency's package file or lock file. For example the following would match package.json but not package/frontend/package.json : \"matchFiles\": [\"package.json\"], Use matchPaths instead if you need more flexible matching.","title":"matchFiles"},{"location":"configuration-options/#matchpackagenames","text":"Package names to match. Valid only within a packageRules object. Name Value type array subType string parent packageRules mergeable true Use this field if you want to have one or more exact name matches in your package rule. See also excludePackageNames . { \"packageRules\" : [ { \"matchPackageNames\" : [ \"angular\" ], \"rangeStrategy\" : \"pin\" } ] } The above will configure rangeStrategy to pin only for the package angular .","title":"matchPackageNames"},{"location":"configuration-options/#matchpackagepatterns","text":"Package name patterns to match. Valid only within a packageRules object. Name Value type array subType string format regex parent packageRules mergeable true Use this field if you want to have one or more package names patterns in your package rule. See also excludePackagePatterns . { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"^angular\" ], \"rangeStrategy\" : \"replace\" } ] } The above will configure rangeStrategy to replace for any package starting with angular .","title":"matchPackagePatterns"},{"location":"configuration-options/#matchpackageprefixes","text":"Package name prefixes to match. Valid only within a packageRules object. Name Value type array subType string parent packageRules mergeable true Use this field to match a package prefix without needing to write a regex expression. See also excludePackagePrefixes . { \"packageRules\" : [ { \"matchPackagePrefixes\" : [ \"angular\" ], \"rangeStrategy\" : \"replace\" } ] } Just like the earlier matchPackagePatterns example, the above will configure rangeStrategy to replace for any package starting with angular .","title":"matchPackagePrefixes"},{"location":"configuration-options/#matchpaths","text":"List of strings or glob patterns to match against package files. Will only work inside a packageRules object. Name Value type array subType string parent packageRules Renovate will match matchPaths against both a partial string match or a minimatch glob pattern. If you want to avoid the partial string matching so that only glob matching is performed, wrap your string in +(...) like so: \"matchPaths\": [\"+(package.json)\"], The above will match only the root package.json , whereas the following would match any package.json in any subdirectory too: \"matchPaths\": [\"package.json\"],","title":"matchPaths"},{"location":"configuration-options/#matchsourceurlprefixes","text":"A list of source URL prefixes to match against, commonly used to group monorepos or packages from the same organization. Name Value type array subType string parent packageRules mergeable true Here's an example of where you use this to group together all packages from the Vue monorepo: { \"packageRules\" : [ { \"matchSourceUrlPrefixes\" : [ \"https://github.com/vuejs/vue\" ], \"groupName\" : \"Vue monorepo packages\" } ] } Here's an example of where you use this to group together all packages from the renovatebot GitHub org: { \"packageRules\" : [ { \"matchSourceUrlPrefixes\" : [ \"https://github.com/renovatebot/\" ], \"groupName\" : \"All renovate packages\" } ] }","title":"matchSourceUrlPrefixes"},{"location":"configuration-options/#matchsourceurls","text":"A list of source URLs to exact match against. Name Value type array subType string parent packageRules mergeable true Here's an example of where you use this to match exact package urls: { \"packageRules\" : [ { \"matchSourceUrls\" : [ \"https://github.com/facebook/react\" ], \"groupName\" : \"React\" } ] }","title":"matchSourceUrls"},{"location":"configuration-options/#matchupdatetypes","text":"Update types to match against ( major , minor , pin , pinDigest , etc). Valid only within packageRules object. Name Value type array subType string allowedValues major,minor,patch,pin,pinDigest,digest,lockFileMaintenance,rollback,bump parent packageRules mergeable true Use this field to match rules against types of updates. For example to apply a special label for Major updates: { \"packageRules\" : [ { \"matchUpdateTypes\" : [ \"major\" ], \"labels\" : [ \"UPDATE-MAJOR\" ] } ] }","title":"matchUpdateTypes"},{"location":"configuration-options/#replacementname","text":"The name of the new dependency that replaces the old deprecated dependency. Name Value type string parent packageRules mergeable true default null This config option only works with the npm manager. We're working to support more managers, subscribe to issue renovatebot/renovate#14149 to follow our progress. Use this field to define the name of a replacement package. Must be used with replacementVersion (see example below). You can suggest a new community package rule by editing the replacements.ts file on the Renovate repository and opening a pull request.","title":"replacementName"},{"location":"configuration-options/#replacementversion","text":"The version of the new dependency that replaces the old deprecated dependency. Name Value type string parent packageRules mergeable true default null This config option only works with the npm manager. We're working to support more managers, subscribe to issue renovatebot/renovate#14149 to follow our progress. Use this field to define the version of a replacement package. Must be used with replacementName . For example to replace the npm package jade with version 2.0.0 of the package pug : { \"packageRules\" : [ { \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"jade\" ], \"replacementName\" : \"pug\" , \"replacementVersion\" : \"2.0.0\" } ] }","title":"replacementVersion"},{"location":"configuration-options/#patch","text":"Configuration to apply when an update type is patch . Name Value type object mergeable true env RENOVATE_PATCH Add to this object if you wish to define rules that apply only to patch updates.","title":"patch"},{"location":"configuration-options/#php","text":"Configuration object for PHP. Name Value type object mergeable true env RENOVATE_PHP","title":"php"},{"location":"configuration-options/#pin","text":"Configuration to apply when an update type is pin . Name Value type object default {\"rebaseWhen\":\"behind-base-branch\",\"groupName\":\"Pin Dependencies\",\"groupSlug\":\"pin-dependencies\",\"commitMessageAction\":\"Pin\",\"group\":{\"commitMessageTopic\":\"dependencies\",\"commitMessageExtra\":\"\"}} mergeable true env RENOVATE_PIN Add to this object if you wish to define rules that apply only to PRs that pin dependencies.","title":"pin"},{"location":"configuration-options/#pindigest","text":"Configuration to apply when pinning a digest (no change in tag/version). Name Value type object default {\"groupName\":\"Pin Dependencies\",\"groupSlug\":\"pin-dependencies\",\"commitMessageAction\":\"Pin\",\"group\":{\"commitMessageTopic\":\"dependencies\",\"commitMessageExtra\":\"\"}} mergeable true env RENOVATE_PIN_DIGEST Add to this object if you wish to define rules that apply only to PRs that pin digests.","title":"pinDigest"},{"location":"configuration-options/#pindigests","text":"Whether to add digests to Dockerfile source images. Name Value type boolean default false cli --pin-digests env RENOVATE_PIN_DIGESTS If enabled Renovate will pin Docker images by means of their SHA256 digest and not only by tag so that they are immutable.","title":"pinDigests"},{"location":"configuration-options/#platformautomerge","text":"Controls if platform-native auto-merge is used. Name Value type boolean default false cli --platform-automerge env RENOVATE_PLATFORM_AUTOMERGE If you have enabled automerge and set automergeType=pr in the Renovate config, then you can also set platformAutomerge to true to speed up merging via the platform's native automerge functionality. Renovate tries platform-native automerge only when it initially creates the PR. Any PR that is being updated will be automerged with the Renovate-based automerge. platformAutomerge will configure PRs to be merged after all (if any) branch policies have been met. This option is available for Azure, GitHub and GitLab. It falls back to Renovate-based automerge if the platform-native automerge is not available. You can also fine-tune the behavior by setting packageRules if you want to use it selectively (e.g. per-package). Note that the outcome of rebaseWhen=auto can differ when platformAutomerge=true . Normally when you set rebaseWhen=auto Renovate rebases any branch that's behind the base branch automatically, and some people rely on that. This behavior is no longer guaranteed when you enable platformAutomerge because the platform might automerge a branch which is not up-to-date. For example, GitHub might automerge a Renovate branch even if it's behind the base branch at the time.","title":"platformAutomerge"},{"location":"configuration-options/#platformcommit","text":"Use platform API to perform commits instead of using Git directly. Name Value type boolean default false supportedPlatforms github cli --platform-commit env RENOVATE_PLATFORM_COMMIT Only use this option if you run Renovate as a GitHub App . It does not apply when you use a Personal Access Token as credential. When platformCommit is enabled, Renovate will create commits with GitHub's API instead of using git directly. This way Renovate can use GitHub's Commit signing support for bots and other GitHub Apps feature.","title":"platformCommit"},{"location":"configuration-options/#postupdateoptions","text":"Enable post-update options to be run after package/artifact updating. Name Value type array allowedValues gomodMassage,gomodUpdateImportPaths,gomodTidy,gomodTidy1.17,npmDedupe,yarnDedupeFewer,yarnDedupeHighest mergeable true gomodMassage : Enable massaging replace directives before calling go commands gomodTidy : Run go mod tidy after Go module updates. This is implicitly enabled for major module updates when gomodUpdateImportPaths is enabled gomodTidy1.17 : Run go mod tidy -compat=1.17 after Go module updates. gomodUpdateImportPaths : Update source import paths on major module updates, using mod npmDedupe : Run npm dedupe after package-lock.json updates yarnDedupeFewer : Run yarn-deduplicate --strategy fewer after yarn.lock updates yarnDedupeHighest : Run yarn-deduplicate --strategy highest ( yarn dedupe --strategy highest for Yarn >=2.2.0) after yarn.lock updates","title":"postUpdateOptions"},{"location":"configuration-options/#postupgradetasks","text":"Post-upgrade tasks that are executed before a commit is made by Renovate. Name Value type object default {\"commands\":[],\"fileFilters\":[],\"executionMode\":\"update\"} cli --post-upgrade-tasks env RENOVATE_POST_UPGRADE_TASKS Note Post-upgrade tasks can only be used on self-hosted Renovate instances. Post-upgrade tasks are commands that are executed by Renovate after a dependency has been updated but before the commit is created. The intention is to run any additional command line tools that would modify existing files or generate new files when a dependency changes. Each command must match at least one of the patterns defined in allowedPostUpgradeCommands (a global-only configuration option) in order to be executed. If the list of allowed tasks is empty then no tasks will be executed. e.g. { \"postUpgradeTasks\" : { \"commands\" : [ \"tslint --fix\" ], \"fileFilters\" : [ \"yarn.lock\" , \"**/*.js\" ], \"executionMode\" : \"update\" } } The postUpgradeTasks configuration consists of three fields:","title":"postUpgradeTasks"},{"location":"configuration-options/#commands","text":"A list of post-upgrade commands that are executed before a commit is made by Renovate. Name Value type array subType string parent postUpgradeTasks env RENOVATE_COMMANDS A list of commands that are executed after Renovate has updated a dependency but before the commit is made.","title":"commands"},{"location":"configuration-options/#filefilters","text":"Files that match the glob pattern will be committed after running a post-upgrade task. Name Value type array subType string parent postUpgradeTasks env RENOVATE_FILE_FILTERS A list of glob-style matchers that determine which files will be included in the final commit made by Renovate.","title":"fileFilters"},{"location":"configuration-options/#executionmode","text":"Controls when the post upgrade tasks run: on every update, or once per upgrade branch. Name Value type string parent postUpgradeTasks allowedValues update,branch default \"update\" env RENOVATE_EXECUTION_MODE Defaults to update , but can also be set to branch . This sets the level the postUpgradeTask runs on, if set to update the postUpgradeTask will be executed for every dependency on the branch. If set to branch the postUpgradeTask is executed for the whole branch.","title":"executionMode"},{"location":"configuration-options/#prbodycolumns","text":"List of columns to use in PR bodies. Name Value type array subType string default [\"Package\",\"Type\",\"Update\",\"Change\",\"Pending\"] cli --pr-body-columns env RENOVATE_PR_BODY_COLUMNS Use this array to provide a list of column names you wish to include in the PR tables. For example, if you wish to add the package file name to the table, you would add this to your config: { \"prBodyColumns\" : [ \"Package\" , \"Update\" , \"Type\" , \"New value\" , \"Package file\" , \"References\" ] } Note \"Package file\" is predefined in the default prBodyDefinitions object so does not require a definition before it can be used.","title":"prBodyColumns"},{"location":"configuration-options/#prbodydefinitions","text":"Table column definitions for use in PR tables. Name Value type object freeChoice true mergeable true default {\"Package\":\"{{{depNameLinked}}}\",\"Type\":\"{{{depType}}}\",\"Update\":\"{{{updateType}}}\",\"Current value\":\"{{{currentValue}}}\",\"New value\":\"{{{newValue}}}\",\"Change\":\" }} -> }} \",\"Pending\":\"{{{displayPending}}}\",\"References\":\"{{{references}}}\",\"Package file\":\"{{{packageFile}}}\"} cli --pr-body-definitions env RENOVATE_PR_BODY_DEFINITIONS You can configure this object to either (a) modify the template for an existing table column in PR bodies, or (b) you wish to add a definition for a new/additional column. Here is an example of modifying the default value for the \"Package\" column to put it inside a <code></code> block: { \"prBodyDefinitions\" : { \"Package\" : \"`{{{depName}}}`\" } } Here is an example of adding a custom \"Sourcegraph\" column definition: { \"prBodyDefinitions\" : { \"Sourcegraph\" : \"[![code search for \\\"{{{depName}}}\\\"](https://sourcegraph.com/search/badge?q=repo:%5Egithub%5C.com/{{{repository}}}%24+case:yes+-file:package%28-lock%29%3F%5C.json+{{{depName}}}&label=matches)](https://sourcegraph.com/search?q=repo:%5Egithub%5C.com/{{{repository}}}%24+case:yes+-file:package%28-lock%29%3F%5C.json+{{{depName}}})\" }, \"prBodyColumns\" : [ \"Package\" , \"Update\" , \"New value\" , \"References\" , \"Sourcegraph\" ] } Tip Columns must also be included in the prBodyColumns array in order to be used, so that's why it's included above in the example.","title":"prBodyDefinitions"},{"location":"configuration-options/#prbodynotes","text":"List of additional notes/templates to be included in the Pull Request bodies. Name Value type array subType string mergeable true cli --pr-body-notes env RENOVATE_PR_BODY_NOTES Use this field to add custom content inside PR bodies, including conditionally. e.g. if you wish to add an extra Warning to major updates: { \"prBodyNotes\" : [ \"{{#if isMajor}}:warning: MAJOR MAJOR MAJOR :warning:{{/if}}\" ] }","title":"prBodyNotes"},{"location":"configuration-options/#prbodytemplate","text":"Pull Request body template. Controls which sections are rendered in the body. Name Value type string default \"{{{header}}}{{{table}}}{{{notes}}}{{{changelogs}}}{{{configDescription}}}{{{controls}}}{{{footer}}}\" env RENOVATE_PR_BODY_TEMPLATE This setting controls which sections are rendered in the body of the pull request. The available sections are header, table, notes, changelogs, configDescription, controls, footer.","title":"prBodyTemplate"},{"location":"configuration-options/#prconcurrentlimit","text":"Limit to a maximum of x concurrent branches/PRs. 0 (default) means no limit. Name Value type integer default 0 cli --pr-concurrent-limit env RENOVATE_PR_CONCURRENT_LIMIT This setting - if enabled - limits Renovate to a maximum of x concurrent PRs open at any time. This limit is enforced on a per-repository basis.","title":"prConcurrentLimit"},{"location":"configuration-options/#prcreation","text":"When to create the PR for a branch. Name Value type string allowedValues immediate,not-pending,status-success,approval default \"immediate\" cli --pr-creation env RENOVATE_PR_CREATION This setting tells Renovate when you would like it to raise PRs: immediate (default): Renovate will create PRs immediately after creating the corresponding branch not-pending : Renovate will wait until status checks have completed (passed or failed) before raising the PR status-success : Renovate won't raise PRs unless tests pass Renovate defaults to immediate but you might want to change this to not-pending instead. With prCreation set to immediate , you'll get a Pull Request and possible associated notification right away when a new update is available. Your test suite takes a bit of time to complete, so if you go look at the new PR right away, you don't know if your tests pass or fail. You're basically waiting until you have the test results, before you can decide if you want to merge the PR or not. With prCreation set to not-pending , Renovate waits until all tests have finished running, and only then creates the PR. When you get the PR notification, you can take action immediately, as you have the full test results. When you set prCreation to not-pending you're reducing the \"noise\" but get notified of new PRs a bit later.","title":"prCreation"},{"location":"configuration-options/#prfooter","text":"Text added here will be placed last in the PR body, with a divider separator before it. Name Value type string default \"This PR has been generated by [Renovate Bot](https://github.com/renovatebot/renovate).\" cli --pr-footer env RENOVATE_PR_FOOTER","title":"prFooter"},{"location":"configuration-options/#prheader","text":"Text added here will be placed first in the PR body. Name Value type string cli --pr-header env RENOVATE_PR_HEADER default null","title":"prHeader"},{"location":"configuration-options/#prhourlylimit","text":"Rate limit PRs to maximum x created per hour. 0 (default) means no limit. Name Value type integer default 0 cli --pr-hourly-limit env RENOVATE_PR_HOURLY_LIMIT This setting - if enabled - helps slow down Renovate, particularly during the onboarding phase. What may happen without this setting is: Onboarding PR is created User merges onboarding PR to activate Renovate Renovate creates a \"Pin Dependencies\" PR (if necessary) User merges Pin PR Renovate then creates every single upgrade PR necessary - potentially dozens The above can result in swamping CI systems, as well as a lot of retesting if branches need to be rebased every time one is merged. Instead, if prHourlyLimit is configure to a value like 1 or 2, it will mean that Renovate creates at most that many new PRs within each hourly period (:00-:59). So the project should still result in all PRs created perhaps within the first 24 hours maximum, but at a rate that may allow users to merge them once they pass tests. It does not place a limit on the number of concurrently open PRs - only on the rate they are created. This limit is enforced on a per-repository basis.","title":"prHourlyLimit"},{"location":"configuration-options/#prnotpendinghours","text":"Timeout in hours for when prCreation=not-pending . Name Value type integer default 25 cli --pr-not-pending-hours env RENOVATE_PR_NOT_PENDING_HOURS If you configure prCreation=not-pending , then Renovate will wait until tests are non-pending (all pass or at least one fails) before creating PRs. However there are cases where PRs may remain in pending state forever, e.g. absence of tests or status checks that are configure to pending indefinitely. This is why we configured an upper limit for how long we wait until creating a PR. Note If the option stabilityDays is non-zero then Renovate disables the prNotPendingHours functionality.","title":"prNotPendingHours"},{"location":"configuration-options/#prpriority","text":"Set sorting priority for PR creation. PRs with higher priority are created first, negative priority last. Name Value type integer default 0 Sometimes Renovate needs to rate limit its creation of PRs, e.g. hourly or concurrent PR limits. In such cases it sorts/prioritizes by default based on the update type (e.g. patches raised before minor, minor before major). If you have dependencies that are more or less important than others then you can use the prPriority field for PR sorting. The default value is 0, so setting a negative value will make dependencies sort last, while higher values sort first. Here's an example of how you would define PR priority so that devDependencies are raised last and react is raised first: { \"packageRules\" : [ { \"matchDepTypes\" : [ \"devDependencies\" ], \"prPriority\" : -1 }, { \"matchPackageNames\" : [ \"react\" ], \"prPriority\" : 5 } ] }","title":"prPriority"},{"location":"configuration-options/#prtitle","text":"Pull Request title template (deprecated). Inherits from commitMessage if null. Name Value type string env RENOVATE_PR_TITLE The PR title is important for some of Renovate's matching algorithms (e.g. determining whether to recreate a PR or not) so ideally don't modify it much.","title":"prTitle"},{"location":"configuration-options/#prunebranchafterautomerge","text":"Set to true to enable branch pruning after automerging. Name Value type boolean default true cli --prune-branch-after-automerge env RENOVATE_PRUNE_BRANCH_AFTER_AUTOMERGE By default Renovate deletes, or \"prunes\", the branch after automerging. Set pruneBranchAfterAutomerge to false to keep the branch after automerging.","title":"pruneBranchAfterAutomerge"},{"location":"configuration-options/#prunestalebranches","text":"Set to false to disable pruning stale branches. Name Value type boolean default true cli --prune-stale-branches env RENOVATE_PRUNE_STALE_BRANCHES Configure to false to disable deleting orphan branches and autoclosing PRs. Defaults to true .","title":"pruneStaleBranches"},{"location":"configuration-options/#python","text":"Configuration object for Python. Name Value type object mergeable true env RENOVATE_PYTHON Currently the only Python package manager is pip - specifically for requirements.txt and requirements.pip files - so adding any config to this python object is essentially the same as adding it to the pip_requirements object instead.","title":"python"},{"location":"configuration-options/#rangestrategy","text":"Determines how to modify or update existing ranges. Name Value type string default \"replace\" allowedValues auto,pin,bump,replace,widen,update-lockfile,in-range-only Behavior: auto = Renovate decides (this will be done on a manager-by-manager basis) pin = convert ranges to exact versions, e.g. ^1.0.0 -> 1.1.0 bump = e.g. bump the range even if the new version satisfies the existing range, e.g. ^1.0.0 -> ^1.1.0 replace = Replace the range with a newer one if the new version falls outside it, and update nothing otherwise widen = Widen the range with newer one, e.g. ^1.0.0 -> ^1.0.0 || ^2.0.0 update-lockfile = Update the lock file when in-range updates are available, otherwise replace for updates out of range. Works for bundler , composer , npm , yarn , terraform and poetry so far in-range-only = Update the lock file when in-range updates are available, ignore package file updates Renovate's \"auto\" strategy works like this for npm: Always pin devDependencies Pin dependencies if we detect that it's an app and not a library Widen peerDependencies If an existing range already ends with an \"or\" operator - e.g. \"^1.0.0 || ^2.0.0\" - then Renovate will widen it, e.g. making it into \"^1.0.0 || ^2.0.0 || ^3.0.0\" Otherwise, replace the range. e.g. \"^2.0.0\" would be replaced by \"^3.0.0\" By default, Renovate assumes that if you are using ranges then it's because you want them to be wide/open. Renovate won't deliberately \"narrow\" any range by increasing the semver value inside. For example, if your package.json specifies a value for left-pad of ^1.0.0 and the latest version on npmjs is 1.2.0 , then Renovate won't change anything because 1.2.0 satisfies the range. If instead you'd prefer to be updated to ^1.2.0 in cases like this, then configure rangeStrategy to bump in your Renovate config. This feature supports simple caret ( ^ ) and tilde ( ~ ) ranges only, like ^1.0.0 and ~1.0.0 . The in-range-only strategy may be useful if you want to leave the package file unchanged and only do update-lockfile within the existing range. The in-range-only strategy behaves like update-lockfile , but discards any updates where the new version of the dependency is not equal to the current version. We recommend you avoid using the in-range-only strategy unless you strictly need it. Using the in-range-only strategy may result in you being multiple releases behind without knowing it.","title":"rangeStrategy"},{"location":"configuration-options/#rebaselabel","text":"Label to request a rebase from Renovate bot. Name Value type string default \"rebase\" cli --rebase-label env RENOVATE_REBASE_LABEL On supported platforms it is possible to add a label to a PR to manually request Renovate to recreate/rebase it. By default this label is \"rebase\" but you can configure it to anything you want by changing this rebaseLabel field.","title":"rebaseLabel"},{"location":"configuration-options/#rebasewhen","text":"Controls when Renovate rebases an existing branch. Name Value type string allowedValues auto,never,conflicted,behind-base-branch default \"auto\" cli --rebase-when env RENOVATE_REBASE_WHEN Possible values and meanings: auto : Renovate will autodetect the best setting. It will use behind-base-branch if configured to automerge or repository has been set to require PRs to be up to date. Otherwise, conflicted will be used instead never : Renovate will never rebase the branch or update it unless manually requested conflicted : Renovate will rebase only if the branch is conflicted behind-base-branch : Renovate will rebase whenever the branch falls 1 or more commit behind its base branch rebaseWhen=conflicted is not recommended if you have enabled Renovate automerge, because: It could result in a broken base branch if two updates are merged one after another without testing the new versions together If you have enforced that PRs must be up-to-date before merging (e.g. using branch protection on GitHub), then automerge won't be possible as soon as a PR gets out-of-date but remains non-conflicted It is also recommended to avoid rebaseWhen=never as it can result in conflicted branches with outdated PR descriptions and/or status checks. Avoid setting rebaseWhen=never and then also setting prCreation=not-pending as this can prevent creation of PRs.","title":"rebaseWhen"},{"location":"configuration-options/#recreateclosed","text":"Recreate PRs even if same ones were closed previously. Name Value type boolean default false cli --recreate-closed env RENOVATE_RECREATE_CLOSED By default, Renovate will detect if it has proposed an update to a project before and not propose the same one again. For example the Webpack 3.x case described above. This field lets you customise this behavior down to a per-package level. For example we override it to true in the following cases where branch names and PR titles need to be reused: Package groups When pinning versions Lock file maintenance Typically you shouldn't need to modify this setting.","title":"recreateClosed"},{"location":"configuration-options/#regexmanagers","text":"Custom managers using regex matching. Name Value type array subType object cli --regex-managers mergeable true env RENOVATE_REGEX_MANAGERS Use regexManagers entries to configure the regex manager in Renovate. You can define custom managers for cases such as: Proprietary file formats or conventions Popular file formats not yet supported as a manager by Renovate The custom manager concept is based on using Regular Expression named capture groups. You must have a named capture group matching (e.g. (?<depName>.*) ) or configure it's corresponding template (e.g. depNameTemplate ) for these fields: datasource depName currentValue Use named capture group matching or set a corresponding template. We recommend you use only one of these methods, or you'll get confused. We recommend that you also tell Renovate what versioning to use. If the versioning field is missing, then Renovate defaults to using semver versioning. For more details and examples, see our documentation for the regex manager . For template fields, use the triple brace {{{ }}} notation to avoid Handlebars escaping any special characters.","title":"regexManagers"},{"location":"configuration-options/#matchstrings","text":"Regex capture rule to use. Valid only within a regexManagers object. Name Value type array subType string format regex parent regexManagers matchStrings should each be a valid regular expression, optionally with named capture groups. Example: { \"matchStrings\" : [ \"ENV .*?_VERSION=(?<currentValue>.*) # (?<datasource>.*?)/(?<depName>.*?)\\\\s\" ] }","title":"matchStrings"},{"location":"configuration-options/#matchstringsstrategy","text":"Strategy how to interpret matchStrings. Name Value type string default \"any\" allowedValues any,recursive,combination parent regexManagers matchStringsStrategy controls behavior when multiple matchStrings values are provided. Three options are available: any (default) recursive combination","title":"matchStringsStrategy"},{"location":"configuration-options/#any","text":"Each provided matchString will be matched individually to the content of the packageFile . If a matchString has multiple matches in a file each will be interpreted as an independent dependency. As example the following configuration will update all 3 lines in the Dockerfile. renovate.json: { \"regexManagers\" : [ { \"fileMatch\" : [ \"^Dockerfile$\" ], \"matchStringsStrategy\" : \"any\" , \"matchStrings\" : [ \"ENV [A-Z]+_VERSION=(?<currentValue>.*) # (?<datasource>.*?)/(?<depName>.*?)(\\\\&versioning=(?<versioning>.*?))?\\\\s\" , \"FROM (?<depName>\\\\S*):(?<currentValue>\\\\S*)\" ], \"datasourceTemplate\" : \"docker\" } ] } a Dockerfile: FROM amd64/ubuntu:18.04 ENV GRADLE_VERSION = 6 .2 # gradle-version/gradle & versioning = maven ENV NODE_VERSION = 10 .19.0 # github-tags/nodejs/node & versioning = node","title":"any"},{"location":"configuration-options/#recursive","text":"If using recursive the matchStrings will be looped through and the full match of the last will define the range of the next one. This can be used to narrow down the search area to prevent multiple matches. But the recursive strategy still allows the matching of multiple dependencies as described below. All matches of the first matchStrings pattern are detected, then each of these matches will used as basis be used as the input for the next matchStrings pattern, and so on. If the next matchStrings pattern has multiple matches then it will split again. This process will be followed as long there is a match plus a next matchingStrings pattern is available or a dependency is detected. Matched groups will be available in subsequent matching layers. This is an example how this can work. The first regex manager will only upgrade grafana/loki as looks for the backup key then looks for the test key and then uses this result for extraction of necessary attributes. But the second regex manager will upgrade both definitions as its first matchStrings matches both test keys. renovate.json: { \"regexManagers\" : [ { \"fileMatch\" : [ \"^example.json$\" ], \"matchStringsStrategy\" : \"recursive\" , \"matchStrings\" : [ \"\\\"backup\\\":\\\\s*{[^}]*}\" , \"\\\"test\\\":\\\\s*\\\\{[^}]*}\" , \"\\\"name\\\":\\\\s*\\\"(?<depName>.*)\\\"[^\\\"]*\\\"type\\\":\\\\s*\\\"(?<datasource>.*)\\\"[^\\\"]*\\\"value\\\":\\\\s*\\\"(?<currentValue>.*)\\\"\" ], \"datasourceTemplate\" : \"docker\" }, { \"fileMatch\" : [ \"^example.json$\" ], \"matchStringsStrategy\" : \"recursive\" , \"matchStrings\" : [ \"\\\"test\\\":\\\\s*\\\\{[^}]*}\" , \"\\\"name\\\":\\\\s*\\\"(?<depName>.*)\\\"[^\\\"]*\\\"type\\\":\\\\s*\\\"(?<datasource>.*)\\\"[^\\\"]*\\\"value\\\":\\\\s*\\\"(?<currentValue>.*)\\\"\" ], \"datasourceTemplate\" : \"docker\" } ] } example.json: { \"backup\" : { \"test\" : { \"name\" : \"grafana/loki\" , \"type\" : \"docker\" , \"value\" : \"1.6.1\" } }, \"setup\" : { \"test\" : { \"name\" : \"python\" , \"type\" : \"docker\" , \"value\" : \"3.9.0\" } } }","title":"recursive"},{"location":"configuration-options/#combination","text":"This option allows the possibility to combine the values of multiple lines inside a file. While using multiple lines is also possible using both other matchStringStrategy values, the combination approach is less susceptible to white space or line breaks stopping a match. combination will only match at most one dependency per file, so if you want to update multiple dependencies using combination you have to define multiple regex managers. Matched group values will be merged to form a single dependency. renovate.json: { \"regexManagers\" : [ { \"fileMatch\" : [ \"^main.yml$\" ], \"matchStringsStrategy\" : \"combination\" , \"matchStrings\" : [ \"prometheus_image:\\\\s*\\\"(?<depName>.*)\\\"\\\\s*//\" , \"prometheus_version:\\\\s*\\\"(?<currentValue>.*)\\\"\\\\s*//\" ], \"datasourceTemplate\" : \"docker\" }, { \"fileMatch\" : [ \"^main.yml$\" ], \"matchStringsStrategy\" : \"combination\" , \"matchStrings\" : [ \"thanos_image:\\\\s*\\\"(?<depName>.*)\\\"\\\\s*//\" , \"thanos_version:\\\\s*\\\"(?<currentValue>.*)\\\"\\\\s*//\" ], \"datasourceTemplate\" : \"docker\" } ] } Ansible variable file ( yaml ): prometheus_image : \"prom/prometheus\" // a comment prometheus_version : \"v2.21.0\" // a comment ------ thanos_image : \"prom/prometheus\" // a comment thanos_version : \"0.15.0\" // a comment In the above example, each regex manager will match a single dependency each.","title":"combination"},{"location":"configuration-options/#depnametemplate","text":"Optional depName for extracted dependencies. Valid only within a regexManagers object. Name Value type string parent regexManagers default null If depName cannot be captured with a named capture group in matchString then it can be defined manually using this field. It will be compiled using Handlebars and the regex groups result.","title":"depNameTemplate"},{"location":"configuration-options/#extractversiontemplate","text":"Optional extractVersion for extracted dependencies. Valid only within a regexManagers object. Name Value type string parent regexManagers default null If extractVersion cannot be captured with a named capture group in matchString then it can be defined manually using this field. It will be compiled using Handlebars and the regex groups result.","title":"extractVersionTemplate"},{"location":"configuration-options/#packagenametemplate","text":"Optional packageName for extracted dependencies, else defaults to depName value. Valid only within a regexManagers object. Name Value type string parent regexManagers default null packageName is used for looking up dependency versions. It will be compiled using Handlebars and the regex groups result. It will default to the value of depName if left unconfigured/undefined.","title":"packageNameTemplate"},{"location":"configuration-options/#currentvaluetemplate","text":"Optional currentValue for extracted dependencies. Valid only within a regexManagers object. Name Value type string parent regexManagers default null If the currentValue for a dependency is not captured with a named group then it can be defined in config using this field. It will be compiled using Handlebars and the regex groups result.","title":"currentValueTemplate"},{"location":"configuration-options/#datasourcetemplate","text":"Optional datasource for extracted dependencies. Valid only within a regexManagers object. Name Value type string parent regexManagers default null If the datasource for a dependency is not captured with a named group then it can be defined in config using this field. It will be compiled using Handlebars and the regex groups result.","title":"datasourceTemplate"},{"location":"configuration-options/#deptypetemplate","text":"Optional depType for extracted dependencies. Valid only within a regexManagers object. Name Value type string parent regexManagers default null If depType cannot be captured with a named capture group in matchString then it can be defined manually using this field. It will be compiled using Handlebars and the regex groups result.","title":"depTypeTemplate"},{"location":"configuration-options/#versioningtemplate","text":"Optional versioning for extracted dependencies. Valid only within a regexManagers object. Name Value type string parent regexManagers default null If the versioning for a dependency is not captured with a named group then it can be defined in config using this field. It will be compiled using Handlebars and the regex groups result.","title":"versioningTemplate"},{"location":"configuration-options/#registryurltemplate","text":"Optional registry URL for extracted dependencies. Valid only within a regexManagers object. Name Value type string parent regexManagers default null If the registryUrls for a dependency is not captured with a named group then it can be defined in config using this field. It will be compiled using Handlebars and the regex groups result.","title":"registryUrlTemplate"},{"location":"configuration-options/#autoreplacestringtemplate","text":"Optional extractVersion for extracted dependencies. Valid only within a regexManagers object. Name Value type string parent regexManagers default null Allows overwriting how the matched string is replaced. This allows for some migration strategies. E.g. moving from one Docker image repository to another one. helm-values.yaml: # The image of the service <registry>/<repo>/<image>:<tag> image : my.old.registry/aRepository/andImage:1.18-alpine regex definition: { \"regexManagers\" : [ { \"fileMatch\" : [ \"values.yaml$\" ], \"matchStrings\" : [ \"image:\\\\s+(?<depName>my\\\\.old\\\\.registry\\\\/aRepository\\\\/andImage):(?<currentValue>[^\\\\s]+)\" ], \"depNameTemplate\" : \"my.new.registry/aRepository/andImage\" , \"autoReplaceStringTemplate\" : \"image: {{{depName}}}:{{{newValue}}}\" , \"datasourceTemplate\" : \"docker\" } ] } This will lead to following update where 1.21-alpine is the newest version of my.new.registry/aRepository/andImage : # The image of the service <registry>/<repo>/<image>:<tag> image : my.new.registry/aRepository/andImage:1.21-alpine","title":"autoReplaceStringTemplate"},{"location":"configuration-options/#registryurls","text":"List of URLs to try for dependency lookup. Package manager specific. Name Value type array subType string Usually Renovate is able to either (a) use the default registries for a datasource, or (b) automatically detect during the manager extract phase which custom registries are in use. In case there is a need to configure them manually, it can be done using this registryUrls field, typically using packageRules like so: { \"packageRules\" : [ { \"matchDatasources\" : [ \"docker\" ], \"registryUrls\" : [ \"https://docker.mycompany.domain\" ] } ] } The field supports multiple URLs but it is datasource-dependent on whether only the first is used or multiple.","title":"registryUrls"},{"location":"configuration-options/#replacement","text":"Configuration to apply when replacing a dependency. Name Value type object default {\"branchTopic\":\"{{{depNameSanitized}}}-replacement\",\"commitMessageAction\":\"Replace\",\"commitMessageExtra\":\"with {{newName}} {{#if isMajor}}v{{{newMajor}}}{{else}}{{#if isSingleVersion}}v{{{newVersion}}}{{else}}{{{newValue}}}{{/if}}{{/if}}\",\"prBodyNotes\":[\"This is a special PR that replaces }} with the community suggested minimal stable replacement version.\"]} mergeable true env RENOVATE_REPLACEMENT Add to this object if you wish to define rules that apply only to PRs that replace dependencies.","title":"replacement"},{"location":"configuration-options/#respectlatest","text":"Ignore versions newer than npm \"latest\" version. Name Value type boolean cli --respect-latest env RENOVATE_RESPECT_LATEST default true Similar to ignoreUnstable , this option controls whether to update to versions that are greater than the version tagged as latest in the repository. By default, renovate will update to a version greater than latest only if the current version is itself past latest.","title":"respectLatest"},{"location":"configuration-options/#reviewers","text":"Requested reviewers for Pull Requests (either username or email address depending on the platform). Name Value type array subType string cli --reviewers env RENOVATE_REVIEWERS Must be valid usernames. If on GitHub and assigning a team to review, you must use the prefix team: and add the last part of the team name. Say the full team name on GitHub is @organization/foo , then you'd set the config option like this: { \"reviewers\" : [ \"team:foo\" ] }","title":"reviewers"},{"location":"configuration-options/#reviewersfromcodeowners","text":"Determine reviewers based on configured code owners and changes in PR. Name Value type boolean default false cli --reviewers-from-code-owners env RENOVATE_REVIEWERS_FROM_CODE_OWNERS If enabled Renovate tries to determine PR reviewers by matching rules defined in a CODEOWNERS file against the changes in the PR. See GitHub or GitLab documentation for details on syntax and possible file locations.","title":"reviewersFromCodeOwners"},{"location":"configuration-options/#reviewerssamplesize","text":"Take a random sample of given size from reviewers. Name Value type integer cli --reviewers-sample-size env RENOVATE_REVIEWERS_SAMPLE_SIZE","title":"reviewersSampleSize"},{"location":"configuration-options/#rollback","text":"Configuration to apply when rolling back a version. Name Value type object default {\"branchTopic\":\"{{{depNameSanitized}}}-rollback\",\"commitMessageAction\":\"Roll back\",\"semanticCommitType\":\"fix\"} mergeable true env RENOVATE_ROLLBACK Add to this object if you wish to define rules that apply only to PRs that roll back versions.","title":"rollback"},{"location":"configuration-options/#rollbackprs","text":"Create PRs to roll back versions if the current version is not found in the registry. Name Value type boolean default false cli --rollback-prs env RENOVATE_ROLLBACK_PRS There are times when a dependency version in use by a project gets removed from the registry. For some registries, existing releases or even whole packages can be removed or \"yanked\" at any time, while for some registries only very new or unused releases can be removed. Renovate's \"rollback\" feature exists to propose a downgrade to the next-highest release if the current release is no longer found in the registry. Renovate does not create these rollback PRs by default, with one exception: npm packages get a rollback PR if needed. You can configure the rollbackPrs property globally, per-language, or per-package to override the default behavior.","title":"rollbackPrs"},{"location":"configuration-options/#ruby","text":"Configuration object for Ruby language. Name Value type object mergeable true env RENOVATE_RUBY","title":"ruby"},{"location":"configuration-options/#rust","text":"Configuration option for Rust package management. Name Value type object mergeable true env RENOVATE_RUST","title":"rust"},{"location":"configuration-options/#schedule","text":"Limit branch creation to these times of day or week. Name Value type array subType string cli --schedule default [\"at any time\"] The schedule option allows you to define times of week or month for Renovate updates. Running Renovate around the clock can be too \"noisy\" for some projects. To reduce the noise you can use the schedule config option to limit the time frame in which Renovate will perform actions on your repository. You can use the standard Cron syntax and Later syntax to define your schedule. The default value for schedule is \"at any time\", which is functionally the same as declaring a null schedule. i.e. Renovate will run on the repository around the clock. The easiest way to define a schedule is to use a preset if one of them fits your requirements. See Schedule presets for details and feel free to request a new one in the source repository if you think others would benefit from it too. Otherwise, here are some text schedules that are known to work: every weekend before 5:00am after 10pm and before 5:00am after 10pm and before 5am every weekday on friday and saturday every 3 months on the first day of the month * 0 2 * * Warning For Cron schedules, you must use the * wildcard for the minutes value, as Renovate doesn't support minute granularity. One example might be that you don't want Renovate to run during your typical business hours, so that your build machines don't get clogged up testing package.json updates. You could then configure a schedule like this at the repository level: { \"schedule\" : [ \"after 10pm and before 5am every weekday\" , \"every weekend\" ] } This would mean that Renovate can run for 7 hours each night plus all the time on weekends. This scheduling feature can also be particularly useful for \"noisy\" packages that are updated frequently, such as aws-sdk . To restrict aws-sdk to only monthly updates, you could add this package rule: { \"packageRules\" : [ { \"matchPackageNames\" : [ \"aws-sdk\" ], \"extends\" : [ \"schedule:monthly\" ] } ] } Technical details: We mostly rely on the text parsing of the library @breejs/later but only its concepts of \"days\", \"time_before\", and \"time_after\". Read the parser documentation at breejs.github.io/later/parsers.html#text . To parse Cron syntax, Renovate uses @cheap-glitch/mi-cron . Renovate does not support scheduled minutes or \"at an exact time\" granularity. Note Actions triggered via the Dependency Dashboard are not restricted by a configured schedule.","title":"schedule"},{"location":"configuration-options/#semanticcommitscope","text":"Commit scope to use if Semantic Commits are enabled. Name Value type string default \"deps\" cli --semantic-commit-scope env RENOVATE_SEMANTIC_COMMIT_SCOPE By default you will see Angular-style commit prefixes like \"chore(deps):\" . If you wish to change it to something else like \"package\" then it will look like \"chore(package):\" . You can also use parentDir or baseDir to namespace your commits for monorepos e.g. \"{{parentDir}}\" .","title":"semanticCommitScope"},{"location":"configuration-options/#semanticcommittype","text":"Commit type to use if Semantic Commits is enabled. Name Value type string default \"chore\" cli --semantic-commit-type env RENOVATE_SEMANTIC_COMMIT_TYPE By default you will see Angular-style commit prefixes like \"chore(deps):\" . If you wish to change it to something else like \"ci\" then it will look like \"ci(deps):\" .","title":"semanticCommitType"},{"location":"configuration-options/#semanticcommits","text":"Enable Semantic Commit prefixes for commits and PR titles. Name Value type string allowedValues auto,enabled,disabled default \"auto\" cli --semantic-commits env RENOVATE_SEMANTIC_COMMITS If you are using a semantic prefix for your commits, then you will want to enable this setting. Although it's configurable to a package-level, it makes most sense to configure it at a repository level. If configured to enabled , then the semanticCommitScope and semanticCommitType fields will be used for each commit message and PR title. Renovate autodetects if your repository is already using semantic commits or not and follows suit, so you only need to configure this if you wish to override Renovate's autodetected setting.","title":"semanticCommits"},{"location":"configuration-options/#separatemajorminor","text":"If set to false , Renovate will upgrade dependencies to their latest release only. Renovate will not separate major or minor branches. Name Value type boolean cli --separate-major-minor env RENOVATE_SEPARATE_MAJOR_MINOR default true Renovate's default behavior is to create a separate branch/PR if both minor and major version updates exist (note that your choice of rangeStrategy value can influence which updates exist in the first place however). For example, if you were using Webpack 2.0.0 and versions 2.1.0 and 3.0.0 were both available, then Renovate would create two PRs so that you have the choice whether to apply the minor update to 2.x or the major update of 3.x. If you were to apply the minor update then Renovate would keep updating the 3.x branch for you as well, e.g. if Webpack 3.0.1 or 3.1.0 were released. If instead you applied the 3.0.0 update then Renovate would clean up the unneeded 2.x branch for you on the next run. It is recommended that you leave this option to true , because of the polite way that Renovate handles this. For example, let's say in the above example that you decided you wouldn't update to Webpack 3 for a long time and don't want to build/test every time a new 3.x version arrives. In that case, simply close the \"Update Webpack to version 3.x\" PR and it won't be recreated again even if subsequent Webpack 3.x versions are released. You can continue with Webpack 2.x for as long as you want and get any updates/patches that are made for it. Then eventually when you do want to update to Webpack 3.x you can make that update to package.json yourself and commit it to the base branch once it's tested. After that, Renovate will resume providing you updates to 3.x again! i.e. if you close a major upgrade PR then it won't come back again, but once you make the major upgrade yourself then Renovate will resume providing you with minor or patch updates. This option also has priority over package groups configured by packageRule . So Renovate will propose separate PRs for major and minor updates of packages even if they are grouped. If you want to enforce grouped package updates, you need to set this option to false within the packageRule .","title":"separateMajorMinor"},{"location":"configuration-options/#separateminorpatch","text":"If set to true , Renovate will separate minor and patch updates into separate branches. Name Value type boolean default false cli --separate-minor-patch env RENOVATE_SEPARATE_MINOR_PATCH By default, Renovate won't distinguish between \"patch\" (e.g. 1.0.x) and \"minor\" (e.g. 1.x.0) releases - it groups them together. E.g., if you are running version 1.0.0 of a package and both versions 1.0.1 and 1.1.0 are available then Renovate will raise a single PR for version 1.1.0. If you wish to distinguish between patch and minor upgrades, for example if you wish to automerge patch but not minor, then you can configured this option to true .","title":"separateMinorPatch"},{"location":"configuration-options/#separatemultiplemajor","text":"If set to true , PRs will be raised separately for each available major upgrade version. Name Value type boolean default false cli --separate-multiple-major env RENOVATE_SEPARATE_MULTIPLE_MAJOR Configure this to true if you wish to get one PR for every separate major version upgrade of a dependency. e.g. if you are on webpack@v1 currently then default behavior is a PR for upgrading to webpack@v3 and not for webpack@v2. If this setting is true then you would get one PR for webpack@v2 and one for webpack@v3.","title":"separateMultipleMajor"},{"location":"configuration-options/#stabilitydays","text":"Number of days required before a new release is considered stable. Name Value type integer default 0 cli --stability-days env RENOVATE_STABILITY_DAYS If this is set to a non-zero value, and an update has a release timestamp header, then Renovate will check if the \"stability days\" have passed. Note: Renovate will wait for the set number of stabilityDays to pass for each separate version. Renovate does not wait until the package has seen no releases for x stabilityDays . stabilityDays is not intended to help with slowing down fast releasing project updates. If you want to slow down PRs for a specific package, setup a custom schedule for that package. Read our selective-scheduling help to learn how to set the schedule. If the number of days since the release is less than the set stabilityDays a \"pending\" status check is added to the branch. If enough days have passed then the \"pending\" status is removed, and a \"passing\" status check is added. Some datasources do not provide a release timestamp (in which case this feature is not compatible), and other datasources may provide a release timestamp but it's not supported by Renovate (in which case a feature request needs to be implemented). Maven users: you cannot use stabilityDays if a Maven source returns unreliable last-modified headers. There are a couple of uses for stabilityDays :","title":"stabilityDays"},{"location":"configuration-options/#suppress-branchpr-creation-for-x-days","text":"If you combine stabilityDays=3 and prCreation=\"not-pending\" then Renovate will hold back from creating branches until 3 or more days have elapsed since the version was released. It's recommended that you enable dependencyDashboard=true so you don't lose visibility of these pending PRs.","title":"Suppress branch/PR creation for X days"},{"location":"configuration-options/#prevent-holding-broken-npm-packages","text":"npm packages less than 72 hours (3 days) old can be unpublished, which could result in a service impact if you have already updated to it. Set stabilityDays to 3 for npm packages to prevent relying on a package that can be removed from the registry: { \"packageRules\" : [ { \"matchDatasources\" : [ \"npm\" ], \"stabilityDays\" : 3 } ] }","title":"Prevent holding broken npm packages"},{"location":"configuration-options/#await-x-days-before-automerging","text":"If you have both automerge as well as stabilityDays enabled, it means that PRs will be created immediately but automerging will be delayed until X days have passed. This works because Renovate will add a \"renovate/stability-days\" pending status check to each branch/PR and that pending check will prevent the branch going green to automerge.","title":"Await X days before Automerging"},{"location":"configuration-options/#stopupdatinglabel","text":"Label to make Renovate stop updating a PR. Name Value type string default \"stop-updating\" supportedPlatforms azure,github,gitlab,gitea cli --stop-updating-label env RENOVATE_STOP_UPDATING_LABEL On supported platforms it is possible to add a label to a PR to request Renovate stop updating the PR. By default this label is \"stop-updating\" but you can configure it to anything you want by changing this stopUpdatingLabel field.","title":"stopUpdatingLabel"},{"location":"configuration-options/#suppressnotifications","text":"Options to suppress various types of warnings and other notifications. Name Value type array subType string default [\"deprecationWarningIssues\"] allowedValues prIgnoreNotification,branchAutomergeFailure,lockFileErrors,artifactErrors,deprecationWarningIssues,onboardingClose,configErrorIssue mergeable true Use this field to suppress various types of warnings and other notifications from Renovate. Example: { \"suppressNotifications\" : [ \"prIgnoreNotification\" ] } The above config will suppress the comment which is added to a PR whenever you close a PR unmerged.","title":"suppressNotifications"},{"location":"configuration-options/#timezone","text":"IANA Time Zone Name Value type string cli --timezone env RENOVATE_TIMEZONE default null It is only recommended to configure this field if you wish to use the schedules feature and want to write them in your local timezone. Please see the above link for valid timezone names.","title":"timezone"},{"location":"configuration-options/#transitiveremediation","text":"Enable remediation of transitive dependencies. Name Value type boolean default false supportedManagers npm supportedPlatforms github cli --transitive-remediation env RENOVATE_TRANSITIVE_REMEDIATION When enabled, Renovate tries to remediate vulnerabilities even if they exist only in transitive dependencies. Applicable only for GitHub platform (with vulnerability alerts enabled) and npm manager. When the lockfileVersion is higher than 1 in package-lock.json , remediations are only possible when changes are made to package.json . This is considered a feature flag with the aim to remove it and default to this behavior once it has been more widely tested.","title":"transitiveRemediation"},{"location":"configuration-options/#updateinternaldeps","text":"Whether to update internal dep versions in a monorepo. Works on Lerna or Yarn Workspaces. Name Value type boolean default false cli --update-internal-deps env RENOVATE_UPDATE_INTERNAL_DEPS Renovate defaults to skipping any internal package dependencies within monorepos. In such case dependency versions won't be updated by Renovate. To opt in to letting Renovate update internal package versions normally, set this configuration option to true.","title":"updateInternalDeps"},{"location":"configuration-options/#updatelockfiles","text":"Set to false to disable lock file updating. Name Value type boolean cli --update-lock-files env RENOVATE_UPDATE_LOCK_FILES default true","title":"updateLockFiles"},{"location":"configuration-options/#updatenotscheduled","text":"Whether to update branches when not scheduled. Renovate will not create branches outside of the schedule. Name Value type boolean cli --update-not-scheduled env RENOVATE_UPDATE_NOT_SCHEDULED default true When schedules are in use, it generally means \"no updates\". However there are cases where updates might be desirable - e.g. if you have configured prCreation=not-pending , or you have rebaseWhen=behind-base-branch and the base branch is updated so you want Renovate PRs to be rebased. This defaults to true , meaning that Renovate will perform certain \"desirable\" updates to existing PRs even when outside of schedule. If you wish to disable all updates outside of scheduled hours then configure this field to false .","title":"updateNotScheduled"},{"location":"configuration-options/#updatepinneddependencies","text":"Whether to update pinned (single version) dependencies or not. Name Value type boolean default true cli --update-pinned-dependencies env RENOVATE_UPDATE_PINNED_DEPENDENCIES By default, Renovate will try to update all detected dependencies, regardless of whether they are defined using pinned single versions (e.g. 1.2.3 ) or constraints/ranges (e.g. ( ^1.2.3 ). You can set this option to false if you wish to disable updating for pinned (single version) dependencies specifically.","title":"updatePinnedDependencies"},{"location":"configuration-options/#usebasebranchconfig","text":"Whether to read configuration from baseBranches instead of only the default branch. Name Value type string allowedValues merge,none default \"none\" cli --use-base-branch-config env RENOVATE_USE_BASE_BRANCH_CONFIG By default, Renovate will read config file from the default branch only and will ignore any config files in base branches. You can configure useBaseBranchConfig=merge to instruct Renovate to merge the config from each base branch over the top of the config in the default branch. The config file name in the base branch must be the same as in the default branch and cannot be package.json . This scenario may be useful for testing the config changes in base branches instantly.","title":"useBaseBranchConfig"},{"location":"configuration-options/#userstrings","text":"User-facing strings for the Renovate comment when a PR is closed. Name Value type object freeChoice true default {\"ignoreTopic\":\"Renovate Ignore Notification\",\"ignoreMajor\":\"As this PR has been closed unmerged, Renovate will ignore this upgrade and you will not receive PRs for *any* future {{{newMajor}}}.x releases. However, if you upgrade to {{{newMajor}}}.x manually then Renovate will reenable minor and patch updates automatically.\",\"ignoreDigest\":\"As this PR has been closed unmerged, Renovate will ignore this upgrade and you will not receive PRs for the }} }} update again.\",\"ignoreOther\":\"As this PR has been closed unmerged, Renovate will now ignore this update ({{{newValue}}}). You will still receive a PR once a newer version is released, so if you wish to permanently ignore this dependency, please add it to the ignoreDeps array of your renovate config.\"} cli --user-strings env RENOVATE_USER_STRINGS When a PR is closed, Renovate posts a comment to let users know that future updates will be ignored. If you want, you can change the text in the comment with the userStrings config option. You can edit these user-facing strings: ignoreDigest : Text of the PR comment for digest upgrades. ignoreMajor : Text of the PR comment for major upgrades. ignoreOther : Text of the PR comment for other (neither digest nor major) upgrades. ignoreTopic : Topic of the PR comment. Example: { \"userStrings\" : { \"ignoreTopic\" : \"Custom topic for PR comment\" , \"ignoreMajor\" : \"Custom text for major upgrades.\" , \"ignoreDigest\" : \"Custom text for digest upgrades.\" , \"ignoreOther\" : \"Custom text for other upgrades.\" } }","title":"userStrings"},{"location":"configuration-options/#versioning","text":"Versioning to use for filtering and comparisons. Name Value type string allowedValues aws-machine-image,cargo,composer,conan,debian,docker,git,gradle,hashicorp,helm,hex,ivy,loose,maven,node,npm,nuget,pep440,poetry,regex,rez,ruby,semver,semver-coerced,swift,ubuntu default null Usually, each language or package manager has a specific type of \"versioning\": JavaScript uses npm's SemVer implementation, Python uses pep440, etc. Renovate also uses custom versioning, like \"docker\" to address the most common way people tag versions using Docker, and \"loose\" as a fallback that tries SemVer first but otherwise just does its best to sort and compare. By exposing versioning to config, you can override the default versioning for a package manager if needed. We do not recommend overriding the default versioning, but there are some cases such as Docker or Gradle where versioning is not strictly defined and you may need to specify the versioning type per-package. Renovate supports 4-part versions (1.2.3.4) in full for the NuGet package manager. Other managers can use the \"loose\" versioning fallback: the first 3 parts are used as the version, all trailing parts are used for alphanumeric sorting.","title":"versioning"},{"location":"configuration-options/#vulnerabilityalerts","text":"Config to apply when a PR is needed due to a vulnerability in the existing package version. Name Value type object default {\"groupName\":null,\"schedule\":[],\"dependencyDashboardApproval\":false,\"rangeStrategy\":\"update-lockfile\",\"commitMessageSuffix\":\"[SECURITY]\",\"branchTopic\":\"{{{datasource}}}-{{{depName}}}-vulnerability\",\"prCreation\":\"immediate\"} mergeable true supportedPlatforms github Renovate can read from GitHub's Vulnerability Alerts and customize Pull Requests accordingly. For this to work, you must first ensure you have enabled \" Dependency graph \" and \" Dependabot alerts \" under the \"Security & analysis\" section of the repository's \"Settings\" tab. Additionally, if you are running Renovate in app mode then you must make sure that the app has been granted the permissions to read \"Vulnerability alerts\". If you are the account admin, browse to the app (e.g. https://github.com/apps/renovate ), select \"Configure\", and then scroll down to the \"Permissions\" section and verify that read access to \"vulnerability alerts\" is mentioned. Once the above conditions are met, and you got one or more vulnerability alerts from GitHub for this repository, then Renovate tries to raise fix PRs accordingly. Use the vulnerabilityAlerts configuration object if you want to customise vulnerability-fix PRs specifically. For example, to configure custom labels and assignees: { \"vulnerabilityAlerts\" : { \"labels\" : [ \"security\" ], \"automerge\" : true , \"assignees\" : [ \"@rarkins\" ] } } Warning There's a small chance that an incorrect vulnerability alert could result in flapping/looping vulnerability fixes, so observe carefully if enabling automerge . To disable the vulnerability alerts functionality completely, configure like this: { \"vulnerabilityAlerts\" : { \"enabled\" : false } }","title":"vulnerabilityAlerts"},{"location":"configuration-templates/","text":"Config Template Editing \u00b6 This document describes how you can edit branch names, commit messages, PR titles and PR content. Branch Name \u00b6 The branch name is very important for Renovate because it helps determine \"grouping\" of updates, and also makes it efficient when an existing PR needs to be updated when a newer version of a package is released. If you change the branchPrefix while you have ignored some upgrades (closed PR without merging), you might get a duplicate PR after the new branchPrefix setting is picked up by the bot. branchName default value is {{{branchPrefix}}}{{{additionalBranchPrefix}}}{{{branchTopic}}} . The most common branch name you will see looks like this: renovate/react-17.x . In this example, the branchPrefix is the default renovate/ , additionalBranchPrefix is empty, and branchTopic is react-17.x . Most users will be happy with the default branchPrefix of renovate/ , but you can change this if you don't like the default. Say you don't want the forward slashes, in that case you would use renovate- as your branchPrefix . The onboarding PR will always use renovate/configure . additionalBranchPrefix is optional and by default is empty. branchTopic depends on the package manager and upgrade type, so you will see a lot of variety. This is probably a setting you want to change yourself. Be careful, and consider creating a new \"config help\" post at the discussions tab in the Renovate repository to get help from the Renovate team with your config. Commit Message \u00b6 Renovate will use one commit per branch, this makes it easy for you to merge. The commitMessage reflects the contents of the branch and is usually the same as the PR title. commitMessage has a default value of {{commitMessagePrefix}} {{commitMessageAction}} {{commitMessageTopic}} {{commitMessageExtra}} {{commitMessageSuffix}} , with the intention that you only edit some of those subcomponents. You usually don't need to edit commitMessagePrefix , this option is used by Renovate if it needs to add a prefix to conform to the Semantic Commit convention. Do not touch this unless you know what you're doing. commitMessageAction is usually just one word, e.g. 'Update', 'Pin', 'Refresh', etc. You're probably fine leaving this setting alone, though you can change it. e.g. if you prefer that Renovate uses the term 'Upgrade' instead of 'Update' then you could configure \"commitMessageAction\": \"Upgrade\" . commitMessageTopic is usually two to three words that show what is being updated. e.g. it might be dependency react or Docker image ubuntu . You may want to edit this. If you think your new commitMessageTopic is helpful for others, please open a PR . commitMessageExtra refers to the version being updated to. e.g. to v17 for a major upgrade, or to v17.0.2 for a patch update. It can be empty in some cases, like if the action/topic doesn't change a package version, e.g. Pin Docker digests . commitMessageSuffix defaults to empty but is currently used in two cases: Differentiating major from non-major groups Differentiating between PRs from different base branches, maybe for major updates you always want the PR to end with (MAJOR) , for instance commitBody is used if you wish to add multi-line commit messages, such as for the Signed-off-by fields, or adding [skip-ci] , etc. It is appended to the generated commitMessage , separated by a newline. PR Title \u00b6 Because commit messages match with the PR title, the PR title template defaults to null and inherits/copies the value from commitMessage . If you have a requirement where prTitle should be different from commitMessage , then please raise a feature request for discussion. PR Body \u00b6 You can change the PR body in the following ways: Change the entire layout/flow by using prBodyTemplate (we do not recommend this) Add a header by using prHeader Add a footer by using prFooter Add a note by using prBodyNotes Edit the embedded table by using prBodyDefinitions and prBodyColumns","title":"Config Template Editing"},{"location":"configuration-templates/#config-template-editing","text":"This document describes how you can edit branch names, commit messages, PR titles and PR content.","title":"Config Template Editing"},{"location":"configuration-templates/#branch-name","text":"The branch name is very important for Renovate because it helps determine \"grouping\" of updates, and also makes it efficient when an existing PR needs to be updated when a newer version of a package is released. If you change the branchPrefix while you have ignored some upgrades (closed PR without merging), you might get a duplicate PR after the new branchPrefix setting is picked up by the bot. branchName default value is {{{branchPrefix}}}{{{additionalBranchPrefix}}}{{{branchTopic}}} . The most common branch name you will see looks like this: renovate/react-17.x . In this example, the branchPrefix is the default renovate/ , additionalBranchPrefix is empty, and branchTopic is react-17.x . Most users will be happy with the default branchPrefix of renovate/ , but you can change this if you don't like the default. Say you don't want the forward slashes, in that case you would use renovate- as your branchPrefix . The onboarding PR will always use renovate/configure . additionalBranchPrefix is optional and by default is empty. branchTopic depends on the package manager and upgrade type, so you will see a lot of variety. This is probably a setting you want to change yourself. Be careful, and consider creating a new \"config help\" post at the discussions tab in the Renovate repository to get help from the Renovate team with your config.","title":"Branch Name"},{"location":"configuration-templates/#commit-message","text":"Renovate will use one commit per branch, this makes it easy for you to merge. The commitMessage reflects the contents of the branch and is usually the same as the PR title. commitMessage has a default value of {{commitMessagePrefix}} {{commitMessageAction}} {{commitMessageTopic}} {{commitMessageExtra}} {{commitMessageSuffix}} , with the intention that you only edit some of those subcomponents. You usually don't need to edit commitMessagePrefix , this option is used by Renovate if it needs to add a prefix to conform to the Semantic Commit convention. Do not touch this unless you know what you're doing. commitMessageAction is usually just one word, e.g. 'Update', 'Pin', 'Refresh', etc. You're probably fine leaving this setting alone, though you can change it. e.g. if you prefer that Renovate uses the term 'Upgrade' instead of 'Update' then you could configure \"commitMessageAction\": \"Upgrade\" . commitMessageTopic is usually two to three words that show what is being updated. e.g. it might be dependency react or Docker image ubuntu . You may want to edit this. If you think your new commitMessageTopic is helpful for others, please open a PR . commitMessageExtra refers to the version being updated to. e.g. to v17 for a major upgrade, or to v17.0.2 for a patch update. It can be empty in some cases, like if the action/topic doesn't change a package version, e.g. Pin Docker digests . commitMessageSuffix defaults to empty but is currently used in two cases: Differentiating major from non-major groups Differentiating between PRs from different base branches, maybe for major updates you always want the PR to end with (MAJOR) , for instance commitBody is used if you wish to add multi-line commit messages, such as for the Signed-off-by fields, or adding [skip-ci] , etc. It is appended to the generated commitMessage , separated by a newline.","title":"Commit Message"},{"location":"configuration-templates/#pr-title","text":"Because commit messages match with the PR title, the PR title template defaults to null and inherits/copies the value from commitMessage . If you have a requirement where prTitle should be different from commitMessage , then please raise a feature request for discussion.","title":"PR Title"},{"location":"configuration-templates/#pr-body","text":"You can change the PR body in the following ways: Change the entire layout/flow by using prBodyTemplate (we do not recommend this) Add a header by using prHeader Add a footer by using prFooter Add a note by using prBodyNotes Edit the embedded table by using prBodyDefinitions and prBodyColumns","title":"PR Body"},{"location":"dependency-pinning/","text":"Should you Pin your JavaScript Dependencies? \u00b6 Once you start using a tool/service like Renovate, probably the biggest decision you need to make is whether to \"pin\" your dependencies instead of using SemVer ranges. The answer is \"It's your choice\", but we can certainly make some generalisations/recommendations to help you. If you do not want to read the in-depth discussion, and just want our recommendations, skip ahead to the \"So what's best?\" section . What is Dependency Pinning? \u00b6 To ensure we're all talking about the same thing, it's important to define exactly what we mean by dependency \"pinning\". Historically, projects use SemVer ranges in their package.json . For instance, if you run npm install foobar you will see an entry like \"foobar\": \"^1.1.0\" added to your package.json . Verbosely, this means \"any foobar version greater than or equal to 1.1.0 but less than 2\". The project will automatically use 1.1.1 if it's released, or 1.2.0 , or 1.2.1 , etc - meaning you will get not only patch updates but also feature (minor) releases too. Another alternative is ranges like \"foobar\": \"~1.1.0\" which means \"any foobar version greater than or equal to 1.1.0 but less than 1.2\". This narrows the range to only patch updates to the 1.1 range. If instead you \"pin\" your dependencies rather than use ranges, it means you use exact entries like \"foobar\": \"1.1.0\" which means \"use only foobar version 1.1.0 and no other\". Why use ranges? \u00b6 For projects of any type, the main reason to use ranges is so that you can \"automatically\" get updated releases - which may even include security fixes. By \"automatically\", we mean that any time you run npm install you will get the very latest version matching your SemVer - assuming you're not using a lock file, that is. Tilde vs Caret \u00b6 If you're familiar with the theory of SemVer, you might think that you only need to use tilde ranges (e.g. \"~1.1.0\" ) to get bug fixes, rather than caret ranges (e.g. \"^1.1.0\" ). This is true in theory but not in practice. The reality is that for most projects, fixes are not \"backported\" to previous minor releases, and minor releases themselves may include fixes. So for example release 1.2.0 may include one new feature and one fix, so if you stick with 1.1.0 then you will miss out on the fix as there will never be a 1.1.1 once 1.2.0 is already released. This is the reality of most open source packages. Ranges for Libraries \u00b6 A second reason for using ranges applies to \"libraries\" that are published as npm packages with the intention that they are used/ require() 'd by other packages. In this case, it is usually a bad idea to pin all your dependencies because it will introduce an unnecessarily narrow range (one release!) and cause most users of your package to bloat their node_modules with duplicates. For example, you might have pinned foobar to version 1.1.0 and another author pinned his/her foobar dependency to 1.2.2 . Any user of both your packages will end up with npm trying to install two separate versions of foobar , which might not even work. Even if both projects use a service like Renovate to keep their pinned dependencies up to date with the very latest versions, it's still not a good idea - there will always be times when one package has updated/released before the other one and they will be out of sync. e.g. there might be a space of 30 minutes where your package specifies foobar 1.1.0 and the other one specifies 1.1.1 and your joint downstream users end up with a duplicate. Why pin dependencies? \u00b6 You mainly pin versions for certainty, and visibility. When you have a pinned version of each dependency in your package.json , you know exactly which version of each dependency is installed at any time. This benefits when upgrading versions as well as when rolling back in case of problems. Note We'll cover lock files later, don't worry. Upgrading pinned versions \u00b6 Let's say that a \"faulty\" version 1.2.0 of foobar is released and it breaks one of your tests. If you were using default caret SemVer ranges, then your main branch is now \"broken\" because its package.json says that any version 1.x above 1.1.0 is acceptable, and npm will choose the latest ( 1.2.0 ). You would need to manually check and work out which dependency caused the failure ( foobar may not have been the only dependency to have \"automatically\" upgraded since the last time your tests passed) and then you would need to pin the dependency yourself to stop npm installing 1.2.0 . Consider the same situation if instead you were pinning dependency versions. Your main branch would not be broken because it's pinned to foobar@1.1.0 - instead you'd just have a Pull Request for upgrading to foobar@1.2.0 which would fail. You'd know not to merge it and can wait for foobar@1.2.1 or later when it's fixed. By pinning dependencies you know exactly what you're running and you know exactly what failed. Now consider a similar theoretical scenario where foobar@1.2.0 is faulty but it is not caught by any of your automated tests. This is more common and more dangerous. If you were using SemVer ranges then this new version of foobar will likely be deployed to production automatically one day, sometime after which you notice errors and realise you need to fix it. Like before, you need to manually work out which dependency caused it - assuming you guess correctly that it was a new dependency version at fault - and pin it manually by editing package.json one dependency at a time. Alternatively, if you were instead pinning foobar then you would get a PR for foobar@1.2.0 which awaits your approval. So first of all, you can choose to read the release notes and/or visually inspect the branch yourself before merging, hopefully saving you from pushing this faulty code to production. If you did not catch the fault before merging, you are still better off with a pinned version. If you discover something wrong in production, you can easily \"roll back\" commits in your development environment until you find which rollback fixes the problem. Then you can simply revert that commit (reversing foobar@1.1.0 -> foobar@1.2.0 ) and push that to main . When the next release of foobar comes out (e.g. 1.2.1 ) you will be prompted with a new PR and hopefully inspect it carefully this time before merge! As you can see in the above, pinning dependencies makes your build more consistent and predictable as a developer. Downside of pinned dependencies - upgrade \"noise\" \u00b6 The one major downside to your development workflow of pinning dependencies is the potential for increased \"noise\" in your repository. As mentioned above, you can expect to get Pull Requests whenever there is a new version of your dependencies available. Depending on how many repositories you maintain, and how many dependencies are in each, you may find this default approach to be overwhelming (e.g. waking up to 10 new Pull Requests each day). Reducing the \"noise\" of dependency updates \u00b6 The increased volume of Pull Requests for upgrading dependencies may be considered by some to be undesirable \"noise\" in their day. To some extent this is simply a trade-off for having your dependencies pinned and predictable, but there are also ways you can reduce this noise while still gaining the majority of the benefits: Pull Request automerging \u00b6 There are some dependencies that either (a) don't have the potential to break something in production, or (b) are fully tested by your tests. For example, it's very hard for eslint to break anything in production. If your build/tests pass, then you are fine. Consider enabling automerge for all lint packages to save yourself the pointless click when you manually approve them each time. In this case you might wake up to 5/10 of your overnight Pull Requests having already merged themselves. Another example of a good candidate for automerging might be a database driver like node-postgres ( pg on npm), if you have 100% test coverage of your API. In that case if the pg package has a minor or patch update and passes all tests then you may as well merge it automatically if you were not going to do a manual inspection anyway. Branch automerging \u00b6 In the above suggestion of Pull Request automerging, you might still find it annoying if you get GitHub Notifications for every PR that is created and merged. In that case, you could set automergeType to branch , which means Renovate will: Create a new branch for testing Wait until after tests have completed Push the commit directly to main if tests pass, or Raise a PR only if tests failed With this approach, updates will be essentially \"silent\" - causing no notifications - but you will be able to see each commit on main of course. Scheduling \u00b6 Although it can feel satisfying to get updates \"immediately\" when they're available, the reality is that you usually don't need updates so frequently. And worse still, npm package versions that are less than 24 hours can be unpublished , which would really break your build if you've pinned to a version that no longer exists. So to reduce the interruptions of automated dependency updates, consider putting Renovate on a schedule, such as: Update only on weekends? This way you update packages at most once per week, and your CI build runners are likely to be idle anyway Update daily, but between hours like midnight and 5am? That way notifications don't pop up in people's feed while they're working, and you also get the benefit of not tying up build machines when developers need to use them To learn all about controlling Renovate's schedule, read the key concepts, scheduling docs. Grouping related packages \u00b6 Although it's good to isolate each dependency update for ease of troubleshooting, there are times when the extra noise isn't worth it, or when packages naturally belong together anyway (such as all babel packages). You can add a package rule in our Renovate configuration to group these together and you'll get just one branch combined even if multiple packages have updates available. Pinning Dependencies and Lock Files \u00b6 Since both yarn and npm@5 both support lock files, it's a common question to ask \"Why should I pin dependencies if I'm already using a lock file?\". It's a good question! Lock files are a great companion to SemVer ranges or pinning dependencies, because these files lock (pin) deeper into your dependency tree than you see in package.json . What a lock file will do for you \u00b6 When kept in sync with its associated package.json , a lock file will further lock down the exact dependencies and sub -dependencies that your project uses, so that everyone running npm install or yarn install will install the exact same dependencies as the person or bot that last updated the lock file. To reuse an earlier example, this means that you could have foobar@^1.1.0 in your package.json and be locked to 1.1.0 in your lock file, so that when the broken foobar@1.2.0 is released, nobody on the team installs it. What a lock file doesn't do for you \u00b6 If a lock file gets out of sync with its package.json , it can no longer be guaranteed to lock anything, and the package.json will be the source of truth for installs. The lock file has only delayed the inevitable problem, and provides much less visibility than package.json , because it's not designed to be human readable and is quite dense. If the package.json has a range, and a new in-range version is released that would break the build, then essentially your package.json is in a state of \"broken\", even if the lock file is still holding things together. The upside is that the lockfile will hold back foobar to 1.1.0 unless it's forced to upgrade, so the break is postponed. The downside is how you will discover the break eventually. The easiest case is if for some reason you need to upgrade foobar , e.g. for a new feature it has, so you might run something like yarn upgrade foobar . Then you might either discover the break during your development or when you push your new development to CI for testing. In this case, hopefully you'll guess it's foobar that broke it and not your own code. Alternatively, maybe someone thinks \"This lockfile is probably really out of date and might be missing some essential patches\" and decides to yarn upgrade the whole thing in one go. No doubt the diff will be full of green and red as many direct and indirect dependencies will have changed versions. Then it's pushed to CI for testing, fails, and you have to guess which of the changes caused it until you eventually narrow it down to foobar . This might require even manually looking through the lock file diffs line by line. Maybe dep blahblah also broke at the same time, to make it even harder. By ceding control of direct dependency versions to the lock file, you have lost the ability to know when things are updated. You also may be missing out on really important patches you're not even aware of, because they're \"in range\" yet locked back to vulnerable or buggy versions in the lock file. Reconsider the same scenario if foobar had instead been pinned to 1.1.0 in package.json . The (broken) upgrade to 1.2.0 would have been explicitly proposed to you via a Renovate PR, you would see the break, and know that the version is bad. Meanwhile you could be upgrading all the other essential fixes of other dependencies without worrying about foobar . You could even be running yarn upgrade regularly to be getting indirect package updates in the lockfile and seeing if everything still passes. So the lock file does not solve the same SemVer problems that pinning solves - but it compliments it. For this reason our usual recommendation using a lock file regardless of whether you pin dependencies or not, and pinning even if you have a lock file. Don't forget though that our motto is \"Flexible, so you don't need to be\", so go ahead and configure however you want. Also, we're open to ideas for how to make lock file updates more \"visible\" too. e.g. are you interested in a Renovate feature where you get a lockfile-only PR any time a direct dependency gets an in-range update? What about indirect/sub-dependencies? \u00b6 A good argument made by @LinusU is: pinning will only protect you against breakage in a, in many cases, small percentage of your packages. If you for example have installed express and pinned it, you will only protect yourself against a bad express release, it will not help with the 30 dependencies that express has. Because of this, I personally think that pinning dependencies just creates a false sense of security, and that using a lock file is superior in every way. It is true that pinning applies only to direct dependencies, and \"indirect\" dependencies typically count for a lot more in total in your lockfile than direct. e.g. those 30 ones that Express relies on. Does pinning give you \"increased\" security? Undeniably. The question is not whether it does, but whether that increased security comes at a cost (e.g. \"noise\"). But Linus also points out that a false sense of security is a cost too. Don't forget that there is some form of transitive trust too. You need to pick your direct dependencies carefully, and which versions of them you use. Hopefully in doing that you pick dependencies partly for how well they look after their own dependencies and versions (e.g. do they have good enough test coverage, do they use something like Renovate to keep updated, etc?). So the reality is that even if 90% of the entries in your lock file are indirect dependencies, those are ones you have somewhat \"delegated\" responsibility for to your dependencies. e.g. I'd hope that Express are even better at watching their dependencies for breaks than I am, to use the example above. But certainly \"does it give a false sense of security\" is not a question we can really answer quantifiably. So what's best? \u00b6 We recommend: Any apps (web or Node.js) that aren't require() 'd by other packages should pin all types of dependencies for greatest reliability/predictability Browser or dual browser/node.js libraries that are consumed/ required() 'd by others should keep using SemVer ranges for dependencies but can use pinned dependencies for devDependencies Node.js-only libraries can consider pinning all dependencies, because application size/duplicate dependencies are not as much a concern in Node.js compared to the browser. Of course, don't do that if your library is a micro one likely to be consumed in disk-sensitive environments Use a lock file As noted earlier, when you pin dependencies then you will see an increase in the raw volume of dependency updates, compared to if you use ranges. If/when this starts bothering you, add Renovate rules to reduce the volume, such as scheduling updates, grouping them, or automerging \"safe\" ones. References \u00b6 This is a \"living\" document and we plan to update it whenever we think of something new or someone makes a valid point we've missed or misunderstood. Updated 2018-01-19 after excellent feedback on lockfiles by @LinusU","title":"Should you Pin your Javascript Dependencies?"},{"location":"dependency-pinning/#should-you-pin-your-javascript-dependencies","text":"Once you start using a tool/service like Renovate, probably the biggest decision you need to make is whether to \"pin\" your dependencies instead of using SemVer ranges. The answer is \"It's your choice\", but we can certainly make some generalisations/recommendations to help you. If you do not want to read the in-depth discussion, and just want our recommendations, skip ahead to the \"So what's best?\" section .","title":"Should you Pin your JavaScript Dependencies?"},{"location":"dependency-pinning/#what-is-dependency-pinning","text":"To ensure we're all talking about the same thing, it's important to define exactly what we mean by dependency \"pinning\". Historically, projects use SemVer ranges in their package.json . For instance, if you run npm install foobar you will see an entry like \"foobar\": \"^1.1.0\" added to your package.json . Verbosely, this means \"any foobar version greater than or equal to 1.1.0 but less than 2\". The project will automatically use 1.1.1 if it's released, or 1.2.0 , or 1.2.1 , etc - meaning you will get not only patch updates but also feature (minor) releases too. Another alternative is ranges like \"foobar\": \"~1.1.0\" which means \"any foobar version greater than or equal to 1.1.0 but less than 1.2\". This narrows the range to only patch updates to the 1.1 range. If instead you \"pin\" your dependencies rather than use ranges, it means you use exact entries like \"foobar\": \"1.1.0\" which means \"use only foobar version 1.1.0 and no other\".","title":"What is Dependency Pinning?"},{"location":"dependency-pinning/#why-use-ranges","text":"For projects of any type, the main reason to use ranges is so that you can \"automatically\" get updated releases - which may even include security fixes. By \"automatically\", we mean that any time you run npm install you will get the very latest version matching your SemVer - assuming you're not using a lock file, that is.","title":"Why use ranges?"},{"location":"dependency-pinning/#tilde-vs-caret","text":"If you're familiar with the theory of SemVer, you might think that you only need to use tilde ranges (e.g. \"~1.1.0\" ) to get bug fixes, rather than caret ranges (e.g. \"^1.1.0\" ). This is true in theory but not in practice. The reality is that for most projects, fixes are not \"backported\" to previous minor releases, and minor releases themselves may include fixes. So for example release 1.2.0 may include one new feature and one fix, so if you stick with 1.1.0 then you will miss out on the fix as there will never be a 1.1.1 once 1.2.0 is already released. This is the reality of most open source packages.","title":"Tilde vs Caret"},{"location":"dependency-pinning/#ranges-for-libraries","text":"A second reason for using ranges applies to \"libraries\" that are published as npm packages with the intention that they are used/ require() 'd by other packages. In this case, it is usually a bad idea to pin all your dependencies because it will introduce an unnecessarily narrow range (one release!) and cause most users of your package to bloat their node_modules with duplicates. For example, you might have pinned foobar to version 1.1.0 and another author pinned his/her foobar dependency to 1.2.2 . Any user of both your packages will end up with npm trying to install two separate versions of foobar , which might not even work. Even if both projects use a service like Renovate to keep their pinned dependencies up to date with the very latest versions, it's still not a good idea - there will always be times when one package has updated/released before the other one and they will be out of sync. e.g. there might be a space of 30 minutes where your package specifies foobar 1.1.0 and the other one specifies 1.1.1 and your joint downstream users end up with a duplicate.","title":"Ranges for Libraries"},{"location":"dependency-pinning/#why-pin-dependencies","text":"You mainly pin versions for certainty, and visibility. When you have a pinned version of each dependency in your package.json , you know exactly which version of each dependency is installed at any time. This benefits when upgrading versions as well as when rolling back in case of problems. Note We'll cover lock files later, don't worry.","title":"Why pin dependencies?"},{"location":"dependency-pinning/#upgrading-pinned-versions","text":"Let's say that a \"faulty\" version 1.2.0 of foobar is released and it breaks one of your tests. If you were using default caret SemVer ranges, then your main branch is now \"broken\" because its package.json says that any version 1.x above 1.1.0 is acceptable, and npm will choose the latest ( 1.2.0 ). You would need to manually check and work out which dependency caused the failure ( foobar may not have been the only dependency to have \"automatically\" upgraded since the last time your tests passed) and then you would need to pin the dependency yourself to stop npm installing 1.2.0 . Consider the same situation if instead you were pinning dependency versions. Your main branch would not be broken because it's pinned to foobar@1.1.0 - instead you'd just have a Pull Request for upgrading to foobar@1.2.0 which would fail. You'd know not to merge it and can wait for foobar@1.2.1 or later when it's fixed. By pinning dependencies you know exactly what you're running and you know exactly what failed. Now consider a similar theoretical scenario where foobar@1.2.0 is faulty but it is not caught by any of your automated tests. This is more common and more dangerous. If you were using SemVer ranges then this new version of foobar will likely be deployed to production automatically one day, sometime after which you notice errors and realise you need to fix it. Like before, you need to manually work out which dependency caused it - assuming you guess correctly that it was a new dependency version at fault - and pin it manually by editing package.json one dependency at a time. Alternatively, if you were instead pinning foobar then you would get a PR for foobar@1.2.0 which awaits your approval. So first of all, you can choose to read the release notes and/or visually inspect the branch yourself before merging, hopefully saving you from pushing this faulty code to production. If you did not catch the fault before merging, you are still better off with a pinned version. If you discover something wrong in production, you can easily \"roll back\" commits in your development environment until you find which rollback fixes the problem. Then you can simply revert that commit (reversing foobar@1.1.0 -> foobar@1.2.0 ) and push that to main . When the next release of foobar comes out (e.g. 1.2.1 ) you will be prompted with a new PR and hopefully inspect it carefully this time before merge! As you can see in the above, pinning dependencies makes your build more consistent and predictable as a developer.","title":"Upgrading pinned versions"},{"location":"dependency-pinning/#downside-of-pinned-dependencies-upgrade-noise","text":"The one major downside to your development workflow of pinning dependencies is the potential for increased \"noise\" in your repository. As mentioned above, you can expect to get Pull Requests whenever there is a new version of your dependencies available. Depending on how many repositories you maintain, and how many dependencies are in each, you may find this default approach to be overwhelming (e.g. waking up to 10 new Pull Requests each day).","title":"Downside of pinned dependencies - upgrade \"noise\""},{"location":"dependency-pinning/#reducing-the-noise-of-dependency-updates","text":"The increased volume of Pull Requests for upgrading dependencies may be considered by some to be undesirable \"noise\" in their day. To some extent this is simply a trade-off for having your dependencies pinned and predictable, but there are also ways you can reduce this noise while still gaining the majority of the benefits:","title":"Reducing the \"noise\" of dependency updates"},{"location":"dependency-pinning/#pull-request-automerging","text":"There are some dependencies that either (a) don't have the potential to break something in production, or (b) are fully tested by your tests. For example, it's very hard for eslint to break anything in production. If your build/tests pass, then you are fine. Consider enabling automerge for all lint packages to save yourself the pointless click when you manually approve them each time. In this case you might wake up to 5/10 of your overnight Pull Requests having already merged themselves. Another example of a good candidate for automerging might be a database driver like node-postgres ( pg on npm), if you have 100% test coverage of your API. In that case if the pg package has a minor or patch update and passes all tests then you may as well merge it automatically if you were not going to do a manual inspection anyway.","title":"Pull Request automerging"},{"location":"dependency-pinning/#branch-automerging","text":"In the above suggestion of Pull Request automerging, you might still find it annoying if you get GitHub Notifications for every PR that is created and merged. In that case, you could set automergeType to branch , which means Renovate will: Create a new branch for testing Wait until after tests have completed Push the commit directly to main if tests pass, or Raise a PR only if tests failed With this approach, updates will be essentially \"silent\" - causing no notifications - but you will be able to see each commit on main of course.","title":"Branch automerging"},{"location":"dependency-pinning/#scheduling","text":"Although it can feel satisfying to get updates \"immediately\" when they're available, the reality is that you usually don't need updates so frequently. And worse still, npm package versions that are less than 24 hours can be unpublished , which would really break your build if you've pinned to a version that no longer exists. So to reduce the interruptions of automated dependency updates, consider putting Renovate on a schedule, such as: Update only on weekends? This way you update packages at most once per week, and your CI build runners are likely to be idle anyway Update daily, but between hours like midnight and 5am? That way notifications don't pop up in people's feed while they're working, and you also get the benefit of not tying up build machines when developers need to use them To learn all about controlling Renovate's schedule, read the key concepts, scheduling docs.","title":"Scheduling"},{"location":"dependency-pinning/#grouping-related-packages","text":"Although it's good to isolate each dependency update for ease of troubleshooting, there are times when the extra noise isn't worth it, or when packages naturally belong together anyway (such as all babel packages). You can add a package rule in our Renovate configuration to group these together and you'll get just one branch combined even if multiple packages have updates available.","title":"Grouping related packages"},{"location":"dependency-pinning/#pinning-dependencies-and-lock-files","text":"Since both yarn and npm@5 both support lock files, it's a common question to ask \"Why should I pin dependencies if I'm already using a lock file?\". It's a good question! Lock files are a great companion to SemVer ranges or pinning dependencies, because these files lock (pin) deeper into your dependency tree than you see in package.json .","title":"Pinning Dependencies and Lock Files"},{"location":"dependency-pinning/#what-a-lock-file-will-do-for-you","text":"When kept in sync with its associated package.json , a lock file will further lock down the exact dependencies and sub -dependencies that your project uses, so that everyone running npm install or yarn install will install the exact same dependencies as the person or bot that last updated the lock file. To reuse an earlier example, this means that you could have foobar@^1.1.0 in your package.json and be locked to 1.1.0 in your lock file, so that when the broken foobar@1.2.0 is released, nobody on the team installs it.","title":"What a lock file will do for you"},{"location":"dependency-pinning/#what-a-lock-file-doesnt-do-for-you","text":"If a lock file gets out of sync with its package.json , it can no longer be guaranteed to lock anything, and the package.json will be the source of truth for installs. The lock file has only delayed the inevitable problem, and provides much less visibility than package.json , because it's not designed to be human readable and is quite dense. If the package.json has a range, and a new in-range version is released that would break the build, then essentially your package.json is in a state of \"broken\", even if the lock file is still holding things together. The upside is that the lockfile will hold back foobar to 1.1.0 unless it's forced to upgrade, so the break is postponed. The downside is how you will discover the break eventually. The easiest case is if for some reason you need to upgrade foobar , e.g. for a new feature it has, so you might run something like yarn upgrade foobar . Then you might either discover the break during your development or when you push your new development to CI for testing. In this case, hopefully you'll guess it's foobar that broke it and not your own code. Alternatively, maybe someone thinks \"This lockfile is probably really out of date and might be missing some essential patches\" and decides to yarn upgrade the whole thing in one go. No doubt the diff will be full of green and red as many direct and indirect dependencies will have changed versions. Then it's pushed to CI for testing, fails, and you have to guess which of the changes caused it until you eventually narrow it down to foobar . This might require even manually looking through the lock file diffs line by line. Maybe dep blahblah also broke at the same time, to make it even harder. By ceding control of direct dependency versions to the lock file, you have lost the ability to know when things are updated. You also may be missing out on really important patches you're not even aware of, because they're \"in range\" yet locked back to vulnerable or buggy versions in the lock file. Reconsider the same scenario if foobar had instead been pinned to 1.1.0 in package.json . The (broken) upgrade to 1.2.0 would have been explicitly proposed to you via a Renovate PR, you would see the break, and know that the version is bad. Meanwhile you could be upgrading all the other essential fixes of other dependencies without worrying about foobar . You could even be running yarn upgrade regularly to be getting indirect package updates in the lockfile and seeing if everything still passes. So the lock file does not solve the same SemVer problems that pinning solves - but it compliments it. For this reason our usual recommendation using a lock file regardless of whether you pin dependencies or not, and pinning even if you have a lock file. Don't forget though that our motto is \"Flexible, so you don't need to be\", so go ahead and configure however you want. Also, we're open to ideas for how to make lock file updates more \"visible\" too. e.g. are you interested in a Renovate feature where you get a lockfile-only PR any time a direct dependency gets an in-range update?","title":"What a lock file doesn't do for you"},{"location":"dependency-pinning/#what-about-indirectsub-dependencies","text":"A good argument made by @LinusU is: pinning will only protect you against breakage in a, in many cases, small percentage of your packages. If you for example have installed express and pinned it, you will only protect yourself against a bad express release, it will not help with the 30 dependencies that express has. Because of this, I personally think that pinning dependencies just creates a false sense of security, and that using a lock file is superior in every way. It is true that pinning applies only to direct dependencies, and \"indirect\" dependencies typically count for a lot more in total in your lockfile than direct. e.g. those 30 ones that Express relies on. Does pinning give you \"increased\" security? Undeniably. The question is not whether it does, but whether that increased security comes at a cost (e.g. \"noise\"). But Linus also points out that a false sense of security is a cost too. Don't forget that there is some form of transitive trust too. You need to pick your direct dependencies carefully, and which versions of them you use. Hopefully in doing that you pick dependencies partly for how well they look after their own dependencies and versions (e.g. do they have good enough test coverage, do they use something like Renovate to keep updated, etc?). So the reality is that even if 90% of the entries in your lock file are indirect dependencies, those are ones you have somewhat \"delegated\" responsibility for to your dependencies. e.g. I'd hope that Express are even better at watching their dependencies for breaks than I am, to use the example above. But certainly \"does it give a false sense of security\" is not a question we can really answer quantifiably.","title":"What about indirect/sub-dependencies?"},{"location":"dependency-pinning/#so-whats-best","text":"We recommend: Any apps (web or Node.js) that aren't require() 'd by other packages should pin all types of dependencies for greatest reliability/predictability Browser or dual browser/node.js libraries that are consumed/ required() 'd by others should keep using SemVer ranges for dependencies but can use pinned dependencies for devDependencies Node.js-only libraries can consider pinning all dependencies, because application size/duplicate dependencies are not as much a concern in Node.js compared to the browser. Of course, don't do that if your library is a micro one likely to be consumed in disk-sensitive environments Use a lock file As noted earlier, when you pin dependencies then you will see an increase in the raw volume of dependency updates, compared to if you use ranges. If/when this starts bothering you, add Renovate rules to reduce the volume, such as scheduling updates, grouping them, or automerging \"safe\" ones.","title":"So what's best?"},{"location":"dependency-pinning/#references","text":"This is a \"living\" document and we plan to update it whenever we think of something new or someone makes a valid point we've missed or misunderstood. Updated 2018-01-19 after excellent feedback on lockfiles by @LinusU","title":"References"},{"location":"docker/","text":"Docker \u00b6 Renovate supports upgrading dependencies in various types of Docker definition files: Docker's Dockerfile files Docker Compose docker-compose.yml , compose.yml files CircleCI config files Kubernetes manifest files Ansible configuration files How It Works \u00b6 Renovate searches in each repository for any files matching each manager's configured fileMatch pattern(s) Matching files are parsed, Renovate checks if the file(s) has any Docker image references (e.g. FROM lines in a Dockerfile ) If the image tag in use \"looks\" like a version (e.g. myimage:1 , myimage:1.1 , myimage:1.1.0 , myimage:1-onbuild ) then Renovate checks the Docker registry for upgrades (e.g. from myimage:1.1.0 to myimage:1.2.0 ) Preservation of Version Precision \u00b6 By default, Renovate preserves the precision level specified in the Docker images. For example, if the existing image is pinned at myimage:1.1 then Renovate only proposes upgrades to myimage:1.2 or myimage:1.3 . This means that you will not get upgrades to a more specific versions like myimage:1.2.0 or myimage:1.3.0 . Renovate does not yet support \"pinning\" an imprecise version to a precise version, e.g. from myimage:1.2 to myimage:1.2.0 , but it's a feature we'd like to work on one day. Version compatibility \u00b6 Although suffixes in SemVer indicate pre-releases (e.g. v1.2.0-alpha.2 ), in Docker they typically indicate compatibility, e.g. 1.2.0-alpine . By default Renovate assumes suffixes indicate compatibility, for this reason Renovate will not change any suffixes. Renovate will update 1.2.0-alpine to 1.2.1-alpine but never updates to 1.2.1 or 1.2.1-stretch as that would change the suffix. If this behavior does not suit a particular package you have, Renovate allows you to customize the versioning scheme it uses. For example, you have a Docker image foo/bar that sticks to SemVer versioning. This means that you need to tell Renovate that suffixes indicate pre-release versions, and not compatibility. You could then use this packageRules array, to tell Renovate to use semver versioning for the foo/bar package: { \"packageRules\" : [ { \"matchDatasources\" : [ \"docker\" ], \"matchPackageNames\" : [ \"foo/bar\" ], \"versioning\" : \"semver\" } ] } Another example is the official python image, which follows pep440 versioning. You can tell Renovate to use the pep440 versioning scheme with this set of packageRules : { \"packageRules\" : [ { \"matchDatasources\" : [ \"docker\" ], \"matchPackageNames\" : [ \"python\" ], \"versioning\" : \"pep440\" } ] } If traditional versioning doesn't work, try Renovate's built-in loose versioning . Renovate will perform a best-effort sort of the versions, regardless of whether they have letters or digits. If both the traditional versioning, and the loose versioning do not give the results you want, try the regex versioning . This approach uses regex capture group syntax to specify which part of the version string is major, minor, patch, pre-release, or compatibility. See the docs for versioning for documentation and examples of regex versioning in action. Digest Pinning \u00b6 We recommend that you pin your Docker images to an exact digest. By pinning to a digest you ensure your Docker builds are immutable : every time you do a pull you get the same content. If you have experience with the way dependency versioning is handled in the JavaScript/npm ecosystem, you might be used to exact versions being immutable. e.g. if you specify a version like 2.0.1 , you and your colleagues always get the exact same \"code\". What you may not know is that Docker's tags are not immutable versions, even if they look like a version. e.g. you probably expect myimage:1 and myimage:1.2 to change over time, but you might incorrectly assume that myimage:1.2.0 never changes. Although it probably shouldn't , the reality is that any Docker image tag can change content, and potentially break. Using a Docker digest as the image's primary identifier instead of using a Docker tag will achieve immutability. It's not easy to work with strings like FROM node@sha256:d938c1761e3afbae9242848ffbb95b9cc1cb0a24d889f8bd955204d347a7266e . Luckily Renovate can update the digests for you, so you don't have to. To keep things simple, Renovate retains the Docker tag in the FROM line, e.g. FROM node:14.15.1@sha256:d938c1761e3afbae9242848ffbb95b9cc1cb0a24d889f8bd955204d347a7266e . Read on to see how Renovate updates Docker digests. Digest Updating \u00b6 If you follow our advice to go from a simple tag like node:14 to using a pinned digest node:14@sha256:d938c1761e3afbae9242848ffbb95b9cc1cb0a24d889f8bd955204d347a7266e , you will get Renovate PRs whenever the node:14 image is updated on Docker Hub. Previously this update would have been \"invisible\" to you - one day you pull code that represents node:14.15.0 and the next day you get code that represents node:14.15.1 . But you can never be sure, especially as Docker caches. Perhaps some of your colleagues or worse still your build machine are stuck on an older version with a security vulnerability. By pinning to a digest instead, you will get these updates via Pull Requests, or even committed directly to your repository if you enable branch automerge for convenience. This ensures everyone on the team uses the latest versions and is in sync. Version Upgrading \u00b6 Renovate also supports upgrading versions in Docker tags, e.g. from myimage:1.2.0 to myimage:1.2.1 or myimage:1.2 to myimage:1.3 . If a tag looks like a version, Renovate will upgrade it like a version. We recommend you use the major.minor.patch tagging scheme e.g. change from myimage:1 to myimage:1.1.1 . This way it's easy to see what the Renovate PR is going to change. You can see the difference between a PR that upgrades myimage from 1.1.1 to 1.1.2 . and a PR that changes the contents of the version you already use ( 1.1.1 ). Currently, Renovate will upgrade minor/patch versions (e.g. from 1.2.0 to 1.2.1 ) by default, but not upgrade major versions. If you wish to enable major versions then add the preset docker:enableMajor to your extends array in your renovate.json . Renovate has some Docker-specific intelligence when it comes to versions. For example: Ubuntu codenames \u00b6 Renovate understands Ubuntu release code names and will offer upgrades to the latest LTS release (e.g. from ubuntu:xenial to ubuntu:focal ). For this to work you must follow this naming scheme: The first term of the full codename is used (e.g. bionic for Bionic Beaver release) The codename is in lowercase For example, Renovate will offer to upgrade the following Dockerfile layer: FROM ubuntu:yakkety To: FROM ubuntu:focal Debian codenames \u00b6 Renovate understands Debian release code names and rolling updates schedule and will offer upgrades to the latest stable release (e.g. from debian:stretch to debian:bullseye ). For this to work the codename must be in lowercase. For example, Renovate will offer to upgrade the following Dockerfile layer: FROM debian:buster To: FROM debian:bullseye Configuring/Disabling \u00b6 If you wish to make changes that apply to all Docker managers, then add them to the docker config object. This is not foolproof, because some managers like circleci and ansible support multiple datasources that do not inherit from the docker config object. If you wish to override Docker settings for one particular type of manager, use that manager's config object instead. For example, to disable digest updates for Docker Compose only but leave them for other managers like Dockerfile , you would use this: { \"docker-compose\" : { \"digest\" : { \"enabled\" : false } } } The following configuration options are applicable to Docker: Disable all Docker Renovation \u00b6 Add \"docker:disable\" to your extends array. Disable Renovate for only certain Dockerfiles \u00b6 Add all paths to ignore into the ignorePaths configuration field. e.g. { \"extends\" : [ \"config:base\" ], \"ignorePaths\" : [ \"docker/old-files/\" ] } Enable Docker major updates \u00b6 Add \"docker:enableMajor\" to your extends array. Disable digest pinning \u00b6 Add \"default:pinDigestsDisabled\" to your extends array. Automerge digest updates \u00b6 Add \"default:automergeDigest\" to your extends array. If you want Renovate to commit directly to your base branch without opening a PR first, add \"default:automergeBranchPush\" to the extends array. Registry authentication \u00b6 There are many different registries, and many ways to authenticate to those registries. We will explain how to authenticate for the most common registries. DockerHub \u00b6 Here is an example of configuring a default Docker username/password in config.js . The Docker Hub password is stored in a process environment variable. module . exports = { hostRules : [ { hostType : 'docker' , username : '<your-username>' , password : process . env . DOCKER_HUB_PASSWORD , }, ], }; You can add additional host rules, read the hostrules documentation for more information. Self-hosted Docker registry \u00b6 Say you host some Docker images yourself, and use a password to access your self-hosted Docker images. In addition to self-hosting, you also pull images from Docker Hub, without a password. In this example you would configure a specific Docker host like this: module . exports = { hostRules : [ { hostType : 'docker' , matchHost : 'your.host.io' , username : '<your-username>' , password : process . env . SELF_HOSTED_DOCKER_IMAGES_PASSWORD , }, ], }; Google Container Registry \u00b6 Assume you are running GitLab CI in the Google Cloud, and you are storing your Docker images in the Google Container Registry (GCR). Access to the GCR uses Bearer token based authentication. This token can be obtained by running gcloud auth print-access-token , which requires the Google Cloud SDK to be installed. The token expires after 60 minutes so you cannot store it in a variable for subsequent builds (like you can with RENOVATE_TOKEN ). When running Renovate in this context the Google access token must be retrieved and injected into the hostRules configuration just before Renovate is started. This documentation gives a few hints on a possible way to achieve this end result. The basic approach is that you create a custom image and then run Renovate as one of the stages of your project. To make this run independent of any user you should use a Project Access Token (with Scopes: api , read_api and write_repository ) for the project and use this as the RENOVATE_TOKEN variable for GitLab CI. See also the renovate-runner repository on GitLab where .gitlab-ci.yml configuration examples can be found. To get access to the token a custom Renovate Docker image is needed that includes the Google Cloud SDK. The Dockerfile to create such an image can look like this: FROM renovate/renovate:32.74.3 # Include the \"Docker tip\" which you can find here https://cloud.google.com/sdk/docs/install # under \"Installation\" for \"Debian/Ubuntu\" RUN ... For Renovate to access the Google Container Registry (GCR) it needs the current Google Access Token. The configuration fragment to do that looks something like this: hostRules : [ { matchHost : 'eu.gcr.io' , token : 'MyReallySecretTokenThatExpiresAfter60Minutes' , }, ]; One way to provide the short-lived Google Access Token to Renovate is by generating these settings into a config.js file from within the .gitlab-ci.yml right before starting Renovate: script : - 'echo \"module.exports = { hostRules: [ { matchHost: '' eu.gcr.io '' , token: '' \"$(gcloud auth print-access-token)\" '' } ] };\" > config.js' - renovate $RENOVATE_EXTRA_FLAGS","title":"Docker"},{"location":"docker/#docker","text":"Renovate supports upgrading dependencies in various types of Docker definition files: Docker's Dockerfile files Docker Compose docker-compose.yml , compose.yml files CircleCI config files Kubernetes manifest files Ansible configuration files","title":"Docker"},{"location":"docker/#how-it-works","text":"Renovate searches in each repository for any files matching each manager's configured fileMatch pattern(s) Matching files are parsed, Renovate checks if the file(s) has any Docker image references (e.g. FROM lines in a Dockerfile ) If the image tag in use \"looks\" like a version (e.g. myimage:1 , myimage:1.1 , myimage:1.1.0 , myimage:1-onbuild ) then Renovate checks the Docker registry for upgrades (e.g. from myimage:1.1.0 to myimage:1.2.0 )","title":"How It Works"},{"location":"docker/#preservation-of-version-precision","text":"By default, Renovate preserves the precision level specified in the Docker images. For example, if the existing image is pinned at myimage:1.1 then Renovate only proposes upgrades to myimage:1.2 or myimage:1.3 . This means that you will not get upgrades to a more specific versions like myimage:1.2.0 or myimage:1.3.0 . Renovate does not yet support \"pinning\" an imprecise version to a precise version, e.g. from myimage:1.2 to myimage:1.2.0 , but it's a feature we'd like to work on one day.","title":"Preservation of Version Precision"},{"location":"docker/#version-compatibility","text":"Although suffixes in SemVer indicate pre-releases (e.g. v1.2.0-alpha.2 ), in Docker they typically indicate compatibility, e.g. 1.2.0-alpine . By default Renovate assumes suffixes indicate compatibility, for this reason Renovate will not change any suffixes. Renovate will update 1.2.0-alpine to 1.2.1-alpine but never updates to 1.2.1 or 1.2.1-stretch as that would change the suffix. If this behavior does not suit a particular package you have, Renovate allows you to customize the versioning scheme it uses. For example, you have a Docker image foo/bar that sticks to SemVer versioning. This means that you need to tell Renovate that suffixes indicate pre-release versions, and not compatibility. You could then use this packageRules array, to tell Renovate to use semver versioning for the foo/bar package: { \"packageRules\" : [ { \"matchDatasources\" : [ \"docker\" ], \"matchPackageNames\" : [ \"foo/bar\" ], \"versioning\" : \"semver\" } ] } Another example is the official python image, which follows pep440 versioning. You can tell Renovate to use the pep440 versioning scheme with this set of packageRules : { \"packageRules\" : [ { \"matchDatasources\" : [ \"docker\" ], \"matchPackageNames\" : [ \"python\" ], \"versioning\" : \"pep440\" } ] } If traditional versioning doesn't work, try Renovate's built-in loose versioning . Renovate will perform a best-effort sort of the versions, regardless of whether they have letters or digits. If both the traditional versioning, and the loose versioning do not give the results you want, try the regex versioning . This approach uses regex capture group syntax to specify which part of the version string is major, minor, patch, pre-release, or compatibility. See the docs for versioning for documentation and examples of regex versioning in action.","title":"Version compatibility"},{"location":"docker/#digest-pinning","text":"We recommend that you pin your Docker images to an exact digest. By pinning to a digest you ensure your Docker builds are immutable : every time you do a pull you get the same content. If you have experience with the way dependency versioning is handled in the JavaScript/npm ecosystem, you might be used to exact versions being immutable. e.g. if you specify a version like 2.0.1 , you and your colleagues always get the exact same \"code\". What you may not know is that Docker's tags are not immutable versions, even if they look like a version. e.g. you probably expect myimage:1 and myimage:1.2 to change over time, but you might incorrectly assume that myimage:1.2.0 never changes. Although it probably shouldn't , the reality is that any Docker image tag can change content, and potentially break. Using a Docker digest as the image's primary identifier instead of using a Docker tag will achieve immutability. It's not easy to work with strings like FROM node@sha256:d938c1761e3afbae9242848ffbb95b9cc1cb0a24d889f8bd955204d347a7266e . Luckily Renovate can update the digests for you, so you don't have to. To keep things simple, Renovate retains the Docker tag in the FROM line, e.g. FROM node:14.15.1@sha256:d938c1761e3afbae9242848ffbb95b9cc1cb0a24d889f8bd955204d347a7266e . Read on to see how Renovate updates Docker digests.","title":"Digest Pinning"},{"location":"docker/#digest-updating","text":"If you follow our advice to go from a simple tag like node:14 to using a pinned digest node:14@sha256:d938c1761e3afbae9242848ffbb95b9cc1cb0a24d889f8bd955204d347a7266e , you will get Renovate PRs whenever the node:14 image is updated on Docker Hub. Previously this update would have been \"invisible\" to you - one day you pull code that represents node:14.15.0 and the next day you get code that represents node:14.15.1 . But you can never be sure, especially as Docker caches. Perhaps some of your colleagues or worse still your build machine are stuck on an older version with a security vulnerability. By pinning to a digest instead, you will get these updates via Pull Requests, or even committed directly to your repository if you enable branch automerge for convenience. This ensures everyone on the team uses the latest versions and is in sync.","title":"Digest Updating"},{"location":"docker/#version-upgrading","text":"Renovate also supports upgrading versions in Docker tags, e.g. from myimage:1.2.0 to myimage:1.2.1 or myimage:1.2 to myimage:1.3 . If a tag looks like a version, Renovate will upgrade it like a version. We recommend you use the major.minor.patch tagging scheme e.g. change from myimage:1 to myimage:1.1.1 . This way it's easy to see what the Renovate PR is going to change. You can see the difference between a PR that upgrades myimage from 1.1.1 to 1.1.2 . and a PR that changes the contents of the version you already use ( 1.1.1 ). Currently, Renovate will upgrade minor/patch versions (e.g. from 1.2.0 to 1.2.1 ) by default, but not upgrade major versions. If you wish to enable major versions then add the preset docker:enableMajor to your extends array in your renovate.json . Renovate has some Docker-specific intelligence when it comes to versions. For example:","title":"Version Upgrading"},{"location":"docker/#ubuntu-codenames","text":"Renovate understands Ubuntu release code names and will offer upgrades to the latest LTS release (e.g. from ubuntu:xenial to ubuntu:focal ). For this to work you must follow this naming scheme: The first term of the full codename is used (e.g. bionic for Bionic Beaver release) The codename is in lowercase For example, Renovate will offer to upgrade the following Dockerfile layer: FROM ubuntu:yakkety To: FROM ubuntu:focal","title":"Ubuntu codenames"},{"location":"docker/#debian-codenames","text":"Renovate understands Debian release code names and rolling updates schedule and will offer upgrades to the latest stable release (e.g. from debian:stretch to debian:bullseye ). For this to work the codename must be in lowercase. For example, Renovate will offer to upgrade the following Dockerfile layer: FROM debian:buster To: FROM debian:bullseye","title":"Debian codenames"},{"location":"docker/#configuringdisabling","text":"If you wish to make changes that apply to all Docker managers, then add them to the docker config object. This is not foolproof, because some managers like circleci and ansible support multiple datasources that do not inherit from the docker config object. If you wish to override Docker settings for one particular type of manager, use that manager's config object instead. For example, to disable digest updates for Docker Compose only but leave them for other managers like Dockerfile , you would use this: { \"docker-compose\" : { \"digest\" : { \"enabled\" : false } } } The following configuration options are applicable to Docker:","title":"Configuring/Disabling"},{"location":"docker/#disable-all-docker-renovation","text":"Add \"docker:disable\" to your extends array.","title":"Disable all Docker Renovation"},{"location":"docker/#disable-renovate-for-only-certain-dockerfiles","text":"Add all paths to ignore into the ignorePaths configuration field. e.g. { \"extends\" : [ \"config:base\" ], \"ignorePaths\" : [ \"docker/old-files/\" ] }","title":"Disable Renovate for only certain Dockerfiles"},{"location":"docker/#enable-docker-major-updates","text":"Add \"docker:enableMajor\" to your extends array.","title":"Enable Docker major updates"},{"location":"docker/#disable-digest-pinning","text":"Add \"default:pinDigestsDisabled\" to your extends array.","title":"Disable digest pinning"},{"location":"docker/#automerge-digest-updates","text":"Add \"default:automergeDigest\" to your extends array. If you want Renovate to commit directly to your base branch without opening a PR first, add \"default:automergeBranchPush\" to the extends array.","title":"Automerge digest updates"},{"location":"docker/#registry-authentication","text":"There are many different registries, and many ways to authenticate to those registries. We will explain how to authenticate for the most common registries.","title":"Registry authentication"},{"location":"docker/#dockerhub","text":"Here is an example of configuring a default Docker username/password in config.js . The Docker Hub password is stored in a process environment variable. module . exports = { hostRules : [ { hostType : 'docker' , username : '<your-username>' , password : process . env . DOCKER_HUB_PASSWORD , }, ], }; You can add additional host rules, read the hostrules documentation for more information.","title":"DockerHub"},{"location":"docker/#self-hosted-docker-registry","text":"Say you host some Docker images yourself, and use a password to access your self-hosted Docker images. In addition to self-hosting, you also pull images from Docker Hub, without a password. In this example you would configure a specific Docker host like this: module . exports = { hostRules : [ { hostType : 'docker' , matchHost : 'your.host.io' , username : '<your-username>' , password : process . env . SELF_HOSTED_DOCKER_IMAGES_PASSWORD , }, ], };","title":"Self-hosted Docker registry"},{"location":"docker/#google-container-registry","text":"Assume you are running GitLab CI in the Google Cloud, and you are storing your Docker images in the Google Container Registry (GCR). Access to the GCR uses Bearer token based authentication. This token can be obtained by running gcloud auth print-access-token , which requires the Google Cloud SDK to be installed. The token expires after 60 minutes so you cannot store it in a variable for subsequent builds (like you can with RENOVATE_TOKEN ). When running Renovate in this context the Google access token must be retrieved and injected into the hostRules configuration just before Renovate is started. This documentation gives a few hints on a possible way to achieve this end result. The basic approach is that you create a custom image and then run Renovate as one of the stages of your project. To make this run independent of any user you should use a Project Access Token (with Scopes: api , read_api and write_repository ) for the project and use this as the RENOVATE_TOKEN variable for GitLab CI. See also the renovate-runner repository on GitLab where .gitlab-ci.yml configuration examples can be found. To get access to the token a custom Renovate Docker image is needed that includes the Google Cloud SDK. The Dockerfile to create such an image can look like this: FROM renovate/renovate:32.74.3 # Include the \"Docker tip\" which you can find here https://cloud.google.com/sdk/docs/install # under \"Installation\" for \"Debian/Ubuntu\" RUN ... For Renovate to access the Google Container Registry (GCR) it needs the current Google Access Token. The configuration fragment to do that looks something like this: hostRules : [ { matchHost : 'eu.gcr.io' , token : 'MyReallySecretTokenThatExpiresAfter60Minutes' , }, ]; One way to provide the short-lived Google Access Token to Renovate is by generating these settings into a config.js file from within the .gitlab-ci.yml right before starting Renovate: script : - 'echo \"module.exports = { hostRules: [ { matchHost: '' eu.gcr.io '' , token: '' \"$(gcloud auth print-access-token)\" '' } ] };\" > config.js' - renovate $RENOVATE_EXTRA_FLAGS","title":"Google Container Registry"},{"location":"faq/","text":"Frequently Asked Questions (FAQ) \u00b6 What is the default behavior? \u00b6 Renovate will: Look for configuration options in a configuration file (e.g. renovate.json ) and in each package.json file Find and process all package files (e.g. package.json , composer.json , Dockerfile , etc) in each repository Use separate branches/PR for each dependency Use separate branches for each major version of each dependency Pin devDependencies to a single version, rather than use ranges Pin dependencies to a single version if it appears not to be a library Update yarn.lock and/or package-lock.json files if found Create Pull Requests immediately after branch creation Which Renovate versions are officially supported? \u00b6 The Renovate maintainers only support the latest version of Renovate. The Renovate team will only fix bugs for an older version if the hosted app needs to stay on an older major version for a short time or if some critical bug needs to be fixed and the new major is blocked. If you're using the hosted app, you don't need to do anything, as the Renovate maintainers update the hosted app regularly. If you're self hosting Renovate, use the latest release if possible. Renovate core features not supported on all platforms \u00b6 Feature Platforms which lack feature See Renovate issue(s) Dependency Dashboard BitBucket, BitBucket Server, Azure #9592 Hosted app GitLab, BitBucket, BitBucket Server, Azure, Gitea Major platform features not supported by Renovate \u00b6 Some major platform features are not supported at all by Renovate. Feature name Platform See Renovate issue(s) Jira issues BitBucket #3796 Merge trains GitLab #5573 Configurable merge strategy and message Only BitBucket for now #10867 #10868 #10869 #10870 What is this main branch I see in the documentation? \u00b6 When you create a new repository with Git, Git creates a base branch for you. The default branch name that Git uses is master (this will be changed to main later). The Git-hosting ecosystem has settled on using main to replace master . When you create a new repository on say GitHub or GitLab, you'll get a main branch as your base branch. We've replaced master with main in our documentation where possible. A branch name has no special meaning within the Git program, it's just a name. The base branch could be called trunk or mainline or prod , and Git would work just as well. What if I need to .. ? \u00b6 Troubleshoot Renovate \u00b6 If you have problems with Renovate, or need to know where Renovate keeps the logging output then read our troubleshooting documentation . Tell Renovate to ask for approval before creating a Pull Request \u00b6 The default behavior is that Renovate creates a pull request right away whenever there's an update. But maybe you want Renovate to ask for your approval before it creates a pull request. Use the \"Dependency Dashboard approval\" workflow to get updates for certain packages - or certain types of updates - only after you give approval via the Dependency Dashboard. The basic idea is that you create a new packageRules entry and describe what kind of package, or type of updates you want to approve beforehand. Say you want to manually approve all major npm package manager updates: { \"packageRules\" : [ { \"matchUpdateTypes\" : [ \"major\" ], \"matchManagers\" : [ \"npm\" ], \"dependencyDashboardApproval\" : true } ] } Or say you want to manually approve all major Jest updates: { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"^jest\" ], \"matchUpdateTypes\" : [ \"major\" ], \"dependencyDashboardApproval\" : true } ] } You could even configure Renovate bot to ask for approval for all updates. The dependencyDashboardApproval is not part of a packageRules array, and so applies to all updates: { \"dependencyDashboardApproval\" : true } Read our documentation on the dependencyDashboardApproval config option. Use an alternative branch as my Pull Request target \u00b6 Say your repository's default branch is main but you want Renovate to use the next branch as its PR target. You can configure the PR target branch via the baseBranches option. Add this line to the renovate.json file that's in the default branch ( main in this example). { \"baseBranches\" : [ \"next\" ] } You can set more than one PR target branch in the baseBranches array. Support private npm modules \u00b6 See the dedicated Private npm module support page. Control Renovate's schedule \u00b6 To learn all about controlling Renovate schedule, read the key concepts, scheduling docs. Disable Renovate for certain dependency types \u00b6 Define a packageRules entry which has the dependency type(s) in matchDepTypes and \"enabled\": false . Use a single branch/PR for all dependency upgrades \u00b6 Add a configuration for configuration option groupName set to value \"all\" , at the top level of your renovate.json or package.json . Use separate branches per dependency, but not one per major release \u00b6 Set configuration option separateMajorMinor to false . Keep using SemVer ranges, instead of pinning dependencies \u00b6 Set configuration option rangeStrategy to \"replace\" . Keep lock files (including sub-dependencies) up-to-date, even when package.json hasn't changed \u00b6 By default, if you enable lock-file maintenance, Renovate will update the lockfile [\"before 5am on monday\"] . If you want to update the lock file more often, update the schedule field inside the lockFileMaintenance object. Wait until tests have passed before creating the PR \u00b6 Set the configuration option prCreation to \"status-success\" . Branches with failing tests will remain in Git and continue to get updated if necessary, but no PR will be created until their tests pass. Wait until tests have passed before creating a PR, but create the PR even if they fail \u00b6 Set the configuration option prCreation to \"not-pending\" . Assign PRs to specific user(s) \u00b6 Set the configuration option assignees to an array of usernames. Add labels to PRs \u00b6 Set the configuration option labels to an array of labels to use. Apply a rule, but only to package abc ? \u00b6 Add a packageRules array to your configuration Create one object inside this array Set field matchPackageNames to value [\"abc\"] Add the configuration option to the same object e.g. { \"packageRules\" : [ { \"matchPackageNames\" : [ \"abc\" ], \"assignees\" : [ \"importantreviewer\" ] } ] } Apply a rule, but only for packages starting with abc \u00b6 Do the same as above, but instead of using matchPackageNames , use matchPackagePatterns and a regex: { \"packageRules\" : [ { \"matchPackagePatterns\" : \"^abc\" , \"assignees\" : [ \"importantreviewer\" ] } ] } Group all packages starting with abc together in one PR \u00b6 As above, but apply a groupName : { \"packageRules\" : [ { \"matchPackagePatterns\" : \"^abc\" , \"groupName\" : [ \"abc packages\" ] } ] } Change the default values for branch name, commit message, PR title or PR description \u00b6 You can use the branchName , commitMessage , prTitle or prBody configuration options to change the defaults for those settings. Automatically merge passing Pull Requests \u00b6 Set the configuration option automerge to true . Nest it inside config objects patch or minor if you want it to apply to certain types only. Separate patch releases from minor releases \u00b6 Renovate's default behavior for major/minor releases \u00b6 Renovate's default behavior is to separate major and minor releases, patch releases are also considered \"minor\". Let's explain the default behavior with an example: Say you are using a package foo , it's the 0.8.0 version. The foo maintainers then release the following versions: 0.8.1 (patch) 0.9.0 (minor) 1.0.0 (major) Renovate would then open the following PRs: Update dependency foo to 0.9.0 (minor) Update dependency foo to 1.0.0 (major) Note how Renovate groups the patch and minor versions together into one PR. This means you only get a PR for the minor version, 0.9.0 . You can override the default behavior. To learn more read the section below. Overriding the default behavior for major/minor releases \u00b6 You can see in the example above that Renovate won't normally open a PR for the foo patch release. You can tell Renovate to open a separate PR for the patch release by setting separateMinorPatch to true . In both cases, Renovate will open 3 PRs: Update dependency foo to 0.8.1 (patch) Update dependency foo to 0.9.0 (minor) Update dependency foo to 1.0.0 (major) Most people don't want more PRs though. But it can still be handy to get PRs for patches when using automerge: Get daily patch updates which are automerged once tests pass Get weekly updates for minor and major updates The end result would be that you barely notice Renovate during the week, while you still get the benefits of patch level updates.","title":"Frequently Asked Questions"},{"location":"faq/#frequently-asked-questions-faq","text":"","title":"Frequently Asked Questions (FAQ)"},{"location":"faq/#what-is-the-default-behavior","text":"Renovate will: Look for configuration options in a configuration file (e.g. renovate.json ) and in each package.json file Find and process all package files (e.g. package.json , composer.json , Dockerfile , etc) in each repository Use separate branches/PR for each dependency Use separate branches for each major version of each dependency Pin devDependencies to a single version, rather than use ranges Pin dependencies to a single version if it appears not to be a library Update yarn.lock and/or package-lock.json files if found Create Pull Requests immediately after branch creation","title":"What is the default behavior?"},{"location":"faq/#which-renovate-versions-are-officially-supported","text":"The Renovate maintainers only support the latest version of Renovate. The Renovate team will only fix bugs for an older version if the hosted app needs to stay on an older major version for a short time or if some critical bug needs to be fixed and the new major is blocked. If you're using the hosted app, you don't need to do anything, as the Renovate maintainers update the hosted app regularly. If you're self hosting Renovate, use the latest release if possible.","title":"Which Renovate versions are officially supported?"},{"location":"faq/#renovate-core-features-not-supported-on-all-platforms","text":"Feature Platforms which lack feature See Renovate issue(s) Dependency Dashboard BitBucket, BitBucket Server, Azure #9592 Hosted app GitLab, BitBucket, BitBucket Server, Azure, Gitea","title":"Renovate core features not supported on all platforms"},{"location":"faq/#major-platform-features-not-supported-by-renovate","text":"Some major platform features are not supported at all by Renovate. Feature name Platform See Renovate issue(s) Jira issues BitBucket #3796 Merge trains GitLab #5573 Configurable merge strategy and message Only BitBucket for now #10867 #10868 #10869 #10870","title":"Major platform features not supported by Renovate"},{"location":"faq/#what-is-this-main-branch-i-see-in-the-documentation","text":"When you create a new repository with Git, Git creates a base branch for you. The default branch name that Git uses is master (this will be changed to main later). The Git-hosting ecosystem has settled on using main to replace master . When you create a new repository on say GitHub or GitLab, you'll get a main branch as your base branch. We've replaced master with main in our documentation where possible. A branch name has no special meaning within the Git program, it's just a name. The base branch could be called trunk or mainline or prod , and Git would work just as well.","title":"What is this main branch I see in the documentation?"},{"location":"faq/#what-if-i-need-to","text":"","title":"What if I need to .. ?"},{"location":"faq/#troubleshoot-renovate","text":"If you have problems with Renovate, or need to know where Renovate keeps the logging output then read our troubleshooting documentation .","title":"Troubleshoot Renovate"},{"location":"faq/#tell-renovate-to-ask-for-approval-before-creating-a-pull-request","text":"The default behavior is that Renovate creates a pull request right away whenever there's an update. But maybe you want Renovate to ask for your approval before it creates a pull request. Use the \"Dependency Dashboard approval\" workflow to get updates for certain packages - or certain types of updates - only after you give approval via the Dependency Dashboard. The basic idea is that you create a new packageRules entry and describe what kind of package, or type of updates you want to approve beforehand. Say you want to manually approve all major npm package manager updates: { \"packageRules\" : [ { \"matchUpdateTypes\" : [ \"major\" ], \"matchManagers\" : [ \"npm\" ], \"dependencyDashboardApproval\" : true } ] } Or say you want to manually approve all major Jest updates: { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"^jest\" ], \"matchUpdateTypes\" : [ \"major\" ], \"dependencyDashboardApproval\" : true } ] } You could even configure Renovate bot to ask for approval for all updates. The dependencyDashboardApproval is not part of a packageRules array, and so applies to all updates: { \"dependencyDashboardApproval\" : true } Read our documentation on the dependencyDashboardApproval config option.","title":"Tell Renovate to ask for approval before creating a Pull Request"},{"location":"faq/#use-an-alternative-branch-as-my-pull-request-target","text":"Say your repository's default branch is main but you want Renovate to use the next branch as its PR target. You can configure the PR target branch via the baseBranches option. Add this line to the renovate.json file that's in the default branch ( main in this example). { \"baseBranches\" : [ \"next\" ] } You can set more than one PR target branch in the baseBranches array.","title":"Use an alternative branch as my Pull Request target"},{"location":"faq/#support-private-npm-modules","text":"See the dedicated Private npm module support page.","title":"Support private npm modules"},{"location":"faq/#control-renovates-schedule","text":"To learn all about controlling Renovate schedule, read the key concepts, scheduling docs.","title":"Control Renovate's schedule"},{"location":"faq/#disable-renovate-for-certain-dependency-types","text":"Define a packageRules entry which has the dependency type(s) in matchDepTypes and \"enabled\": false .","title":"Disable Renovate for certain dependency types"},{"location":"faq/#use-a-single-branchpr-for-all-dependency-upgrades","text":"Add a configuration for configuration option groupName set to value \"all\" , at the top level of your renovate.json or package.json .","title":"Use a single branch/PR for all dependency upgrades"},{"location":"faq/#use-separate-branches-per-dependency-but-not-one-per-major-release","text":"Set configuration option separateMajorMinor to false .","title":"Use separate branches per dependency, but not one per major release"},{"location":"faq/#keep-using-semver-ranges-instead-of-pinning-dependencies","text":"Set configuration option rangeStrategy to \"replace\" .","title":"Keep using SemVer ranges, instead of pinning dependencies"},{"location":"faq/#keep-lock-files-including-sub-dependencies-up-to-date-even-when-packagejson-hasnt-changed","text":"By default, if you enable lock-file maintenance, Renovate will update the lockfile [\"before 5am on monday\"] . If you want to update the lock file more often, update the schedule field inside the lockFileMaintenance object.","title":"Keep lock files (including sub-dependencies) up-to-date, even when package.json hasn't changed"},{"location":"faq/#wait-until-tests-have-passed-before-creating-the-pr","text":"Set the configuration option prCreation to \"status-success\" . Branches with failing tests will remain in Git and continue to get updated if necessary, but no PR will be created until their tests pass.","title":"Wait until tests have passed before creating the PR"},{"location":"faq/#wait-until-tests-have-passed-before-creating-a-pr-but-create-the-pr-even-if-they-fail","text":"Set the configuration option prCreation to \"not-pending\" .","title":"Wait until tests have passed before creating a PR, but create the PR even if they fail"},{"location":"faq/#assign-prs-to-specific-users","text":"Set the configuration option assignees to an array of usernames.","title":"Assign PRs to specific user(s)"},{"location":"faq/#add-labels-to-prs","text":"Set the configuration option labels to an array of labels to use.","title":"Add labels to PRs"},{"location":"faq/#apply-a-rule-but-only-to-package-abc","text":"Add a packageRules array to your configuration Create one object inside this array Set field matchPackageNames to value [\"abc\"] Add the configuration option to the same object e.g. { \"packageRules\" : [ { \"matchPackageNames\" : [ \"abc\" ], \"assignees\" : [ \"importantreviewer\" ] } ] }","title":"Apply a rule, but only to package abc?"},{"location":"faq/#apply-a-rule-but-only-for-packages-starting-with-abc","text":"Do the same as above, but instead of using matchPackageNames , use matchPackagePatterns and a regex: { \"packageRules\" : [ { \"matchPackagePatterns\" : \"^abc\" , \"assignees\" : [ \"importantreviewer\" ] } ] }","title":"Apply a rule, but only for packages starting with abc"},{"location":"faq/#group-all-packages-starting-with-abc-together-in-one-pr","text":"As above, but apply a groupName : { \"packageRules\" : [ { \"matchPackagePatterns\" : \"^abc\" , \"groupName\" : [ \"abc packages\" ] } ] }","title":"Group all packages starting with abc together in one PR"},{"location":"faq/#change-the-default-values-for-branch-name-commit-message-pr-title-or-pr-description","text":"You can use the branchName , commitMessage , prTitle or prBody configuration options to change the defaults for those settings.","title":"Change the default values for branch name, commit message, PR title or PR description"},{"location":"faq/#automatically-merge-passing-pull-requests","text":"Set the configuration option automerge to true . Nest it inside config objects patch or minor if you want it to apply to certain types only.","title":"Automatically merge passing Pull Requests"},{"location":"faq/#separate-patch-releases-from-minor-releases","text":"","title":"Separate patch releases from minor releases"},{"location":"faq/#renovates-default-behavior-for-majorminor-releases","text":"Renovate's default behavior is to separate major and minor releases, patch releases are also considered \"minor\". Let's explain the default behavior with an example: Say you are using a package foo , it's the 0.8.0 version. The foo maintainers then release the following versions: 0.8.1 (patch) 0.9.0 (minor) 1.0.0 (major) Renovate would then open the following PRs: Update dependency foo to 0.9.0 (minor) Update dependency foo to 1.0.0 (major) Note how Renovate groups the patch and minor versions together into one PR. This means you only get a PR for the minor version, 0.9.0 . You can override the default behavior. To learn more read the section below.","title":"Renovate's default behavior for major/minor releases"},{"location":"faq/#overriding-the-default-behavior-for-majorminor-releases","text":"You can see in the example above that Renovate won't normally open a PR for the foo patch release. You can tell Renovate to open a separate PR for the patch release by setting separateMinorPatch to true . In both cases, Renovate will open 3 PRs: Update dependency foo to 0.8.1 (patch) Update dependency foo to 0.9.0 (minor) Update dependency foo to 1.0.0 (major) Most people don't want more PRs though. But it can still be handy to get PRs for patches when using automerge: Get daily patch updates which are automerged once tests pass Get weekly updates for minor and major updates The end result would be that you barely notice Renovate during the week, while you still get the benefits of patch level updates.","title":"Overriding the default behavior for major/minor releases"},{"location":"gitlab-bot-security/","text":"GitLab bot security \u00b6 You should understand GitLab's security model, before deciding to run a \"bot\" service like Renovate on GitLab, particularly the pipeline credentials. Important : If you have any doubts or concerns about this content that could affect other users, please follow our Security Policy and report them confidentially. CI_JOB_TOKEN permissions \u00b6 The concept of CI_JOB_TOKEN permissions was overhauled in GitLab release 8.12 , jobs are now run with the permissions of the user account which triggered the pipeline. For security reasons the token was limited to read-only permissions and a limited set of API endpoints, but it\u2019s been extended to allow write access to the GitLab Package Registry . Any pipeline triggered by a user account thus has permissions to read any repository which that account has access to as well as publish packages to them. With the current GitLab CI permissions model, you should avoid committing to any project which you don\u2019t trust completely, because that project could maliciously steal repository data, publish fake releases, or spam releases. Risks of hosting a Renovate GitLab app/bot/service \u00b6 The GitLab security model means that the risks of running a public bot service on GitLab are too high, which is why the existing service has been suspended until an alternate security model is ready. It's also important to remember that when accounts are invited into projects or groups on GitLab, acceptance happens automatically (which was a useful feature to leverage for a shared service). If you are running a self-hosted Renovate service, it is advisable to: Run a shared service only within projects which have shared visibility/security within the users, or which have a low risk that a user would try to gain access to a private project they don't otherwise have access to If running with autodiscover , also configure a value for autodiscoverFilter so that the bot can't be invited to projects or groups you don't intend Security solutions and workarounds \u00b6 The following research notes may help you to assess the GitLab bot security risk. Public projects only \u00b6 If a bot service is run on public projects only, then the risk of private project data being accessed by unauthorized users is zero. But malicious users can still spoof or spam packages to any other public project they are not a member of, so that rules out this approach for a public hosted service. A public-visibility-only bot service should be low risk for most self-hosted GitLab instances. There is still a small problem that you can't prevent users from inviting the bot into private projects if they are not aware of the risks of doing so. Project Access Tokens \u00b6 Project Access Tokens are a recently added feature for GitLab. The main downsides to their use for a shared bot service are: It is not yet possible to provision them through the API , so project maintainers would need to provision a project bot account and then save it to Renovate manually and per-project Project Access Tokens are a paid-only feature for gitlab.com, which excludes a large percentage of the public service user base At the time of writing, there are still some issues with getting Project Access Tokens to trigger and authenticate CI Any service using such tokens would get MRs from a user like @project_123_bot which is less intuitive than @renovate-bot The big benefit of Project Access Tokens is their limited scope, users with write access to one project cannot read/write to other projects. Group Access Tokens \u00b6 Group Access Tokens are still in the planning stage, but may offer a more scalable way to manage a Renovate service. Tokens could be provisioned into Renovate per-group and permissions/visibility would need to be kept uniform throughout the group to ensure escalation of privileges is not possible. It should be noted though that many GitLab users do not have uniform permissions/visibility throughout groups today, so this is a risk of Group Access Tokens in general. Even https://gitlab.com/gitlab-org is a good example of how common it is to mix project visibility within a same group. Similarly with Project Access Tokens, if they are a paid-only feature then it would exclude free users from using such a service. Skipping CI \u00b6 The security problem described above is that if a user triggers a malicious pipeline then they can be exploited, so skipping CI altogether would seem to be a way to avoid that. If Renovate can reliably force CI skipping for both (a) branch push, and (b) MR creation/updating then there should be no security exploit risk, but of course then there are no tests run instead. A possibility in future could be to combine this with a force push from a user or project token to trigger tests. The above solution/workaround will be actively researched in collaboration with GitLab. OAuth \u00b6 An alternative to a bot service running with a bot PAT would be to have it run using user OAuth tokens. In this scenario, an OAuth app would be needed to allow users to \"install\" the bot into projects with members they trust not to exploit them, and then commits and Merge Requests would appear to be authored by the user , not any bot. Bot services are better if they are provisioned with a \"bot identity\" so that users can quickly distinguish bot activity from real user activity. Recommended migration \u00b6 Until the hosted app can be reactivated, we recommend users migrate to use self-hosted pipelines to run Renovate. Please see the renovate-bot/renovate-runner README on GitLab for instructions on how to set this up as easily as possible. Status of the Renovate app for GitLab \u00b6 We're trying to find a workable design for the GitLab app, so we can enable it safely again. If you have any ideas, open a discussion and let us know! GitLab introduced Group Access Tokens & API for paid & self-hosted instances, but a good permission setup/flow is still not possible. Check out GitLab issue #346298 . Acknowledgments \u00b6 Thank you to Nejc Habjan for bringing this security challenge to our attention, and also to his colleagues at Siemens for their help researching the risks. Thanks also to the GitLab security team for being responsive to our questions.","title":"GitLab bot security"},{"location":"gitlab-bot-security/#gitlab-bot-security","text":"You should understand GitLab's security model, before deciding to run a \"bot\" service like Renovate on GitLab, particularly the pipeline credentials. Important : If you have any doubts or concerns about this content that could affect other users, please follow our Security Policy and report them confidentially.","title":"GitLab bot security"},{"location":"gitlab-bot-security/#ci_job_token-permissions","text":"The concept of CI_JOB_TOKEN permissions was overhauled in GitLab release 8.12 , jobs are now run with the permissions of the user account which triggered the pipeline. For security reasons the token was limited to read-only permissions and a limited set of API endpoints, but it\u2019s been extended to allow write access to the GitLab Package Registry . Any pipeline triggered by a user account thus has permissions to read any repository which that account has access to as well as publish packages to them. With the current GitLab CI permissions model, you should avoid committing to any project which you don\u2019t trust completely, because that project could maliciously steal repository data, publish fake releases, or spam releases.","title":"CI_JOB_TOKEN permissions"},{"location":"gitlab-bot-security/#risks-of-hosting-a-renovate-gitlab-appbotservice","text":"The GitLab security model means that the risks of running a public bot service on GitLab are too high, which is why the existing service has been suspended until an alternate security model is ready. It's also important to remember that when accounts are invited into projects or groups on GitLab, acceptance happens automatically (which was a useful feature to leverage for a shared service). If you are running a self-hosted Renovate service, it is advisable to: Run a shared service only within projects which have shared visibility/security within the users, or which have a low risk that a user would try to gain access to a private project they don't otherwise have access to If running with autodiscover , also configure a value for autodiscoverFilter so that the bot can't be invited to projects or groups you don't intend","title":"Risks of hosting a Renovate GitLab app/bot/service"},{"location":"gitlab-bot-security/#security-solutions-and-workarounds","text":"The following research notes may help you to assess the GitLab bot security risk.","title":"Security solutions and workarounds"},{"location":"gitlab-bot-security/#public-projects-only","text":"If a bot service is run on public projects only, then the risk of private project data being accessed by unauthorized users is zero. But malicious users can still spoof or spam packages to any other public project they are not a member of, so that rules out this approach for a public hosted service. A public-visibility-only bot service should be low risk for most self-hosted GitLab instances. There is still a small problem that you can't prevent users from inviting the bot into private projects if they are not aware of the risks of doing so.","title":"Public projects only"},{"location":"gitlab-bot-security/#project-access-tokens","text":"Project Access Tokens are a recently added feature for GitLab. The main downsides to their use for a shared bot service are: It is not yet possible to provision them through the API , so project maintainers would need to provision a project bot account and then save it to Renovate manually and per-project Project Access Tokens are a paid-only feature for gitlab.com, which excludes a large percentage of the public service user base At the time of writing, there are still some issues with getting Project Access Tokens to trigger and authenticate CI Any service using such tokens would get MRs from a user like @project_123_bot which is less intuitive than @renovate-bot The big benefit of Project Access Tokens is their limited scope, users with write access to one project cannot read/write to other projects.","title":"Project Access Tokens"},{"location":"gitlab-bot-security/#group-access-tokens","text":"Group Access Tokens are still in the planning stage, but may offer a more scalable way to manage a Renovate service. Tokens could be provisioned into Renovate per-group and permissions/visibility would need to be kept uniform throughout the group to ensure escalation of privileges is not possible. It should be noted though that many GitLab users do not have uniform permissions/visibility throughout groups today, so this is a risk of Group Access Tokens in general. Even https://gitlab.com/gitlab-org is a good example of how common it is to mix project visibility within a same group. Similarly with Project Access Tokens, if they are a paid-only feature then it would exclude free users from using such a service.","title":"Group Access Tokens"},{"location":"gitlab-bot-security/#skipping-ci","text":"The security problem described above is that if a user triggers a malicious pipeline then they can be exploited, so skipping CI altogether would seem to be a way to avoid that. If Renovate can reliably force CI skipping for both (a) branch push, and (b) MR creation/updating then there should be no security exploit risk, but of course then there are no tests run instead. A possibility in future could be to combine this with a force push from a user or project token to trigger tests. The above solution/workaround will be actively researched in collaboration with GitLab.","title":"Skipping CI"},{"location":"gitlab-bot-security/#oauth","text":"An alternative to a bot service running with a bot PAT would be to have it run using user OAuth tokens. In this scenario, an OAuth app would be needed to allow users to \"install\" the bot into projects with members they trust not to exploit them, and then commits and Merge Requests would appear to be authored by the user , not any bot. Bot services are better if they are provisioned with a \"bot identity\" so that users can quickly distinguish bot activity from real user activity.","title":"OAuth"},{"location":"gitlab-bot-security/#recommended-migration","text":"Until the hosted app can be reactivated, we recommend users migrate to use self-hosted pipelines to run Renovate. Please see the renovate-bot/renovate-runner README on GitLab for instructions on how to set this up as easily as possible.","title":"Recommended migration"},{"location":"gitlab-bot-security/#status-of-the-renovate-app-for-gitlab","text":"We're trying to find a workable design for the GitLab app, so we can enable it safely again. If you have any ideas, open a discussion and let us know! GitLab introduced Group Access Tokens & API for paid & self-hosted instances, but a good permission setup/flow is still not possible. Check out GitLab issue #346298 .","title":"Status of the Renovate app for GitLab"},{"location":"gitlab-bot-security/#acknowledgments","text":"Thank you to Nejc Habjan for bringing this security challenge to our attention, and also to his colleagues at Siemens for their help researching the risks. Thanks also to the GitLab security team for being responsive to our questions.","title":"Acknowledgments"},{"location":"golang/","text":"Automated Dependency Updates for Go Modules \u00b6 Renovate supports upgrading dependencies in go.mod files and their accompanying go.sum checksums. How It Works \u00b6 Renovate searches in each repository for any go.mod files Renovate extracts existing dependencies from require statements Renovate resolves the dependency's source repository and checks for SemVer tags if found. Otherwise commits and v0.0.0-.... syntax will be used If Renovate finds an update, Renovate will update go.mod to the new value Renovate runs go get to update the go.sum files If the user has enabled the option gomodUpdateImportPaths in the postUpdateOptions array, then Renovate uses mod to update import paths on major updates, which can update any Go source file If the user has enabled the option gomodTidy or gomodTidy1.17 in the postUpdateOptions array, then Renovate runs go mod tidy or go mod tidy -compat=1.17 respectively, which itself can update go.mod and go.sum . gomodTidy is implicitly enabled for major updates if the user has enabled the option gomodUpdateImportPaths in the postUpdateOptions array. If go modules 1.17 compatibility is needed you need to explicitly set the option gomodTidy1.17 . go mod vendor is run if vendored modules are detected A PR will be created with go.mod , go.sum , and any updated vendored files updated in the one commit If the source repository has either a \"changelog\" file or uses GitHub releases, then Release Notes for each version will be embedded in the generated PR Enabling Go Modules Updating \u00b6 Renovate updates Go Modules by default. To install Renovate Bot itself, either enable the Renovate App on GitHub, or check out Renovate OSS for self-hosted. Technical Details \u00b6 Replace massaging \u00b6 Renovate can massage replace statements it finds prior to running go commands, and then massage them back afterwards. This capability was added - and originally default behavior - because relative replace statements outside of the current repo will not work when Renovate clones the repo locally. On the other hand, this massaging of replace statements may lead to unexpected results, especially because go mod tidy may not fully tidy the go.sum if it is missing the replace directives in go.mod . It has therefore been disabled by default. To enable this replace massaging behavior, add gomodMassage to your postUpdateOptions array. Module Tidying \u00b6 Go Modules tidying is not enabled by default, and is opt-in via the postUpdateOptions config option. The reason for this is that a go mod tidy command may make changes to go.mod and go.sum that are completely unrelated to the updated module(s) in the PR, and so may be confusing to some users. Module Vendoring \u00b6 Vendoring of Go Modules is done automatically if vendor/modules.txt is present. Renovate will commit all files changed within the vendor/ folder. Go binary version \u00b6 By default, Renovate will keep up with the latest version of the go binary. You can force Renovate to use a specific version of Go by setting a constraint. As an example, say you want Renovate to use the latest patch version of the 1.16 Go binary, you'd put this in your Renovate config: { \"constraints\" : { \"go\" : \"1.16\" } } We do not support patch level versions for the minimum go version. This means you cannot use go 1.16.6 , but you can use go 1.16 as a constraint. Custom registry support, and authentication \u00b6 This example shows how you can use a hostRules configuration to configure Renovate for use with a custom private Go module source using Git to pull the modules when updating go.sum and vendored modules. All token hostRules with a hostType (e.g. github , gitlab , bitbucket , ... ) and host rules without a hostType are setup for authentication. module . exports = { hostRules : [ { matchHost : 'github.enterprise.com' , token : process . env . GO_GITHUB_TOKEN , hostType : 'github' , }, { matchHost : 'someGitHost.enterprise.com' , token : process . env . GO_GIT_TOKEN , }, ], };","title":"Golang"},{"location":"golang/#automated-dependency-updates-for-go-modules","text":"Renovate supports upgrading dependencies in go.mod files and their accompanying go.sum checksums.","title":"Automated Dependency Updates for Go Modules"},{"location":"golang/#how-it-works","text":"Renovate searches in each repository for any go.mod files Renovate extracts existing dependencies from require statements Renovate resolves the dependency's source repository and checks for SemVer tags if found. Otherwise commits and v0.0.0-.... syntax will be used If Renovate finds an update, Renovate will update go.mod to the new value Renovate runs go get to update the go.sum files If the user has enabled the option gomodUpdateImportPaths in the postUpdateOptions array, then Renovate uses mod to update import paths on major updates, which can update any Go source file If the user has enabled the option gomodTidy or gomodTidy1.17 in the postUpdateOptions array, then Renovate runs go mod tidy or go mod tidy -compat=1.17 respectively, which itself can update go.mod and go.sum . gomodTidy is implicitly enabled for major updates if the user has enabled the option gomodUpdateImportPaths in the postUpdateOptions array. If go modules 1.17 compatibility is needed you need to explicitly set the option gomodTidy1.17 . go mod vendor is run if vendored modules are detected A PR will be created with go.mod , go.sum , and any updated vendored files updated in the one commit If the source repository has either a \"changelog\" file or uses GitHub releases, then Release Notes for each version will be embedded in the generated PR","title":"How It Works"},{"location":"golang/#enabling-go-modules-updating","text":"Renovate updates Go Modules by default. To install Renovate Bot itself, either enable the Renovate App on GitHub, or check out Renovate OSS for self-hosted.","title":"Enabling Go Modules Updating"},{"location":"golang/#technical-details","text":"","title":"Technical Details"},{"location":"golang/#replace-massaging","text":"Renovate can massage replace statements it finds prior to running go commands, and then massage them back afterwards. This capability was added - and originally default behavior - because relative replace statements outside of the current repo will not work when Renovate clones the repo locally. On the other hand, this massaging of replace statements may lead to unexpected results, especially because go mod tidy may not fully tidy the go.sum if it is missing the replace directives in go.mod . It has therefore been disabled by default. To enable this replace massaging behavior, add gomodMassage to your postUpdateOptions array.","title":"Replace massaging"},{"location":"golang/#module-tidying","text":"Go Modules tidying is not enabled by default, and is opt-in via the postUpdateOptions config option. The reason for this is that a go mod tidy command may make changes to go.mod and go.sum that are completely unrelated to the updated module(s) in the PR, and so may be confusing to some users.","title":"Module Tidying"},{"location":"golang/#module-vendoring","text":"Vendoring of Go Modules is done automatically if vendor/modules.txt is present. Renovate will commit all files changed within the vendor/ folder.","title":"Module Vendoring"},{"location":"golang/#go-binary-version","text":"By default, Renovate will keep up with the latest version of the go binary. You can force Renovate to use a specific version of Go by setting a constraint. As an example, say you want Renovate to use the latest patch version of the 1.16 Go binary, you'd put this in your Renovate config: { \"constraints\" : { \"go\" : \"1.16\" } } We do not support patch level versions for the minimum go version. This means you cannot use go 1.16.6 , but you can use go 1.16 as a constraint.","title":"Go binary version"},{"location":"golang/#custom-registry-support-and-authentication","text":"This example shows how you can use a hostRules configuration to configure Renovate for use with a custom private Go module source using Git to pull the modules when updating go.sum and vendored modules. All token hostRules with a hostType (e.g. github , gitlab , bitbucket , ... ) and host rules without a hostType are setup for authentication. module . exports = { hostRules : [ { matchHost : 'github.enterprise.com' , token : process . env . GO_GITHUB_TOKEN , hostType : 'github' , }, { matchHost : 'someGitHost.enterprise.com' , token : process . env . GO_GIT_TOKEN , }, ], };","title":"Custom registry support, and authentication"},{"location":"java/","text":"Java Dependency Updates \u00b6 Renovate can update Gradle and Maven dependencies. This includes libraries and plugins as well as the Gradle Wrapper. Gradle \u00b6 Renovate detects versions that are specified in a string 'group:artifact:version' and those specified in a map (group:groupName, name:ArtifactName, version:Version) . Gradle File Support \u00b6 Renovate can update: build.gradle / build.gradle.kts files in the root of the repository *.gradle / *.gradle.kts files in a subdirectory as multi-project configurations dependencies whose version is defined in a *.properties file *.versions.toml files in any directory or *.toml files inside the gradle directory ( Gradle Version Catalogs docs ) Renovate does not support: Projects which do not have either a build.gradle or build.gradle.kts in the repository root Android projects that require extra configuration to run (e.g. setting the Android SDK) Gradle versions older than version 5.0 Catalogs defined inside a build.gradle or build.gradle.kts file rather than in TOML Catalogs with version ranges Catalogs versions using reject , and rejectAll constraints Catalogs versions using more than one of require , strictly , prefer in a single declaration Catalogs with custom names that do not end in .toml Catalogs outside the gradle folder whose names do not end in .versions.toml Gradle Wrapper \u00b6 Renovate can update the Gradle Wrapper of a project. This includes the source declaration inside the gradle/wrapper/gradle-wrapper.properties as well as accompanied files such as gradlew , gradlew.bat , and gradle/wrapper/gradle-wrapper.jar . How It Works \u00b6 Renovate extracts the Gradle Wrapper version used from the distributionUrl inside the gradle-wrapper.properties . Once the version is determined, Renovate will look for newer versions from the gradle-version datasource. Renovate will then invoke the Gradle Wrapper to update itself, as recommended by Gradle . For the extraction to work, the distributionUrl must point to a file of type .zip , which includes the version in its name, and defines one of the official distribution types (bin, all). Support for mirrors and custom distributions \u00b6 As Renovate takes the distributionUrl defined inside the gradle-wrapper.properties as basis for its update, source declarations other than to the official Gradle Wrapper are supported. This can be used for hosting the official distributions with a proxy server, an offline mirror or even providing a custom distribution of the Gradle Wrapper, e.g. to provide a company-wide base configuration for all Gradle projects. But the gradle-version datasource is used to determine available versions. In case the available versions at the defined source differ from those available from Gradle or the default datasource cannot be reached, e.g. due to network restrictions, the datasource may be reconfigured via a packageRule : { \"packageRules\" : [ { \"matchDatasources\" : [ \"gradle-version\" ], \"registryUrls\" : [ \"https://domain.tld/repository/custom-gradle-wrapper/versions.json\" ] } ] } Maven \u00b6 Renovate can update dependency versions found in Maven pom.xml files. Maven File Support \u00b6 Renovate will search repositories for all pom.xml files and processes them independently. Renovate will also parse settings.xml files in the following locations: .mvn/settings.xml .m2/settings.xml settings.xml Any repository URLs found within will be added as registryUrls to extracted dependencies. Custom registry support, and authentication \u00b6 The manager for Gradle makes use of the maven datasource. Renovate can be configured to access additional repositories and access repositories authenticated. This example shows how you can use a config.js file to configure Renovate for use with Artifactory. We're using environment variables to pass the Artifactory username and password to Renovate bot. module . exports = { hostRules : [ { hostType : 'maven' , matchHost : 'https://artifactory.yourcompany.com/' , username : process . env . ARTIFACTORY_USERNAME , password : process . env . ARTIFACTORY_PASSWORD , }, ], }; You can overwrite the repositories to use for version lookup through configuration. module . exports = { packageRules : [ { matchDatasources : [ 'maven' ], registryUrls : [ 'https://repo-a.tld/repo' , 'https://repo-b.tld/repo' ], }, ], };","title":"Java"},{"location":"java/#java-dependency-updates","text":"Renovate can update Gradle and Maven dependencies. This includes libraries and plugins as well as the Gradle Wrapper.","title":"Java Dependency Updates"},{"location":"java/#gradle","text":"Renovate detects versions that are specified in a string 'group:artifact:version' and those specified in a map (group:groupName, name:ArtifactName, version:Version) .","title":"Gradle"},{"location":"java/#gradle-file-support","text":"Renovate can update: build.gradle / build.gradle.kts files in the root of the repository *.gradle / *.gradle.kts files in a subdirectory as multi-project configurations dependencies whose version is defined in a *.properties file *.versions.toml files in any directory or *.toml files inside the gradle directory ( Gradle Version Catalogs docs ) Renovate does not support: Projects which do not have either a build.gradle or build.gradle.kts in the repository root Android projects that require extra configuration to run (e.g. setting the Android SDK) Gradle versions older than version 5.0 Catalogs defined inside a build.gradle or build.gradle.kts file rather than in TOML Catalogs with version ranges Catalogs versions using reject , and rejectAll constraints Catalogs versions using more than one of require , strictly , prefer in a single declaration Catalogs with custom names that do not end in .toml Catalogs outside the gradle folder whose names do not end in .versions.toml","title":"Gradle File Support"},{"location":"java/#gradle-wrapper","text":"Renovate can update the Gradle Wrapper of a project. This includes the source declaration inside the gradle/wrapper/gradle-wrapper.properties as well as accompanied files such as gradlew , gradlew.bat , and gradle/wrapper/gradle-wrapper.jar .","title":"Gradle Wrapper"},{"location":"java/#how-it-works","text":"Renovate extracts the Gradle Wrapper version used from the distributionUrl inside the gradle-wrapper.properties . Once the version is determined, Renovate will look for newer versions from the gradle-version datasource. Renovate will then invoke the Gradle Wrapper to update itself, as recommended by Gradle . For the extraction to work, the distributionUrl must point to a file of type .zip , which includes the version in its name, and defines one of the official distribution types (bin, all).","title":"How It Works"},{"location":"java/#support-for-mirrors-and-custom-distributions","text":"As Renovate takes the distributionUrl defined inside the gradle-wrapper.properties as basis for its update, source declarations other than to the official Gradle Wrapper are supported. This can be used for hosting the official distributions with a proxy server, an offline mirror or even providing a custom distribution of the Gradle Wrapper, e.g. to provide a company-wide base configuration for all Gradle projects. But the gradle-version datasource is used to determine available versions. In case the available versions at the defined source differ from those available from Gradle or the default datasource cannot be reached, e.g. due to network restrictions, the datasource may be reconfigured via a packageRule : { \"packageRules\" : [ { \"matchDatasources\" : [ \"gradle-version\" ], \"registryUrls\" : [ \"https://domain.tld/repository/custom-gradle-wrapper/versions.json\" ] } ] }","title":"Support for mirrors and custom distributions"},{"location":"java/#maven","text":"Renovate can update dependency versions found in Maven pom.xml files.","title":"Maven"},{"location":"java/#maven-file-support","text":"Renovate will search repositories for all pom.xml files and processes them independently. Renovate will also parse settings.xml files in the following locations: .mvn/settings.xml .m2/settings.xml settings.xml Any repository URLs found within will be added as registryUrls to extracted dependencies.","title":"Maven File Support"},{"location":"java/#custom-registry-support-and-authentication","text":"The manager for Gradle makes use of the maven datasource. Renovate can be configured to access additional repositories and access repositories authenticated. This example shows how you can use a config.js file to configure Renovate for use with Artifactory. We're using environment variables to pass the Artifactory username and password to Renovate bot. module . exports = { hostRules : [ { hostType : 'maven' , matchHost : 'https://artifactory.yourcompany.com/' , username : process . env . ARTIFACTORY_USERNAME , password : process . env . ARTIFACTORY_PASSWORD , }, ], }; You can overwrite the repositories to use for version lookup through configuration. module . exports = { packageRules : [ { matchDatasources : [ 'maven' ], registryUrls : [ 'https://repo-a.tld/repo' , 'https://repo-b.tld/repo' ], }, ], };","title":"Custom registry support, and authentication"},{"location":"javascript/","text":"JavaScript \u00b6 Renovate supports upgrading JavaScript dependencies specified in package.json files. npm , yarn , and pnpm are all supported.","title":"JavaScript"},{"location":"javascript/#javascript","text":"Renovate supports upgrading JavaScript dependencies specified in package.json files. npm , yarn , and pnpm are all supported.","title":"JavaScript"},{"location":"known-limitations/","text":"Known limitations \u00b6 Learn about the limitations of Renovate bot. Introduction \u00b6 Renovate, like any computer program has limitations. Sometimes these are functionality limitations - perhaps something is impossible or too complex to do, or we simply haven't implemented it yet. At other times it may be a \"performance\" limitation, because jobs neither start nor complete instantly, even if the user may start with that expectation. This document tries to list out the most commonly seen limitations and describe whether they're permanent and if there's any plans to improving the situation. Time/schedule based limitations \u00b6 When a user configures a schedule in their repo config, they may think that this schedule \"controls\" when Renovate runs. In actuality, Renovate may be running frequently, but just skipping updates to the repo if the configured schedule is not met. Additionally, the Renovate admin may have put the bot on its own schedule, or the job queue may be too long, so Renovate doesn't even get a chance to run on your repository during a certain scheduled time window. For scheduled action to take place, both these need to happen: The bot needs to run against your repository The current time needs to fall within your repository's configured schedule For the GitHub hosted app, all active repositories will be enqueued hourly by default, but it's often the case that not every repository gets processed every hour. For this reason, it's best to allow for a minimum 2-3 hours schedule window per run, if you want a high chance that the bot will have run on your repo at least once while the schedule is active. Automerge limitations \u00b6 Renovate automerges at most one branch per run Renovate will only automerge a branch when it is up-to-date with the target branch Renovate may not be able to automerge as many branches as you expect, especially if your base branch is receiving regular commits at the same time The limitation to only merge one branch per run is because Renovate's dependency and branch state is based on what was present in the base branch at the start of the run. If a branch is merged into the base branch during Renovate's run - including by other users - it means that remaining Renovate branches may have Git conflicts. It also means that Renovate's knowledge about dependencies in the base branch is now invalid and other branches may need changing as a result of the merge. The limitation to only automerge branches which are up-to-date is a decision due to this example: Two dependencies are in use: alice@1.0.0 and bob@1.0.0 PRs exist for alice@2.0.0 and bob@2.0.0 and both pass tests The PR for alice@2.0.0 is automerged The PR for bob@2.0.0 remains open, does not have conflicts, and has all tests passing But alice@2.0.0 and bob@2.0.0 are incompatible so merging the PR without rebasing and retesting it first would result in a broken base branch","title":"Known Limitations"},{"location":"known-limitations/#known-limitations","text":"Learn about the limitations of Renovate bot.","title":"Known limitations"},{"location":"known-limitations/#introduction","text":"Renovate, like any computer program has limitations. Sometimes these are functionality limitations - perhaps something is impossible or too complex to do, or we simply haven't implemented it yet. At other times it may be a \"performance\" limitation, because jobs neither start nor complete instantly, even if the user may start with that expectation. This document tries to list out the most commonly seen limitations and describe whether they're permanent and if there's any plans to improving the situation.","title":"Introduction"},{"location":"known-limitations/#timeschedule-based-limitations","text":"When a user configures a schedule in their repo config, they may think that this schedule \"controls\" when Renovate runs. In actuality, Renovate may be running frequently, but just skipping updates to the repo if the configured schedule is not met. Additionally, the Renovate admin may have put the bot on its own schedule, or the job queue may be too long, so Renovate doesn't even get a chance to run on your repository during a certain scheduled time window. For scheduled action to take place, both these need to happen: The bot needs to run against your repository The current time needs to fall within your repository's configured schedule For the GitHub hosted app, all active repositories will be enqueued hourly by default, but it's often the case that not every repository gets processed every hour. For this reason, it's best to allow for a minimum 2-3 hours schedule window per run, if you want a high chance that the bot will have run on your repo at least once while the schedule is active.","title":"Time/schedule based limitations"},{"location":"known-limitations/#automerge-limitations","text":"Renovate automerges at most one branch per run Renovate will only automerge a branch when it is up-to-date with the target branch Renovate may not be able to automerge as many branches as you expect, especially if your base branch is receiving regular commits at the same time The limitation to only merge one branch per run is because Renovate's dependency and branch state is based on what was present in the base branch at the start of the run. If a branch is merged into the base branch during Renovate's run - including by other users - it means that remaining Renovate branches may have Git conflicts. It also means that Renovate's knowledge about dependencies in the base branch is now invalid and other branches may need changing as a result of the merge. The limitation to only automerge branches which are up-to-date is a decision due to this example: Two dependencies are in use: alice@1.0.0 and bob@1.0.0 PRs exist for alice@2.0.0 and bob@2.0.0 and both pass tests The PR for alice@2.0.0 is automerged The PR for bob@2.0.0 remains open, does not have conflicts, and has all tests passing But alice@2.0.0 and bob@2.0.0 are incompatible so merging the PR without rebasing and retesting it first would result in a broken base branch","title":"Automerge limitations"},{"location":"merge-confidence/","text":"Merge Confidence \u00b6 Look at the Merge Confidence badges before merging to: Prevent updates which break in production See at a glance if you should update Merge Confidence finds and flags undeclared breaking releases. It analyzes test and release adoption data across Mend Renovate\u2019s early-adopting user base. Pull request badges \u00b6 Merge Confidence adds the following badges to your pull requests: Age : The age of the package Adoption : The percentage of this package's users (within Renovate) which are using this release Passing : The percentage of updates which have passing tests for this package Confidence : The confidence level for this update Supported platforms \u00b6 Merge Confidence badges for pull requests are available in beta on any supported Renovate platform, including Mend Remediate. Supported languages \u00b6 Data is available for packages from: npm Maven PyPI We plan to support more languages soon. Enabling and disabling \u00b6 If you use the Mend Renovate App (formerly WhiteSource Renovate App) then the badges are enabled automatically. If you don't use the app, you can enable the badges by adding this to your Renovate config: \"extends\" : [ \"github>whitesource/merge-confidence:beta\" ] If you want to disable the badges in the app, add this to your config: \"ignorePresets\" : [ \"github>whitesource/merge-confidence:beta\" ] Confidence levels and their meaning \u00b6 Merge Confidence uses the following confidence levels: Low : We think the update contains breaking changes. Often this is expected because it's a Major version update, but updates can have unknown breaking changes. Neutral : We don't have enough data about the update, or we can't decide if the update should be Low or High confidence. High : We rank updates as High confidence when the combination of Age , Adoption and Passing tests means there's a very low chance of breaking changes. Very High : We only use this for updates which are months old and have either high Adoption or have very high test Passing scores. How it works \u00b6 Mend's hosted Renovate App has created millions of pull requests on github.com to help developers update their dependencies since 2017. We bundle and analyze metrics such as package Age , package Adoption , and Passing tests. This way we can find packages that have undeclared breaking changes. Algorithm \u00b6 The algorithm that decides on the values is private and is not something we plan to share. Similar to a search engine's algorithm, we plan to adjust and improve it over time, for example by using historical data to set a baseline confidence level for packages. Data \u00b6 We plan to expose much more of the data via a companion website, such as number of users of a package and popular repositories which already updated to the version in question. Explanations \u00b6 npm package ranking \u00b6 npm packages less than three days old can be unpublished , which can result in a service impact if you have updated to a package that gets unpublished. This is why npm packages can only get the High Confidence badge when they are at least three days old. Percentage values weighting \u00b6 The percentages for Adoption and Passing are weighted towards Organizations, private repositories, and projects with high test reliability. This means those values aren't raw percentages. Roadmap \u00b6 High-level information on planned improvements is available in the Merge Confidence Roadmap Project on GitHub. Questions and feedback \u00b6 You are invited to create an Issue if you have anything you'd like to discuss.","title":"Merge Confidence"},{"location":"merge-confidence/#merge-confidence","text":"Look at the Merge Confidence badges before merging to: Prevent updates which break in production See at a glance if you should update Merge Confidence finds and flags undeclared breaking releases. It analyzes test and release adoption data across Mend Renovate\u2019s early-adopting user base.","title":"Merge Confidence"},{"location":"merge-confidence/#pull-request-badges","text":"Merge Confidence adds the following badges to your pull requests: Age : The age of the package Adoption : The percentage of this package's users (within Renovate) which are using this release Passing : The percentage of updates which have passing tests for this package Confidence : The confidence level for this update","title":"Pull request badges"},{"location":"merge-confidence/#supported-platforms","text":"Merge Confidence badges for pull requests are available in beta on any supported Renovate platform, including Mend Remediate.","title":"Supported platforms"},{"location":"merge-confidence/#supported-languages","text":"Data is available for packages from: npm Maven PyPI We plan to support more languages soon.","title":"Supported languages"},{"location":"merge-confidence/#enabling-and-disabling","text":"If you use the Mend Renovate App (formerly WhiteSource Renovate App) then the badges are enabled automatically. If you don't use the app, you can enable the badges by adding this to your Renovate config: \"extends\" : [ \"github>whitesource/merge-confidence:beta\" ] If you want to disable the badges in the app, add this to your config: \"ignorePresets\" : [ \"github>whitesource/merge-confidence:beta\" ]","title":"Enabling and disabling"},{"location":"merge-confidence/#confidence-levels-and-their-meaning","text":"Merge Confidence uses the following confidence levels: Low : We think the update contains breaking changes. Often this is expected because it's a Major version update, but updates can have unknown breaking changes. Neutral : We don't have enough data about the update, or we can't decide if the update should be Low or High confidence. High : We rank updates as High confidence when the combination of Age , Adoption and Passing tests means there's a very low chance of breaking changes. Very High : We only use this for updates which are months old and have either high Adoption or have very high test Passing scores.","title":"Confidence levels and their meaning"},{"location":"merge-confidence/#how-it-works","text":"Mend's hosted Renovate App has created millions of pull requests on github.com to help developers update their dependencies since 2017. We bundle and analyze metrics such as package Age , package Adoption , and Passing tests. This way we can find packages that have undeclared breaking changes.","title":"How it works"},{"location":"merge-confidence/#algorithm","text":"The algorithm that decides on the values is private and is not something we plan to share. Similar to a search engine's algorithm, we plan to adjust and improve it over time, for example by using historical data to set a baseline confidence level for packages.","title":"Algorithm"},{"location":"merge-confidence/#data","text":"We plan to expose much more of the data via a companion website, such as number of users of a package and popular repositories which already updated to the version in question.","title":"Data"},{"location":"merge-confidence/#explanations","text":"","title":"Explanations"},{"location":"merge-confidence/#npm-package-ranking","text":"npm packages less than three days old can be unpublished , which can result in a service impact if you have updated to a package that gets unpublished. This is why npm packages can only get the High Confidence badge when they are at least three days old.","title":"npm package ranking"},{"location":"merge-confidence/#percentage-values-weighting","text":"The percentages for Adoption and Passing are weighted towards Organizations, private repositories, and projects with high test reliability. This means those values aren't raw percentages.","title":"Percentage values weighting"},{"location":"merge-confidence/#roadmap","text":"High-level information on planned improvements is available in the Merge Confidence Roadmap Project on GitHub.","title":"Roadmap"},{"location":"merge-confidence/#questions-and-feedback","text":"You are invited to create an Issue if you have anything you'd like to discuss.","title":"Questions and feedback"},{"location":"node/","text":"Node.js Versions \u00b6 Renovate can upgrade the Node.js runtime used by your project. This way you're using the latest bug fixes, performance improvements, security mitigations, etc. LTS codenames \u00b6 Renovate understands codenames for Node.js LTS releases and will offer upgrades for them (e.g. from fermium to gallium ) as long as the node versioning scheme is being used. File Support \u00b6 Renovate can manage the Node.js version in the following files: The engines field in package.json The volta field in package.json The .nvmrc file for the Node Version Manager The .node-version file for the nodenv environment manager The node_js field in .travis.yml Configuring which version of npm Renovate uses \u00b6 When binarySource=docker , such as in the hosted Mend Renovate App, Renovate will choose and install an npm version dynamically. To control which version or constraint is installed, you should use the engines.npm property in your package.json file. Renovate bot will then use that version constraint for npm when it creates a pull request. For example, if you want to use at least npm 8.1.0 and also allow newer versions of npm in the 8.x range, you would put this in your package.json file: { \"engines\" : { \"npm\" : \"^8.1.0\" } } Alternatively, the npm version can also be configured via the constraints option .","title":"Node.js Versions"},{"location":"node/#nodejs-versions","text":"Renovate can upgrade the Node.js runtime used by your project. This way you're using the latest bug fixes, performance improvements, security mitigations, etc.","title":"Node.js Versions"},{"location":"node/#lts-codenames","text":"Renovate understands codenames for Node.js LTS releases and will offer upgrades for them (e.g. from fermium to gallium ) as long as the node versioning scheme is being used.","title":"LTS codenames"},{"location":"node/#file-support","text":"Renovate can manage the Node.js version in the following files: The engines field in package.json The volta field in package.json The .nvmrc file for the Node Version Manager The .node-version file for the nodenv environment manager The node_js field in .travis.yml","title":"File Support"},{"location":"node/#configuring-which-version-of-npm-renovate-uses","text":"When binarySource=docker , such as in the hosted Mend Renovate App, Renovate will choose and install an npm version dynamically. To control which version or constraint is installed, you should use the engines.npm property in your package.json file. Renovate bot will then use that version constraint for npm when it creates a pull request. For example, if you want to use at least npm 8.1.0 and also allow newer versions of npm in the 8.x range, you would put this in your package.json file: { \"engines\" : { \"npm\" : \"^8.1.0\" } } Alternatively, the npm version can also be configured via the constraints option .","title":"Configuring which version of npm Renovate uses"},{"location":"noise-reduction/","text":"Noise Reduction \u00b6 Generally, the first reaction people have to automated dependency updates like Renovate is \"oh great/feel the power of automation\". The next reaction a few days or weeks later is often \"this is getting overwhelming\". Indeed, if you leave Renovate on its default settings of raising a PR every single time any dependency receives any update.. you will get a lot of PRs and related notifications. This document will give you some ideas of how to reduce the amount of \"noise\" in your repository and the Pros/Cons of each approach. Of course, please keep in mind that people's definitions of \"noise\" may differ. For some people, it's noisy only if they get a notification or email from GitHub. For others, too many commits in their base branch may be \"noise\". In other words, your mileage may vary. If you have any ideas on this topic, please contact the author by starting a new discussion on the Renovate repository . Package Grouping \u00b6 To reduce noise, you can reduce the number of updates in total, and a good way to do that is via intelligent grouping of related packages. As an example, our default \":app\" and \":library\" presets include the rule \"group:monorepos\" , which means that \"sibling\" packages from known monorepos will always be grouped into the same branch/PR by renovate. For example, all @angular/* packages that are updated at the same time will be raised in a \"Renovate angular monorepo packages\" PR. And every package in the React monorepo will be grouped together in a React monorepo PR too. You may wish to take this further, for example you might want to group together all packages related to eslint , even if they come from separate repositories/authors. In that case you might create a config like this: { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"eslint\" ], \"groupName\" : \"eslint\" } ] } By setting matchPackagePatterns to \"eslint\", it means that any package with ESLint anywhere in its name will be grouped into a renovate/eslint branch and related PR. Caution : Any time you group dependencies together, you naturally increase the chance that the branch will have an error (\"break\" your build). When you have more than one package upgrade in a PR, it's going to take you longer to work out which one broke than if they were all in separate PRs. Also, you will be held up upgrading all those dependencies until they all pass. If you weren't grouping, then you could keep upgrading all dependencies except the one that fails, instead of being held up. You will also have less flexibility about what to do when one or more in the group have a major upgrade and may break the others. Scheduling Renovate \u00b6 For a high level overview of scheduling when Renovate bot runs, read the key concepts, scheduling docs. On its own, the Renovate CLI tool runs once and then exits. Hence, it only runs as often as its administrator sets it to (e.g. via cron ). For the Renovate app on GitHub , it currently runs continuously using a job queue that gets refreshed hourly, or when you make relevant commits to your repository. You can expect to get PRs at any time of the day, e.g. soon after versions are published to npm. Receiving PRs at any hour can increase the feeling of being \"overwhelmed\" by updates and possibly interrupt your flow during working hours, so many Renovate users also consider reducing Renovate's schedule to be outside their normal working hours, for example weeknights and weekends. This is achievable by configuring schedule in your Renovate config and optionally timezone (Renovate's default time zone is UTC, so you may find it easier to write schedules if you override timezone to your local one). Another example of adjusting schedules to fit with your workflow might be if your company performs releases every Monday. In that case, you might schedule Renovate to run every Tuesday after midnight to pick up new dependency updates that you can test over the following week before the next release. Caution : You need to make sure you leave yourself and Renovate enough time in a week to actually get all your updating and merging done. There are multiple reasons why Renovate may need to \"recreate\" PRs after you merge another: Conflict with package.json (sometimes) Conflict with lock files (often) If you have configured Renovate or GitHub that PRs must always be kept up-to-date with the base branch Any of the above reasons can lead to a Renovate branch being considered \"stale\" and then Renovate needs to rebase it off the base branch before you can test and merge again, and Renovate won't do this until it's back in schedule. Selective scheduling \u00b6 Don't think that you need to apply blanket rules to scheduling. Remember that Renovate's configuration is highly flexible so you can configure automerge anywhere from globally (entire repo) right down to a package/upgrade type level. You could even configure a nonsensical rule like: \"patch updates of jquery are for Mondays only\". Remember our example of grouping all eslint packages? If you think about it, updates to eslint rules don't exactly need to be applied in real time! You don't want to get too far behind, so how about we update eslint packages only once a month? { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"eslint\" ], \"groupName\" : \"eslint\" , \"schedule\" : [ \"on the first day of the month\" ] } ] } Or perhaps at least weekly: { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"eslint\" ], \"groupName\" : \"eslint\" , \"schedule\" : [ \"before 2am on monday\" ] } ] } If you're wondering what is supported and not, under the hood, the schedule is parsed using @breejs/later using the later.parse.text(scheduleString) API. Read the parser documentation at breejs.github.io/later/parsers.html#text . Renovate does not support scheduled minutes or \"at an exact time\" granularity. Granularity must be at least one hour. Automerging \u00b6 Automerging is a Renovate feature that can save you a lot of time/noise directly, while also benefiting grouping and scheduling. In short: it means that Renovate can merge PRs or even branches itself if they pass your tests. We recommend that you enable automerge for any type of dependency update where you would just click Merge anyway. We all know that there are some types of updates that we (nearly) always verify manually before merging, and plenty of others that we don't bother looking at unless tests fail. Every time you click Merge on a Renovate PR without manually testing it, you should consider if you can enable automerge and save yourself the time in future. Automerge works particularly well for devDependencies and for production dependencies that have great test coverage. For example, if you have jest or mocha as a dependency, and it has an upgrade with passing tests: automerge them! If you have a linter like eslint or tslint and its update passes: automerge them! If you have an API with 100% test coverage and express is updated: automerge it! Branch automerging \u00b6 Those of you familiar with GitHub might note that even if you automerge PRs, you are still going to get notifications (noise) anyway - one when the PR is created and another when it is merged. For this reason we recommend you consider setting automergeType=branch which will mean: Renovate first creates a branch and no PR If tests pass, Renovate pushes a commit directly to the base branch without PR If tests fail, Renovate raises a PR for you to review The result is that passing updates are essentially \"silent\" - the only sign of them are the commits to your base branch. Automerging and scheduling \u00b6 Automerging is particularly beneficial if you have configured a schedule, because Renovate on its own may be able to automerge the majority of your updates. And this is especially so if your repository needs rebasing, e.g. because you use lock files. e.g. let's say you have dependencies abc and xyz with upgrades, and you use a yarn.lock file. At the start of the schedule, Renovate will create branches for abc and xyz upgrades, including yarn.lock updates After abc passes tests, Renovate will automerge it to your base branch The xyz branch probably now has yarn.lock conflicts Renovate will immediately check all other branches and rebase them The change to xyz branch will trigger another round of CI tests After the updated xyz branch passes, Renovate will automerge it too This is a lot better than you waking up to two PRs and then having to deal with conflicts yourself after you merge the first one. Remember our running eslint example? Let's automerge it if all the linting updates pass: { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"eslint\" ], \"groupName\" : \"eslint\" , \"schedule\" : [ \"before 2am on monday\" ], \"automerge\" : true , \"automergeType\" : \"branch\" } ] } Have you come up with a rule that you think others would benefit from? How about a PR back to renovate-config with the above rule named \":automergeEslintWeekly\" ? Lock file considerations \u00b6 Using lock files greatly increases the chance that merging one PR will result in a second PR becoming conflicted with the base branch. The table below highlights different noise reduction strategies and their effect on pull request and potential lock file conflicts: Action Effect on pull requests Chance of lock file conflicts Group dependencies together Decreases separate PRs Decreases Automerge dependencies Decreases concurrent PRs Decreases Decrease scheduled time for Renovate Increases concurrent PRs Increases The Future of Noise Reduction \u00b6 First of all, if you ever have any ideas about how to make Renovate less noisy, please raise or comment on issues in the main repository . Our philosophy is: Nearly everyone should use Renovate-like dependency update automation Over time, you should \"see\" Renovate less and less One of our hopes with preset configs is that a set of \"sensible\" configs can be maintained by the community that combine grouping, scheduling and automerging to reduce the amount of noise in repositories with little downside or increased risk. Such lists could be maintained and used somewhat like Adblock lists - kept up to date by maintainers but for the majority of users they are simply trusted/automatic/invisible.","title":"Noise Reduction"},{"location":"noise-reduction/#noise-reduction","text":"Generally, the first reaction people have to automated dependency updates like Renovate is \"oh great/feel the power of automation\". The next reaction a few days or weeks later is often \"this is getting overwhelming\". Indeed, if you leave Renovate on its default settings of raising a PR every single time any dependency receives any update.. you will get a lot of PRs and related notifications. This document will give you some ideas of how to reduce the amount of \"noise\" in your repository and the Pros/Cons of each approach. Of course, please keep in mind that people's definitions of \"noise\" may differ. For some people, it's noisy only if they get a notification or email from GitHub. For others, too many commits in their base branch may be \"noise\". In other words, your mileage may vary. If you have any ideas on this topic, please contact the author by starting a new discussion on the Renovate repository .","title":"Noise Reduction"},{"location":"noise-reduction/#package-grouping","text":"To reduce noise, you can reduce the number of updates in total, and a good way to do that is via intelligent grouping of related packages. As an example, our default \":app\" and \":library\" presets include the rule \"group:monorepos\" , which means that \"sibling\" packages from known monorepos will always be grouped into the same branch/PR by renovate. For example, all @angular/* packages that are updated at the same time will be raised in a \"Renovate angular monorepo packages\" PR. And every package in the React monorepo will be grouped together in a React monorepo PR too. You may wish to take this further, for example you might want to group together all packages related to eslint , even if they come from separate repositories/authors. In that case you might create a config like this: { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"eslint\" ], \"groupName\" : \"eslint\" } ] } By setting matchPackagePatterns to \"eslint\", it means that any package with ESLint anywhere in its name will be grouped into a renovate/eslint branch and related PR. Caution : Any time you group dependencies together, you naturally increase the chance that the branch will have an error (\"break\" your build). When you have more than one package upgrade in a PR, it's going to take you longer to work out which one broke than if they were all in separate PRs. Also, you will be held up upgrading all those dependencies until they all pass. If you weren't grouping, then you could keep upgrading all dependencies except the one that fails, instead of being held up. You will also have less flexibility about what to do when one or more in the group have a major upgrade and may break the others.","title":"Package Grouping"},{"location":"noise-reduction/#scheduling-renovate","text":"For a high level overview of scheduling when Renovate bot runs, read the key concepts, scheduling docs. On its own, the Renovate CLI tool runs once and then exits. Hence, it only runs as often as its administrator sets it to (e.g. via cron ). For the Renovate app on GitHub , it currently runs continuously using a job queue that gets refreshed hourly, or when you make relevant commits to your repository. You can expect to get PRs at any time of the day, e.g. soon after versions are published to npm. Receiving PRs at any hour can increase the feeling of being \"overwhelmed\" by updates and possibly interrupt your flow during working hours, so many Renovate users also consider reducing Renovate's schedule to be outside their normal working hours, for example weeknights and weekends. This is achievable by configuring schedule in your Renovate config and optionally timezone (Renovate's default time zone is UTC, so you may find it easier to write schedules if you override timezone to your local one). Another example of adjusting schedules to fit with your workflow might be if your company performs releases every Monday. In that case, you might schedule Renovate to run every Tuesday after midnight to pick up new dependency updates that you can test over the following week before the next release. Caution : You need to make sure you leave yourself and Renovate enough time in a week to actually get all your updating and merging done. There are multiple reasons why Renovate may need to \"recreate\" PRs after you merge another: Conflict with package.json (sometimes) Conflict with lock files (often) If you have configured Renovate or GitHub that PRs must always be kept up-to-date with the base branch Any of the above reasons can lead to a Renovate branch being considered \"stale\" and then Renovate needs to rebase it off the base branch before you can test and merge again, and Renovate won't do this until it's back in schedule.","title":"Scheduling Renovate"},{"location":"noise-reduction/#selective-scheduling","text":"Don't think that you need to apply blanket rules to scheduling. Remember that Renovate's configuration is highly flexible so you can configure automerge anywhere from globally (entire repo) right down to a package/upgrade type level. You could even configure a nonsensical rule like: \"patch updates of jquery are for Mondays only\". Remember our example of grouping all eslint packages? If you think about it, updates to eslint rules don't exactly need to be applied in real time! You don't want to get too far behind, so how about we update eslint packages only once a month? { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"eslint\" ], \"groupName\" : \"eslint\" , \"schedule\" : [ \"on the first day of the month\" ] } ] } Or perhaps at least weekly: { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"eslint\" ], \"groupName\" : \"eslint\" , \"schedule\" : [ \"before 2am on monday\" ] } ] } If you're wondering what is supported and not, under the hood, the schedule is parsed using @breejs/later using the later.parse.text(scheduleString) API. Read the parser documentation at breejs.github.io/later/parsers.html#text . Renovate does not support scheduled minutes or \"at an exact time\" granularity. Granularity must be at least one hour.","title":"Selective scheduling"},{"location":"noise-reduction/#automerging","text":"Automerging is a Renovate feature that can save you a lot of time/noise directly, while also benefiting grouping and scheduling. In short: it means that Renovate can merge PRs or even branches itself if they pass your tests. We recommend that you enable automerge for any type of dependency update where you would just click Merge anyway. We all know that there are some types of updates that we (nearly) always verify manually before merging, and plenty of others that we don't bother looking at unless tests fail. Every time you click Merge on a Renovate PR without manually testing it, you should consider if you can enable automerge and save yourself the time in future. Automerge works particularly well for devDependencies and for production dependencies that have great test coverage. For example, if you have jest or mocha as a dependency, and it has an upgrade with passing tests: automerge them! If you have a linter like eslint or tslint and its update passes: automerge them! If you have an API with 100% test coverage and express is updated: automerge it!","title":"Automerging"},{"location":"noise-reduction/#branch-automerging","text":"Those of you familiar with GitHub might note that even if you automerge PRs, you are still going to get notifications (noise) anyway - one when the PR is created and another when it is merged. For this reason we recommend you consider setting automergeType=branch which will mean: Renovate first creates a branch and no PR If tests pass, Renovate pushes a commit directly to the base branch without PR If tests fail, Renovate raises a PR for you to review The result is that passing updates are essentially \"silent\" - the only sign of them are the commits to your base branch.","title":"Branch automerging"},{"location":"noise-reduction/#automerging-and-scheduling","text":"Automerging is particularly beneficial if you have configured a schedule, because Renovate on its own may be able to automerge the majority of your updates. And this is especially so if your repository needs rebasing, e.g. because you use lock files. e.g. let's say you have dependencies abc and xyz with upgrades, and you use a yarn.lock file. At the start of the schedule, Renovate will create branches for abc and xyz upgrades, including yarn.lock updates After abc passes tests, Renovate will automerge it to your base branch The xyz branch probably now has yarn.lock conflicts Renovate will immediately check all other branches and rebase them The change to xyz branch will trigger another round of CI tests After the updated xyz branch passes, Renovate will automerge it too This is a lot better than you waking up to two PRs and then having to deal with conflicts yourself after you merge the first one. Remember our running eslint example? Let's automerge it if all the linting updates pass: { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"eslint\" ], \"groupName\" : \"eslint\" , \"schedule\" : [ \"before 2am on monday\" ], \"automerge\" : true , \"automergeType\" : \"branch\" } ] } Have you come up with a rule that you think others would benefit from? How about a PR back to renovate-config with the above rule named \":automergeEslintWeekly\" ?","title":"Automerging and scheduling"},{"location":"noise-reduction/#lock-file-considerations","text":"Using lock files greatly increases the chance that merging one PR will result in a second PR becoming conflicted with the base branch. The table below highlights different noise reduction strategies and their effect on pull request and potential lock file conflicts: Action Effect on pull requests Chance of lock file conflicts Group dependencies together Decreases separate PRs Decreases Automerge dependencies Decreases concurrent PRs Decreases Decrease scheduled time for Renovate Increases concurrent PRs Increases","title":"Lock file considerations"},{"location":"noise-reduction/#the-future-of-noise-reduction","text":"First of all, if you ever have any ideas about how to make Renovate less noisy, please raise or comment on issues in the main repository . Our philosophy is: Nearly everyone should use Renovate-like dependency update automation Over time, you should \"see\" Renovate less and less One of our hopes with preset configs is that a set of \"sensible\" configs can be maintained by the community that combine grouping, scheduling and automerging to reduce the amount of noise in repositories with little downside or increased risk. Such lists could be maintained and used somewhat like Adblock lists - kept up to date by maintainers but for the majority of users they are simply trusted/automatic/invisible.","title":"The Future of Noise Reduction"},{"location":"nuget/","text":"NuGet \u00b6 Renovate can upgrade dependencies in these files: .csproj .fsproj .vbproj Version Support \u00b6 Renovate only works with SDK-style .csproj , .fsproj or .vbproj files. By default, this includes: .NET Core 1.0 and above .NET Standard class libraries .csproj , .fsproj or .vbproj files that use the SDK-style syntax To convert your .NET Framework .csproj , .fsproj or .vbproj files into an SDK-style project, follow the steps in this guide . How it works \u00b6 Renovate searches in each repository for any files with a .csproj , .fsproj , or .vbproj extension Existing dependencies are extracted from <PackageReference> and <PackageVersion> tags Renovate looks up the latest version on nuget.org (or on alternate feeds ) to see if any upgrades are available If the source package includes a GitHub URL as its source, and has either: a \"changelog\" file, or uses GitHub releases then release notes for each version are embedded in the generated PR If your project file references a packages.config file, no dependencies will be extracted. Find out here how to migrate from packages.config to PackageReference . Alternate feeds \u00b6 By default Renovate performs all lookups on https://api.nuget.org/v3/index.json , but you can set alternative NuGet feeds. You can set alternative feeds: in a NuGet.config file within your repository (Renovate will not search outside the repository), or in a Renovate configuration options file like renovate.json { \"nuget\" : { \"registryUrls\" : [ \"https://api.nuget.org/v3/index.json\" , \"https://example1.com/nuget/\" , \"https://example2.com/nuget/v3/index.json\" ] } } In the example above we've set three NuGet feeds. The package resolving process uses the merge strategy to handle the three feeds. All feeds are checked for dependency updates, and duplicate updates are merged/joined together into a single dependency update. If your project uses lockfiles (a package.lock.json exists), alternate feed settings must be defined in a NuGet.config only, as registryUrls are not passed through to the NuGet commands used. Protocol versions \u00b6 NuGet supports two protocol versions, v2 and v3 . The NuGet client and server must use the same version. Renovate as a NuGet client supports both v2 and v3 protocols, and will use v2 unless the configured feed URL ends with index.json . This mirrors the behavior of the official NuGet client. If you have a v3 feed that doesn't end with index.json , like for example on the JFrog Artifactory, then you must append #protocolVersion=3 to the registry URL: { \"nuget\" : { \"registryUrls\" : [ \"http://myV3feed#protocolVersion=3\" ] } } Authenticated feeds \u00b6 Credentials for authenticated/private feeds can be given via host rules in the configuration options (file or command line parameter). { \"hostRules\" : [ { \"hostType\" : \"nuget\" , \"matchHost\" : \"http://example1.com/nuget\" , \"username\" : \"root\" , \"password\" : \"p4$$w0rd\" } ] } Note Only Basic HTTP authentication (via username and password) is supported. Future work \u00b6 Contributions and/or feature requests are welcome to support more patterns or additional use cases.","title":"Nuget"},{"location":"nuget/#nuget","text":"Renovate can upgrade dependencies in these files: .csproj .fsproj .vbproj","title":"NuGet"},{"location":"nuget/#version-support","text":"Renovate only works with SDK-style .csproj , .fsproj or .vbproj files. By default, this includes: .NET Core 1.0 and above .NET Standard class libraries .csproj , .fsproj or .vbproj files that use the SDK-style syntax To convert your .NET Framework .csproj , .fsproj or .vbproj files into an SDK-style project, follow the steps in this guide .","title":"Version Support"},{"location":"nuget/#how-it-works","text":"Renovate searches in each repository for any files with a .csproj , .fsproj , or .vbproj extension Existing dependencies are extracted from <PackageReference> and <PackageVersion> tags Renovate looks up the latest version on nuget.org (or on alternate feeds ) to see if any upgrades are available If the source package includes a GitHub URL as its source, and has either: a \"changelog\" file, or uses GitHub releases then release notes for each version are embedded in the generated PR If your project file references a packages.config file, no dependencies will be extracted. Find out here how to migrate from packages.config to PackageReference .","title":"How it works"},{"location":"nuget/#alternate-feeds","text":"By default Renovate performs all lookups on https://api.nuget.org/v3/index.json , but you can set alternative NuGet feeds. You can set alternative feeds: in a NuGet.config file within your repository (Renovate will not search outside the repository), or in a Renovate configuration options file like renovate.json { \"nuget\" : { \"registryUrls\" : [ \"https://api.nuget.org/v3/index.json\" , \"https://example1.com/nuget/\" , \"https://example2.com/nuget/v3/index.json\" ] } } In the example above we've set three NuGet feeds. The package resolving process uses the merge strategy to handle the three feeds. All feeds are checked for dependency updates, and duplicate updates are merged/joined together into a single dependency update. If your project uses lockfiles (a package.lock.json exists), alternate feed settings must be defined in a NuGet.config only, as registryUrls are not passed through to the NuGet commands used.","title":"Alternate feeds"},{"location":"nuget/#protocol-versions","text":"NuGet supports two protocol versions, v2 and v3 . The NuGet client and server must use the same version. Renovate as a NuGet client supports both v2 and v3 protocols, and will use v2 unless the configured feed URL ends with index.json . This mirrors the behavior of the official NuGet client. If you have a v3 feed that doesn't end with index.json , like for example on the JFrog Artifactory, then you must append #protocolVersion=3 to the registry URL: { \"nuget\" : { \"registryUrls\" : [ \"http://myV3feed#protocolVersion=3\" ] } }","title":"Protocol versions"},{"location":"nuget/#authenticated-feeds","text":"Credentials for authenticated/private feeds can be given via host rules in the configuration options (file or command line parameter). { \"hostRules\" : [ { \"hostType\" : \"nuget\" , \"matchHost\" : \"http://example1.com/nuget\" , \"username\" : \"root\" , \"password\" : \"p4$$w0rd\" } ] } Note Only Basic HTTP authentication (via username and password) is supported.","title":"Authenticated feeds"},{"location":"nuget/#future-work","text":"Contributions and/or feature requests are welcome to support more patterns or additional use cases.","title":"Future work"},{"location":"php/","text":"Automated Dependency Updates for PHP Composer Dependencies \u00b6 Renovate can upgrade dependencies in PHP's composer.json and composer.lock files. How It Works \u00b6 Renovate searches in each repository for any composer.json files Existing dependencies are extracted from the relevant sections of the JSON Renovate resolves the dependency on Packagist (or elsewhere if configured), and filter for SemVer versions A PR is created with composer.json and composer.lock updated in the same commit If the source repository has either a \"changelog\" file or uses GitHub releases, then Release Notes for each version will be embedded in the generated PR Enabling \u00b6 Either install the Renovate App on GitHub, or check out Renovate OSS for self-hosted. Private packages \u00b6 If you are using a privately hosted Composer package you can pass the credentials via the hostRules configuration. { \"hostRules\" : [ { \"matchHost\" : \"some.vendor.com\" , \"hostType\" : \"packagist\" , \"username\" : \"<your-username>\" , \"password\" : \"<your-password>\" }, { \"matchHost\" : \"bearer-auth.for.vendor.com\" , \"hostType\" : \"packagist\" , \"token\" : \"abcdef0123456789\" } ] } This host rule is best added to the bot's config.js config so that it is not visible to users of the repository. If you are using the hosted Mend Renovate App then you can encrypt it with Renovate's public key instead, so that only Renovate can decrypt it. Go to https://app.renovatebot.com/encrypt , paste in the secret string you wish to encrypt, click Encrypt , then copy the encrypted result. You may encrypt your password only, but you can encrypt your username as well. { \"hostRules\" : [ { \"matchHost\" : \"some.vendor.com\" , \"hostType\" : \"packagist\" , \"encrypted\" : { \"username\" : \"<your-encrypted-username>\" , \"password\" : \"<your-encrypted-password>\" } }, { \"matchHost\" : \"bearer-auth.for.vendor.com\" , \"hostType\" : \"packagist\" , \"encrypted\" : { \"token\" : \"<your-encrypted-token>\" } } ] }","title":"PHP"},{"location":"php/#automated-dependency-updates-for-php-composer-dependencies","text":"Renovate can upgrade dependencies in PHP's composer.json and composer.lock files.","title":"Automated Dependency Updates for PHP Composer Dependencies"},{"location":"php/#how-it-works","text":"Renovate searches in each repository for any composer.json files Existing dependencies are extracted from the relevant sections of the JSON Renovate resolves the dependency on Packagist (or elsewhere if configured), and filter for SemVer versions A PR is created with composer.json and composer.lock updated in the same commit If the source repository has either a \"changelog\" file or uses GitHub releases, then Release Notes for each version will be embedded in the generated PR","title":"How It Works"},{"location":"php/#enabling","text":"Either install the Renovate App on GitHub, or check out Renovate OSS for self-hosted.","title":"Enabling"},{"location":"php/#private-packages","text":"If you are using a privately hosted Composer package you can pass the credentials via the hostRules configuration. { \"hostRules\" : [ { \"matchHost\" : \"some.vendor.com\" , \"hostType\" : \"packagist\" , \"username\" : \"<your-username>\" , \"password\" : \"<your-password>\" }, { \"matchHost\" : \"bearer-auth.for.vendor.com\" , \"hostType\" : \"packagist\" , \"token\" : \"abcdef0123456789\" } ] } This host rule is best added to the bot's config.js config so that it is not visible to users of the repository. If you are using the hosted Mend Renovate App then you can encrypt it with Renovate's public key instead, so that only Renovate can decrypt it. Go to https://app.renovatebot.com/encrypt , paste in the secret string you wish to encrypt, click Encrypt , then copy the encrypted result. You may encrypt your password only, but you can encrypt your username as well. { \"hostRules\" : [ { \"matchHost\" : \"some.vendor.com\" , \"hostType\" : \"packagist\" , \"encrypted\" : { \"username\" : \"<your-encrypted-username>\" , \"password\" : \"<your-encrypted-password>\" } }, { \"matchHost\" : \"bearer-auth.for.vendor.com\" , \"hostType\" : \"packagist\" , \"encrypted\" : { \"token\" : \"<your-encrypted-token>\" } } ] }","title":"Private packages"},{"location":"presets-compatibility/","text":"compatibility:additionalBranchPrefix \u00b6 Backwards-compatibility preset to restore additionalBranchPrefix settings for multiple managers which were removed in v25 { \"buildkite\" : { \"additionalBranchPrefix\" : \"buildkite-\" }, \"cargo\" : { \"additionalBranchPrefix\" : \"rust-\" }, \"docker\" : { \"additionalBranchPrefix\" : \"docker-\" }, \"homebrew\" : { \"additionalBranchPrefix\" : \"homebrew-\" }, \"packageRules\" : [ { \"matchDatasources\" : [ \"helm\" ], \"additionalBranchPrefix\" : \"helm-\" } ] }","title":"Compatibility Presets"},{"location":"presets-compatibility/#compatibilityadditionalbranchprefix","text":"Backwards-compatibility preset to restore additionalBranchPrefix settings for multiple managers which were removed in v25 { \"buildkite\" : { \"additionalBranchPrefix\" : \"buildkite-\" }, \"cargo\" : { \"additionalBranchPrefix\" : \"rust-\" }, \"docker\" : { \"additionalBranchPrefix\" : \"docker-\" }, \"homebrew\" : { \"additionalBranchPrefix\" : \"homebrew-\" }, \"packageRules\" : [ { \"matchDatasources\" : [ \"helm\" ], \"additionalBranchPrefix\" : \"helm-\" } ] }","title":"compatibility:additionalBranchPrefix"},{"location":"presets-config/","text":"config:base \u00b6 Default base configuration for all languages { \"extends\" : [ \":dependencyDashboard\" , \":semanticPrefixFixDepsChoreOthers\" , \":ignoreModulesAndTests\" , \":autodetectPinVersions\" , \":prHourlyLimit2\" , \":prConcurrentLimit10\" , \"group:monorepos\" , \"group:recommended\" , \"workarounds:all\" ] } config:js-app \u00b6 Default configuration for webapps { \"extends\" : [ \"config:base\" , \":pinAllExceptPeerDependencies\" ] } config:js-lib \u00b6 Default configuration for libraries { \"extends\" : [ \"config:base\" , \":pinOnlyDevDependencies\" ] } config:semverAllMonthly \u00b6 Preserve SemVer ranges and update everything together once a month { \"separateMajorMinor\" : false , \"extends\" : [ \":preserveSemverRanges\" , \"group:all\" , \"schedule:monthly\" , \":maintainLockFilesMonthly\" ], \"lockFileMaintenance\" : { \"extends\" : [ \"group:all\" ], \"commitMessageAction\" : \"Update\" } }","title":"Full Config Presets"},{"location":"presets-config/#configbase","text":"Default base configuration for all languages { \"extends\" : [ \":dependencyDashboard\" , \":semanticPrefixFixDepsChoreOthers\" , \":ignoreModulesAndTests\" , \":autodetectPinVersions\" , \":prHourlyLimit2\" , \":prConcurrentLimit10\" , \"group:monorepos\" , \"group:recommended\" , \"workarounds:all\" ] }","title":"config:base"},{"location":"presets-config/#configjs-app","text":"Default configuration for webapps { \"extends\" : [ \"config:base\" , \":pinAllExceptPeerDependencies\" ] }","title":"config:js-app"},{"location":"presets-config/#configjs-lib","text":"Default configuration for libraries { \"extends\" : [ \"config:base\" , \":pinOnlyDevDependencies\" ] }","title":"config:js-lib"},{"location":"presets-config/#configsemverallmonthly","text":"Preserve SemVer ranges and update everything together once a month { \"separateMajorMinor\" : false , \"extends\" : [ \":preserveSemverRanges\" , \"group:all\" , \"schedule:monthly\" , \":maintainLockFilesMonthly\" ], \"lockFileMaintenance\" : { \"extends\" : [ \"group:all\" ], \"commitMessageAction\" : \"Update\" } }","title":"config:semverAllMonthly"},{"location":"presets-default/","text":":enableRenovate \u00b6 Enable Renovate { \"enabled\" : true } :disableRenovate \u00b6 Disable Renovate { \"enabled\" : false } :disableMajorUpdates \u00b6 Disables major updates { \"major\" : { \"enabled\" : false } } :disableDomain( <arg0> ) \u00b6 Disable requests to a particular domain { \"hostRules\" : [ { \"matchHost\" : \"arg0\" , \"enabled\" : false } ] } :disableHost( <arg0> ) \u00b6 Disable requests to a particular host { \"hostRules\" : [ { \"matchHost\" : \"https://arg0\" , \"enabled\" : false } ] } :enablePreCommit \u00b6 Enable the pre-commit manager { \"pre-commit\" : { \"enabled\" : true } } :ignoreModulesAndTests \u00b6 Ignore node_modules , bower_components , vendor and various test/tests directories { \"ignorePaths\" : [ \"**/node_modules/**\" , \"**/bower_components/**\" , \"**/vendor/**\" , \"**/examples/**\" , \"**/__tests__/**\" , \"**/test/**\" , \"**/tests/**\" , \"**/__fixtures__/**\" ] } :includeNodeModules \u00b6 Include package.json files found within node_modules folders or bower_components . { \"ignorePaths\" : [] } :pinVersions \u00b6 Use version pinning (maintain a single version only and not SemVer ranges) { \"rangeStrategy\" : \"pin\" } :preserveSemverRanges \u00b6 Preserve (but continue to upgrade) any existing SemVer ranges { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"*\" ], \"rangeStrategy\" : \"replace\" } ] } :pinAllExceptPeerDependencies \u00b6 Pin dependency versions for all except peerDependencies { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"*\" ], \"rangeStrategy\" : \"pin\" }, { \"matchDepTypes\" : [ \"engines\" , \"peerDependencies\" ], \"rangeStrategy\" : \"auto\" } ] } :pinDependencies \u00b6 Pin dependency versions where depType=dependencies . Usually applies only to non-dev dependencies in package.json { \"packageRules\" : [ { \"matchDepTypes\" : [ \"dependencies\" ], \"rangeStrategy\" : \"pin\" } ] } :pinDevDependencies \u00b6 Pin dependency versions for devDependencies { \"packageRules\" : [ { \"matchDepTypes\" : [ \"devDependencies\" ], \"rangeStrategy\" : \"pin\" } ] } :pinOnlyDevDependencies \u00b6 Pin dependency versions for devDependencies and retain SemVer ranges for others { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"*\" ], \"rangeStrategy\" : \"replace\" }, { \"matchDepTypes\" : [ \"devDependencies\" ], \"rangeStrategy\" : \"pin\" }, { \"matchDepTypes\" : [ \"peerDependencies\" ], \"rangeStrategy\" : \"widen\" } ] } :autodetectPinVersions \u00b6 Autodetect whether to pin dependencies or maintain ranges { \"rangeStrategy\" : \"auto\" } :separateMajorReleases \u00b6 Separate major versions of dependencies into individual branches/PRs { \"separateMajorMinor\" : true } :separateMultipleMajorReleases \u00b6 Separate each available major versions of dependencies into individual branches/PRs { \"separateMajorMinor\" : true , \"separateMultipleMajor\" : true } :separatePatchReleases \u00b6 Separate patch and minor releases of dependencies into separate PRs { \"separateMinorPatch\" : true } :combinePatchMinorReleases \u00b6 Do not separate patch and minor upgrades into separate PRs for the same dependency { \"separateMinorPatch\" : false } :renovatePrefix \u00b6 Use renovate/ as prefix for all branch names { \"branchPrefix\" : \"renovate/\" } :semanticCommitType( <arg0> ) \u00b6 Use arg0 as semantic commit type for commit messages and PR titles { \"semanticCommitType\" : \"arg0\" } :semanticPrefixChore \u00b6 Use chore as semantic commit type for commit messages and PR titles { \"extends\" : [ \":semanticCommitType(chore)\" ] } :semanticPrefixFix \u00b6 Use fix as semantic commit type for commit messages and PR titles { \"extends\" : [ \":semanticCommitType(fix)\" ] } :disablePeerDependencies \u00b6 Do not renovate peerDependencies versions/ranges { \"packageRules\" : [ { \"matchDepTypes\" : [ \"peerDependencies\" ], \"enabled\" : false } ] } :disableDevDependencies \u00b6 Do not renovate devDependencies versions/ranges { \"packageRules\" : [ { \"matchDepTypes\" : [ \"devDependencies\" ], \"enabled\" : false } ] } :disableDigestUpdates \u00b6 Disable digest and Git hash updates { \"digest\" : { \"enabled\" : false } } :semanticPrefixFixDepsChoreOthers \u00b6 If semantic commits detected, use semantic commit type fix for dependencies and chore for all others { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"*\" ], \"semanticCommitType\" : \"chore\" }, { \"matchDepTypes\" : [ \"dependencies\" , \"require\" ], \"semanticCommitType\" : \"fix\" }, { \"matchDatasources\" : [ \"maven\" ], \"matchDepTypes\" : [ \"compile\" , \"provided\" , \"runtime\" , \"system\" , \"import\" , \"parent\" ], \"semanticCommitType\" : \"fix\" } ] } :semanticCommitTypeAll( <arg0> ) \u00b6 If semantic commits detected, use semantic commit type arg0 for all { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"*\" ], \"semanticCommitType\" : \"arg0\" } ] } :rebaseStalePrs \u00b6 Rebase existing PRs any time the base branch has been updated { \"rebaseWhen\" : \"behind-base-branch\" } :prImmediately \u00b6 Raise PRs immediately (after branch is created) { \"prCreation\" : \"immediate\" } :prNotPending \u00b6 Wait until branch tests have passed or failed before creating the PR { \"prCreation\" : \"not-pending\" } :prHourlyLimitNone \u00b6 Removes rate limit for PR creation per hour { \"prHourlyLimit\" : 0 } :prHourlyLimit1 \u00b6 Rate limit PR creation to a maximum of one per hour { \"prHourlyLimit\" : 1 } :prHourlyLimit2 \u00b6 Rate limit PR creation to a maximum of two per hour { \"prHourlyLimit\" : 2 } :prHourlyLimit4 \u00b6 Rate limit PR creation to a maximum of four per hour { \"prHourlyLimit\" : 4 } :prConcurrentLimitNone \u00b6 Remove limit for open PRs at any time { \"prConcurrentLimit\" : 0 } :prConcurrentLimit10 \u00b6 Limit to maximum 10 open PRs at any time { \"prConcurrentLimit\" : 10 } :prConcurrentLimit20 \u00b6 Limit to maximum 20 open PRs at any time { \"prConcurrentLimit\" : 20 } :disableRateLimiting \u00b6 Remove hourly and concurrent rate limits { \"prConcurrentLimit\" : 0 , \"prHourlyLimit\" : 0 } :automergeDisabled \u00b6 Disable automerging feature - wait for humans to merge all PRs { \"automerge\" : false } :automergeDigest \u00b6 Automerge digest upgrades if they pass tests { \"digest\" : { \"automerge\" : true } } :automergePatch \u00b6 Automerge patch upgrades if they pass tests { \"separateMinorPatch\" : true , \"patch\" : { \"automerge\" : true }, \"pin\" : { \"automerge\" : true }, \"lockFileMaintenance\" : { \"automerge\" : true } } :automergeMinor \u00b6 Automerge patch and minor upgrades if they pass tests { \"minor\" : { \"automerge\" : true }, \"patch\" : { \"automerge\" : true }, \"pin\" : { \"automerge\" : true }, \"lockFileMaintenance\" : { \"automerge\" : true } } :automergeMajor \u00b6 Automerge all upgrades (including major) if they pass tests { \"automerge\" : true } :automergeAll \u00b6 Automerge all upgrades (including major) if they pass tests { \"automerge\" : true } :automergeBranch \u00b6 If automerging, push the new commit directly to base branch (no PR) { \"automergeType\" : \"branch\" } :automergePr \u00b6 Raise a PR first before any automerging { \"automergeType\" : \"pr\" } :automergeRequireAllStatusChecks \u00b6 Require all status checks to pass before any automerging { \"ignoreTests\" : false } :skipStatusChecks \u00b6 Skip status checks and automerge right away { \"ignoreTests\" : true } :maintainLockFilesDisabled \u00b6 Update existing lock files only when package.json is modified { \"lockFileMaintenance\" : { \"enabled\" : false } } :pinDigestsDisabled \u00b6 Disable pinning of Docker dependency digests { \"pinDigests\" : false } :maintainLockFilesWeekly \u00b6 Run lock file maintenance (updates) early Monday mornings { \"lockFileMaintenance\" : { \"enabled\" : true , \"extends\" : [ \"schedule:weekly\" ] } } :maintainLockFilesMonthly \u00b6 Run lock file maintenance (updates) on the first day of each month { \"lockFileMaintenance\" : { \"enabled\" : true , \"extends\" : [ \"schedule:monthly\" ] } } :ignoreUnstable \u00b6 Upgrade to unstable versions only if the existing version is unstable { \"ignoreUnstable\" : true } :respectLatest \u00b6 Upgrade versions up to the \"latest\" tag in npm registry { \"respectLatest\" : true } :updateNotScheduled \u00b6 Keep existing branches updated even when not scheduled { \"updateNotScheduled\" : true } :noUnscheduledUpdates \u00b6 Make no updates to branches when not scheduled { \"updateNotScheduled\" : false } :automergeLinters \u00b6 Update lint packages automatically if tests pass { \"packageRules\" : [ { \"extends\" : [ \"packages:linters\" ], \"automerge\" : true } ] } :automergeTesters \u00b6 Update testing packages automatically if tests pass { \"packageRules\" : [ { \"extends\" : [ \"packages:test\" ], \"automerge\" : true } ] } :automergeTypes \u00b6 Update @types/* packages automatically if tests pass { \"packageRules\" : [ { \"matchPackagePrefixes\" : [ \"@types/\" ], \"automerge\" : true } ] } :doNotPinPackage( <arg0> ) \u00b6 Disable version pinning for arg0 { \"packageRules\" : [ { \"matchPackageNames\" : [ \"arg0\" ], \"rangeStrategy\" : \"replace\" } ] } :pinSkipCi \u00b6 Add [skip ci] to commit message body whenever pinning { \"pin\" : { \"commitBody\" : \"[skip ci]\" } } :gitSignOff \u00b6 Append Git Signed-off-by: signature to Git commits. { \"commitBody\" : \"Signed-off-by: {{{gitAuthor}}}\" } :npm \u00b6 Keep package.json npm dependencies updated { \"npm\" : { \"enabled\" : true } } :gomod \u00b6 Enable Go modules support { \"gomod\" : { \"enabled\" : true } } :onlyNpm \u00b6 Renovate only npm dependencies { \"docker\" : { \"enabled\" : false }, \"meteor\" : { \"enabled\" : false } } :docker \u00b6 Keep Dockerfile FROM sources updated { \"docker\" : { \"enabled\" : true } } :meteor \u00b6 Keep Meteor Npm.depends packages updated { \"meteor\" : { \"enabled\" : true } } :group( <arg0> , <arg1> ) \u00b6 Group arg1 packages into same branch/PR { \"packageRules\" : [ { \"extends\" : [ \"arg0\" ], \"groupName\" : \"arg1\" } ] } :label( <arg0> ) \u00b6 Apply label arg0 to PRs { \"labels\" : [ \"arg0\" ] } :labels( <arg0> , <arg1> ) \u00b6 Apply labels arg0 and arg1 to PRs { \"labels\" : [ \"arg0\" , \"arg1\" ] } :assignee( <arg0> ) \u00b6 Assign PRs to arg0 { \"assignees\" : [ \"arg0\" ] } :reviewer( <arg0> ) \u00b6 Add arg0 as reviewer for PRs { \"reviewers\" : [ \"arg0\" ] } :assignAndReview( <arg0> ) \u00b6 Set arg0 as assignee and reviewer of PRs { \"extends\" : [ \":assignee(arg0)\" , \":reviewer(arg0)\" ] } :enableVulnerabilityAlerts \u00b6 Raise PR when vulnerability alerts are detected { \"vulnerabilityAlerts\" : { \"enabled\" : true } } :enableVulnerabilityAlertsWithLabel( <arg0> ) \u00b6 Raise PR when vulnerability alerts are detected with label arg0 { \"vulnerabilityAlerts\" : { \"enabled\" : true , \"labels\" : [ \"arg0\" ] } } :disableVulnerabilityAlerts \u00b6 Disable vulnerability alerts completely { \"vulnerabilityAlerts\" : { \"enabled\" : false } } :semanticCommits \u00b6 Use semantic prefixes for commit messages and PR titles { \"semanticCommits\" : \"enabled\" } :semanticCommitsDisabled \u00b6 Disable semantic prefixes for commit messages and PR titles { \"semanticCommits\" : \"disabled\" } :disableLockFiles \u00b6 Disable lock file updates { \"updateLockFiles\" : false } :semanticCommitScope( <arg0> ) \u00b6 Use semantic commit scope arg0 for all commits and PR titles { \"semanticCommitScope\" : \"arg0\" } :semanticCommitScopeDisabled \u00b6 Disable semantic commit scope for all commits and PR titles { \"semanticCommitScope\" : null } :widenPeerDependencies \u00b6 Always widen peerDependencies SemVer ranges when updating, instead of replacing { \"packageRules\" : [ { \"matchDepTypes\" : [ \"peerDependencies\" ], \"rangeStrategy\" : \"widen\" } ] } :dependencyDashboard \u00b6 Enable Renovate Dependency Dashboard creation { \"dependencyDashboard\" : true } :disableDependencyDashboard \u00b6 Disable Renovate Dependency Dashboard creation { \"dependencyDashboard\" : false } :dependencyDashboardApproval \u00b6 Enable Renovate Dependency Dashboard approval workflow { \"dependencyDashboardApproval\" : true } :timezone( <arg0> ) \u00b6 Evaluate schedules according to timezone arg0 { \"timezone\" : \"arg0\" } :pathSemanticCommitType( <arg0> , <arg1> ) \u00b6 Use semanticCommitType arg0 for all package files matching path arg1 { \"packageRules\" : [ { \"matchPaths\" : [ \"arg0\" ], \"semanticCommitType\" : \"arg1\" } ] } :followTag( <arg0> , <arg1> ) \u00b6 For package arg0 , strictly follow release tag arg1 { \"packageRules\" : [ { \"matchPackageNames\" : [ \"arg0\" ], \"followTag\" : \"arg1\" } ] } :githubComToken( <arg0> ) \u00b6 Use provided token for github.com lookups. Do not configure this if you are already running on github.com { \"hostRules\" : [ { \"matchHost\" : \"github.com\" , \"encrypted\" : { \"token\" : \"arg0\" } } ] } :disablePrControls \u00b6 Remove the checkbox controls from PRs { \"prBodyTemplate\" : \"{{{header}}}{{{table}}}{{{notes}}}{{{changelogs}}}{{{configDescription}}}{{{footer}}}\" }","title":"Default Presets"},{"location":"presets-default/#enablerenovate","text":"Enable Renovate { \"enabled\" : true }","title":":enableRenovate"},{"location":"presets-default/#disablerenovate","text":"Disable Renovate { \"enabled\" : false }","title":":disableRenovate"},{"location":"presets-default/#disablemajorupdates","text":"Disables major updates { \"major\" : { \"enabled\" : false } }","title":":disableMajorUpdates"},{"location":"presets-default/#disabledomainarg0","text":"Disable requests to a particular domain { \"hostRules\" : [ { \"matchHost\" : \"arg0\" , \"enabled\" : false } ] }","title":":disableDomain(&lt;arg0&gt;)"},{"location":"presets-default/#disablehostarg0","text":"Disable requests to a particular host { \"hostRules\" : [ { \"matchHost\" : \"https://arg0\" , \"enabled\" : false } ] }","title":":disableHost(&lt;arg0&gt;)"},{"location":"presets-default/#enableprecommit","text":"Enable the pre-commit manager { \"pre-commit\" : { \"enabled\" : true } }","title":":enablePreCommit"},{"location":"presets-default/#ignoremodulesandtests","text":"Ignore node_modules , bower_components , vendor and various test/tests directories { \"ignorePaths\" : [ \"**/node_modules/**\" , \"**/bower_components/**\" , \"**/vendor/**\" , \"**/examples/**\" , \"**/__tests__/**\" , \"**/test/**\" , \"**/tests/**\" , \"**/__fixtures__/**\" ] }","title":":ignoreModulesAndTests"},{"location":"presets-default/#includenodemodules","text":"Include package.json files found within node_modules folders or bower_components . { \"ignorePaths\" : [] }","title":":includeNodeModules"},{"location":"presets-default/#pinversions","text":"Use version pinning (maintain a single version only and not SemVer ranges) { \"rangeStrategy\" : \"pin\" }","title":":pinVersions"},{"location":"presets-default/#preservesemverranges","text":"Preserve (but continue to upgrade) any existing SemVer ranges { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"*\" ], \"rangeStrategy\" : \"replace\" } ] }","title":":preserveSemverRanges"},{"location":"presets-default/#pinallexceptpeerdependencies","text":"Pin dependency versions for all except peerDependencies { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"*\" ], \"rangeStrategy\" : \"pin\" }, { \"matchDepTypes\" : [ \"engines\" , \"peerDependencies\" ], \"rangeStrategy\" : \"auto\" } ] }","title":":pinAllExceptPeerDependencies"},{"location":"presets-default/#pindependencies","text":"Pin dependency versions where depType=dependencies . Usually applies only to non-dev dependencies in package.json { \"packageRules\" : [ { \"matchDepTypes\" : [ \"dependencies\" ], \"rangeStrategy\" : \"pin\" } ] }","title":":pinDependencies"},{"location":"presets-default/#pindevdependencies","text":"Pin dependency versions for devDependencies { \"packageRules\" : [ { \"matchDepTypes\" : [ \"devDependencies\" ], \"rangeStrategy\" : \"pin\" } ] }","title":":pinDevDependencies"},{"location":"presets-default/#pinonlydevdependencies","text":"Pin dependency versions for devDependencies and retain SemVer ranges for others { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"*\" ], \"rangeStrategy\" : \"replace\" }, { \"matchDepTypes\" : [ \"devDependencies\" ], \"rangeStrategy\" : \"pin\" }, { \"matchDepTypes\" : [ \"peerDependencies\" ], \"rangeStrategy\" : \"widen\" } ] }","title":":pinOnlyDevDependencies"},{"location":"presets-default/#autodetectpinversions","text":"Autodetect whether to pin dependencies or maintain ranges { \"rangeStrategy\" : \"auto\" }","title":":autodetectPinVersions"},{"location":"presets-default/#separatemajorreleases","text":"Separate major versions of dependencies into individual branches/PRs { \"separateMajorMinor\" : true }","title":":separateMajorReleases"},{"location":"presets-default/#separatemultiplemajorreleases","text":"Separate each available major versions of dependencies into individual branches/PRs { \"separateMajorMinor\" : true , \"separateMultipleMajor\" : true }","title":":separateMultipleMajorReleases"},{"location":"presets-default/#separatepatchreleases","text":"Separate patch and minor releases of dependencies into separate PRs { \"separateMinorPatch\" : true }","title":":separatePatchReleases"},{"location":"presets-default/#combinepatchminorreleases","text":"Do not separate patch and minor upgrades into separate PRs for the same dependency { \"separateMinorPatch\" : false }","title":":combinePatchMinorReleases"},{"location":"presets-default/#renovateprefix","text":"Use renovate/ as prefix for all branch names { \"branchPrefix\" : \"renovate/\" }","title":":renovatePrefix"},{"location":"presets-default/#semanticcommittypearg0","text":"Use arg0 as semantic commit type for commit messages and PR titles { \"semanticCommitType\" : \"arg0\" }","title":":semanticCommitType(&lt;arg0&gt;)"},{"location":"presets-default/#semanticprefixchore","text":"Use chore as semantic commit type for commit messages and PR titles { \"extends\" : [ \":semanticCommitType(chore)\" ] }","title":":semanticPrefixChore"},{"location":"presets-default/#semanticprefixfix","text":"Use fix as semantic commit type for commit messages and PR titles { \"extends\" : [ \":semanticCommitType(fix)\" ] }","title":":semanticPrefixFix"},{"location":"presets-default/#disablepeerdependencies","text":"Do not renovate peerDependencies versions/ranges { \"packageRules\" : [ { \"matchDepTypes\" : [ \"peerDependencies\" ], \"enabled\" : false } ] }","title":":disablePeerDependencies"},{"location":"presets-default/#disabledevdependencies","text":"Do not renovate devDependencies versions/ranges { \"packageRules\" : [ { \"matchDepTypes\" : [ \"devDependencies\" ], \"enabled\" : false } ] }","title":":disableDevDependencies"},{"location":"presets-default/#disabledigestupdates","text":"Disable digest and Git hash updates { \"digest\" : { \"enabled\" : false } }","title":":disableDigestUpdates"},{"location":"presets-default/#semanticprefixfixdepschoreothers","text":"If semantic commits detected, use semantic commit type fix for dependencies and chore for all others { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"*\" ], \"semanticCommitType\" : \"chore\" }, { \"matchDepTypes\" : [ \"dependencies\" , \"require\" ], \"semanticCommitType\" : \"fix\" }, { \"matchDatasources\" : [ \"maven\" ], \"matchDepTypes\" : [ \"compile\" , \"provided\" , \"runtime\" , \"system\" , \"import\" , \"parent\" ], \"semanticCommitType\" : \"fix\" } ] }","title":":semanticPrefixFixDepsChoreOthers"},{"location":"presets-default/#semanticcommittypeallarg0","text":"If semantic commits detected, use semantic commit type arg0 for all { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"*\" ], \"semanticCommitType\" : \"arg0\" } ] }","title":":semanticCommitTypeAll(&lt;arg0&gt;)"},{"location":"presets-default/#rebasestaleprs","text":"Rebase existing PRs any time the base branch has been updated { \"rebaseWhen\" : \"behind-base-branch\" }","title":":rebaseStalePrs"},{"location":"presets-default/#primmediately","text":"Raise PRs immediately (after branch is created) { \"prCreation\" : \"immediate\" }","title":":prImmediately"},{"location":"presets-default/#prnotpending","text":"Wait until branch tests have passed or failed before creating the PR { \"prCreation\" : \"not-pending\" }","title":":prNotPending"},{"location":"presets-default/#prhourlylimitnone","text":"Removes rate limit for PR creation per hour { \"prHourlyLimit\" : 0 }","title":":prHourlyLimitNone"},{"location":"presets-default/#prhourlylimit1","text":"Rate limit PR creation to a maximum of one per hour { \"prHourlyLimit\" : 1 }","title":":prHourlyLimit1"},{"location":"presets-default/#prhourlylimit2","text":"Rate limit PR creation to a maximum of two per hour { \"prHourlyLimit\" : 2 }","title":":prHourlyLimit2"},{"location":"presets-default/#prhourlylimit4","text":"Rate limit PR creation to a maximum of four per hour { \"prHourlyLimit\" : 4 }","title":":prHourlyLimit4"},{"location":"presets-default/#prconcurrentlimitnone","text":"Remove limit for open PRs at any time { \"prConcurrentLimit\" : 0 }","title":":prConcurrentLimitNone"},{"location":"presets-default/#prconcurrentlimit10","text":"Limit to maximum 10 open PRs at any time { \"prConcurrentLimit\" : 10 }","title":":prConcurrentLimit10"},{"location":"presets-default/#prconcurrentlimit20","text":"Limit to maximum 20 open PRs at any time { \"prConcurrentLimit\" : 20 }","title":":prConcurrentLimit20"},{"location":"presets-default/#disableratelimiting","text":"Remove hourly and concurrent rate limits { \"prConcurrentLimit\" : 0 , \"prHourlyLimit\" : 0 }","title":":disableRateLimiting"},{"location":"presets-default/#automergedisabled","text":"Disable automerging feature - wait for humans to merge all PRs { \"automerge\" : false }","title":":automergeDisabled"},{"location":"presets-default/#automergedigest","text":"Automerge digest upgrades if they pass tests { \"digest\" : { \"automerge\" : true } }","title":":automergeDigest"},{"location":"presets-default/#automergepatch","text":"Automerge patch upgrades if they pass tests { \"separateMinorPatch\" : true , \"patch\" : { \"automerge\" : true }, \"pin\" : { \"automerge\" : true }, \"lockFileMaintenance\" : { \"automerge\" : true } }","title":":automergePatch"},{"location":"presets-default/#automergeminor","text":"Automerge patch and minor upgrades if they pass tests { \"minor\" : { \"automerge\" : true }, \"patch\" : { \"automerge\" : true }, \"pin\" : { \"automerge\" : true }, \"lockFileMaintenance\" : { \"automerge\" : true } }","title":":automergeMinor"},{"location":"presets-default/#automergemajor","text":"Automerge all upgrades (including major) if they pass tests { \"automerge\" : true }","title":":automergeMajor"},{"location":"presets-default/#automergeall","text":"Automerge all upgrades (including major) if they pass tests { \"automerge\" : true }","title":":automergeAll"},{"location":"presets-default/#automergebranch","text":"If automerging, push the new commit directly to base branch (no PR) { \"automergeType\" : \"branch\" }","title":":automergeBranch"},{"location":"presets-default/#automergepr","text":"Raise a PR first before any automerging { \"automergeType\" : \"pr\" }","title":":automergePr"},{"location":"presets-default/#automergerequireallstatuschecks","text":"Require all status checks to pass before any automerging { \"ignoreTests\" : false }","title":":automergeRequireAllStatusChecks"},{"location":"presets-default/#skipstatuschecks","text":"Skip status checks and automerge right away { \"ignoreTests\" : true }","title":":skipStatusChecks"},{"location":"presets-default/#maintainlockfilesdisabled","text":"Update existing lock files only when package.json is modified { \"lockFileMaintenance\" : { \"enabled\" : false } }","title":":maintainLockFilesDisabled"},{"location":"presets-default/#pindigestsdisabled","text":"Disable pinning of Docker dependency digests { \"pinDigests\" : false }","title":":pinDigestsDisabled"},{"location":"presets-default/#maintainlockfilesweekly","text":"Run lock file maintenance (updates) early Monday mornings { \"lockFileMaintenance\" : { \"enabled\" : true , \"extends\" : [ \"schedule:weekly\" ] } }","title":":maintainLockFilesWeekly"},{"location":"presets-default/#maintainlockfilesmonthly","text":"Run lock file maintenance (updates) on the first day of each month { \"lockFileMaintenance\" : { \"enabled\" : true , \"extends\" : [ \"schedule:monthly\" ] } }","title":":maintainLockFilesMonthly"},{"location":"presets-default/#ignoreunstable","text":"Upgrade to unstable versions only if the existing version is unstable { \"ignoreUnstable\" : true }","title":":ignoreUnstable"},{"location":"presets-default/#respectlatest","text":"Upgrade versions up to the \"latest\" tag in npm registry { \"respectLatest\" : true }","title":":respectLatest"},{"location":"presets-default/#updatenotscheduled","text":"Keep existing branches updated even when not scheduled { \"updateNotScheduled\" : true }","title":":updateNotScheduled"},{"location":"presets-default/#nounscheduledupdates","text":"Make no updates to branches when not scheduled { \"updateNotScheduled\" : false }","title":":noUnscheduledUpdates"},{"location":"presets-default/#automergelinters","text":"Update lint packages automatically if tests pass { \"packageRules\" : [ { \"extends\" : [ \"packages:linters\" ], \"automerge\" : true } ] }","title":":automergeLinters"},{"location":"presets-default/#automergetesters","text":"Update testing packages automatically if tests pass { \"packageRules\" : [ { \"extends\" : [ \"packages:test\" ], \"automerge\" : true } ] }","title":":automergeTesters"},{"location":"presets-default/#automergetypes","text":"Update @types/* packages automatically if tests pass { \"packageRules\" : [ { \"matchPackagePrefixes\" : [ \"@types/\" ], \"automerge\" : true } ] }","title":":automergeTypes"},{"location":"presets-default/#donotpinpackagearg0","text":"Disable version pinning for arg0 { \"packageRules\" : [ { \"matchPackageNames\" : [ \"arg0\" ], \"rangeStrategy\" : \"replace\" } ] }","title":":doNotPinPackage(&lt;arg0&gt;)"},{"location":"presets-default/#pinskipci","text":"Add [skip ci] to commit message body whenever pinning { \"pin\" : { \"commitBody\" : \"[skip ci]\" } }","title":":pinSkipCi"},{"location":"presets-default/#gitsignoff","text":"Append Git Signed-off-by: signature to Git commits. { \"commitBody\" : \"Signed-off-by: {{{gitAuthor}}}\" }","title":":gitSignOff"},{"location":"presets-default/#npm","text":"Keep package.json npm dependencies updated { \"npm\" : { \"enabled\" : true } }","title":":npm"},{"location":"presets-default/#gomod","text":"Enable Go modules support { \"gomod\" : { \"enabled\" : true } }","title":":gomod"},{"location":"presets-default/#onlynpm","text":"Renovate only npm dependencies { \"docker\" : { \"enabled\" : false }, \"meteor\" : { \"enabled\" : false } }","title":":onlyNpm"},{"location":"presets-default/#docker","text":"Keep Dockerfile FROM sources updated { \"docker\" : { \"enabled\" : true } }","title":":docker"},{"location":"presets-default/#meteor","text":"Keep Meteor Npm.depends packages updated { \"meteor\" : { \"enabled\" : true } }","title":":meteor"},{"location":"presets-default/#grouparg0-arg1","text":"Group arg1 packages into same branch/PR { \"packageRules\" : [ { \"extends\" : [ \"arg0\" ], \"groupName\" : \"arg1\" } ] }","title":":group(&lt;arg0&gt;, &lt;arg1&gt;)"},{"location":"presets-default/#labelarg0","text":"Apply label arg0 to PRs { \"labels\" : [ \"arg0\" ] }","title":":label(&lt;arg0&gt;)"},{"location":"presets-default/#labelsarg0-arg1","text":"Apply labels arg0 and arg1 to PRs { \"labels\" : [ \"arg0\" , \"arg1\" ] }","title":":labels(&lt;arg0&gt;, &lt;arg1&gt;)"},{"location":"presets-default/#assigneearg0","text":"Assign PRs to arg0 { \"assignees\" : [ \"arg0\" ] }","title":":assignee(&lt;arg0&gt;)"},{"location":"presets-default/#reviewerarg0","text":"Add arg0 as reviewer for PRs { \"reviewers\" : [ \"arg0\" ] }","title":":reviewer(&lt;arg0&gt;)"},{"location":"presets-default/#assignandreviewarg0","text":"Set arg0 as assignee and reviewer of PRs { \"extends\" : [ \":assignee(arg0)\" , \":reviewer(arg0)\" ] }","title":":assignAndReview(&lt;arg0&gt;)"},{"location":"presets-default/#enablevulnerabilityalerts","text":"Raise PR when vulnerability alerts are detected { \"vulnerabilityAlerts\" : { \"enabled\" : true } }","title":":enableVulnerabilityAlerts"},{"location":"presets-default/#enablevulnerabilityalertswithlabelarg0","text":"Raise PR when vulnerability alerts are detected with label arg0 { \"vulnerabilityAlerts\" : { \"enabled\" : true , \"labels\" : [ \"arg0\" ] } }","title":":enableVulnerabilityAlertsWithLabel(&lt;arg0&gt;)"},{"location":"presets-default/#disablevulnerabilityalerts","text":"Disable vulnerability alerts completely { \"vulnerabilityAlerts\" : { \"enabled\" : false } }","title":":disableVulnerabilityAlerts"},{"location":"presets-default/#semanticcommits","text":"Use semantic prefixes for commit messages and PR titles { \"semanticCommits\" : \"enabled\" }","title":":semanticCommits"},{"location":"presets-default/#semanticcommitsdisabled","text":"Disable semantic prefixes for commit messages and PR titles { \"semanticCommits\" : \"disabled\" }","title":":semanticCommitsDisabled"},{"location":"presets-default/#disablelockfiles","text":"Disable lock file updates { \"updateLockFiles\" : false }","title":":disableLockFiles"},{"location":"presets-default/#semanticcommitscopearg0","text":"Use semantic commit scope arg0 for all commits and PR titles { \"semanticCommitScope\" : \"arg0\" }","title":":semanticCommitScope(&lt;arg0&gt;)"},{"location":"presets-default/#semanticcommitscopedisabled","text":"Disable semantic commit scope for all commits and PR titles { \"semanticCommitScope\" : null }","title":":semanticCommitScopeDisabled"},{"location":"presets-default/#widenpeerdependencies","text":"Always widen peerDependencies SemVer ranges when updating, instead of replacing { \"packageRules\" : [ { \"matchDepTypes\" : [ \"peerDependencies\" ], \"rangeStrategy\" : \"widen\" } ] }","title":":widenPeerDependencies"},{"location":"presets-default/#dependencydashboard","text":"Enable Renovate Dependency Dashboard creation { \"dependencyDashboard\" : true }","title":":dependencyDashboard"},{"location":"presets-default/#disabledependencydashboard","text":"Disable Renovate Dependency Dashboard creation { \"dependencyDashboard\" : false }","title":":disableDependencyDashboard"},{"location":"presets-default/#dependencydashboardapproval","text":"Enable Renovate Dependency Dashboard approval workflow { \"dependencyDashboardApproval\" : true }","title":":dependencyDashboardApproval"},{"location":"presets-default/#timezonearg0","text":"Evaluate schedules according to timezone arg0 { \"timezone\" : \"arg0\" }","title":":timezone(&lt;arg0&gt;)"},{"location":"presets-default/#pathsemanticcommittypearg0-arg1","text":"Use semanticCommitType arg0 for all package files matching path arg1 { \"packageRules\" : [ { \"matchPaths\" : [ \"arg0\" ], \"semanticCommitType\" : \"arg1\" } ] }","title":":pathSemanticCommitType(&lt;arg0&gt;, &lt;arg1&gt;)"},{"location":"presets-default/#followtagarg0-arg1","text":"For package arg0 , strictly follow release tag arg1 { \"packageRules\" : [ { \"matchPackageNames\" : [ \"arg0\" ], \"followTag\" : \"arg1\" } ] }","title":":followTag(&lt;arg0&gt;, &lt;arg1&gt;)"},{"location":"presets-default/#githubcomtokenarg0","text":"Use provided token for github.com lookups. Do not configure this if you are already running on github.com { \"hostRules\" : [ { \"matchHost\" : \"github.com\" , \"encrypted\" : { \"token\" : \"arg0\" } } ] }","title":":githubComToken(&lt;arg0&gt;)"},{"location":"presets-default/#disableprcontrols","text":"Remove the checkbox controls from PRs { \"prBodyTemplate\" : \"{{{header}}}{{{table}}}{{{notes}}}{{{changelogs}}}{{{configDescription}}}{{{footer}}}\" }","title":":disablePrControls"},{"location":"presets-docker/","text":"docker:disable \u00b6 Disable Docker updates { \"docker\" : { \"enabled\" : false }, \"docker-compose\" : { \"enabled\" : false }, \"circleci\" : { \"enabled\" : false } } docker:enableMajor \u00b6 Enable Docker major updates { \"packageRules\" : [ { \"matchDatasources\" : [ \"docker\" ], \"matchUpdateTypes\" : [ \"major\" ], \"enabled\" : true } ] } docker:disableMajor \u00b6 Disable Docker major updates { \"packageRules\" : [ { \"matchDatasources\" : [ \"docker\" ], \"matchUpdateTypes\" : [ \"major\" ], \"enabled\" : false } ] } docker:pinDigests \u00b6 Pin Docker digests { \"docker\" : { \"pinDigests\" : true } }","title":"Docker Presets"},{"location":"presets-docker/#dockerdisable","text":"Disable Docker updates { \"docker\" : { \"enabled\" : false }, \"docker-compose\" : { \"enabled\" : false }, \"circleci\" : { \"enabled\" : false } }","title":"docker:disable"},{"location":"presets-docker/#dockerenablemajor","text":"Enable Docker major updates { \"packageRules\" : [ { \"matchDatasources\" : [ \"docker\" ], \"matchUpdateTypes\" : [ \"major\" ], \"enabled\" : true } ] }","title":"docker:enableMajor"},{"location":"presets-docker/#dockerdisablemajor","text":"Disable Docker major updates { \"packageRules\" : [ { \"matchDatasources\" : [ \"docker\" ], \"matchUpdateTypes\" : [ \"major\" ], \"enabled\" : false } ] }","title":"docker:disableMajor"},{"location":"presets-docker/#dockerpindigests","text":"Pin Docker digests { \"docker\" : { \"pinDigests\" : true } }","title":"docker:pinDigests"},{"location":"presets-group/","text":"group:all \u00b6 Group all updates together { \"groupName\" : \"all dependencies\" , \"separateMajorMinor\" : false , \"groupSlug\" : \"all\" , \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"*\" ], \"groupName\" : \"all dependencies\" , \"groupSlug\" : \"all\" } ], \"lockFileMaintenance\" : { \"enabled\" : false } } group:allNonMajor \u00b6 Group all minor and patch updates together { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"*\" ], \"matchUpdateTypes\" : [ \"minor\" , \"patch\" ], \"groupName\" : \"all non-major dependencies\" , \"groupSlug\" : \"all-minor-patch\" } ] } group:nodeJs \u00b6 Group anything that looks like Node.js together so that it's updated together { \"packageRules\" : [ { \"matchDatasources\" : [ \"docker\" ], \"matchPackageNames\" : [ \"node\" ], \"matchPackagePatterns\" : [ \"/node$\" ], \"excludePackageNames\" : [ \"calico/node\" , \"kindest/node\" ], \"commitMessageTopic\" : \"Node.js\" } ] } group:recommended \u00b6 Use curated list of recommended non-monorepo package groupings { \"extends\" : [ \"group:nodeJs\" , \"group:allApollographql\" , \"group:codemirror\" , \"group:fortawesome\" , \"group:fusionjs\" , \"group:glimmer\" , \"group:goOpenapi\" , \"group:hibernateCore\" , \"group:hibernateValidator\" , \"group:hibernateOgm\" , \"group:hibernateCommons\" , \"group:illuminate\" , \"group:jekyllEcosystem\" , \"group:jestPlusTSJest\" , \"group:jestPlusTypes\" , \"group:kubernetes\" , \"group:phpstan\" , \"group:polymer\" , \"group:resilience4j\" , \"group:rubyOmniauth\" , \"group:socketio\" , \"group:springAmqp\" , \"group:springAndroid\" , \"group:springBatch\" , \"group:springBoot\" , \"group:springCloud\" , \"group:springCore\" , \"group:springData\" , \"group:springHateoas\" , \"group:springIntegration\" , \"group:springKafka\" , \"group:springLdap\" , \"group:springMobile\" , \"group:springOsgi\" , \"group:springRestDocs\" , \"group:springRoo\" , \"group:springScala\" , \"group:springSecurity\" , \"group:springSession\" , \"group:springShell\" , \"group:springSocial\" , \"group:springStatemachine\" , \"group:springWebflow\" , \"group:springWs\" , \"group:symfony\" ], \"ignoreDeps\" : [] } group:allApollographql \u00b6 Group all packages published by Apollo GraphQL together { \"packageRules\" : [ { \"extends\" : \"packages:apollographql\" , \"groupName\" : \"Apollo GraphQL packages\" } ] } group:codemirror \u00b6 Group CodeMirror packages together { \"packageRules\" : [ { \"groupName\" : \"CodeMirror\" , \"matchPackagePrefixes\" : [ \"@codemirror/\" ] } ] } group:definitelyTyped \u00b6 Group all @types packages together { \"packageRules\" : [ { \"groupName\" : \"definitelyTyped\" , \"matchPackagePrefixes\" : [ \"@types/\" ] } ] } group:dotNetCore \u00b6 .NET Core Docker containers { \"packageRules\" : [ { \"matchDatasources\" : [ \"docker\" ], \"matchPackagePrefixes\" : [ \"mcr.microsoft.com/dotnet/\" ], \"groupName\" : \".NET Core Docker containers\" } ] } group:fortawesome \u00b6 Group all packages by Font Awesome together { \"packageRules\" : [ { \"groupName\" : \"Font Awesome\" , \"matchPackagePrefixes\" : [ \"@fortawesome/\" ] } ] } group:fusionjs \u00b6 Group Fusion.js packages together { \"matchPackageNames\" : [ \"fusion-cli\" , \"fusion-core\" , \"fusion-test-utils\" , \"fusion-tokens\" ], \"matchPackagePrefixes\" : [ \"fusion-plugin-\" , \"fusion-react\" , \"^usion-apollo\" ] } group:glimmer \u00b6 Group Glimmer.js packages together { \"packageRules\" : [ { \"groupName\" : \"Glimmer.js packages\" , \"groupSlug\" : \"glimmer\" , \"matchPackageNames\" : [ \"@glimmer/component\" , \"@glimmer/tracking\" ] } ] } group:illuminate \u00b6 Group PHP Illuminate packages together { \"packageRules\" : [ { \"matchPackagePrefixes\" : [ \"illuminate/\" ], \"groupName\" : \"illuminate packages\" , \"groupSlug\" : \"illuminate\" } ] } group:symfony \u00b6 Group PHP Symfony packages together { \"packageRules\" : [ { \"matchPackagePrefixes\" : [ \"symfony/\" ], \"groupName\" : \"symfony packages\" , \"groupSlug\" : \"symfony\" } ] } group:phpstan \u00b6 Group PHPStan packages together { \"packageRules\" : [ { \"matchDatasources\" : [ \"packagist\" ], \"matchPackagePatterns\" : [ \"^phpstan\\\\/phpstan$\" , \"\\\\/phpstan-\" ], \"groupName\" : \"PHPStan packages\" } ] } group:polymer \u00b6 Group all @polymer packages together { \"packageRules\" : [ { \"groupName\" : \"polymer packages\" , \"matchPackagePrefixes\" : [ \"@polymer/\" ] } ] } group:hibernateCore \u00b6 Group Java Hibernate Core packages { \"packageRules\" : [ { \"matchPackagePrefixes\" : [ \"org.hibernate:\" ], \"groupName\" : \"hibernate core\" } ] } group:hibernateValidator \u00b6 Group Java Hibernate Validator packages { \"packageRules\" : [ { \"matchPackagePrefixes\" : [ \"org.hibernate.validator:\" ], \"groupName\" : \"hibernate validator\" } ] } group:hibernateOgm \u00b6 Group Java Hibernate OGM packages { \"packageRules\" : [ { \"matchPackagePrefixes\" : [ \"org.hibernate.ogm:\" ], \"groupName\" : \"hibernate ogm\" } ] } group:hibernateCommons \u00b6 Group Java Hibernate Commons packages { \"packageRules\" : [ { \"matchPackagePrefixes\" : [ \"org.hibernate.common:\" ], \"groupName\" : \"hibernate commons\" } ] } group:resilience4j \u00b6 Group Java Resilience4j packages { \"packageRules\" : [ { \"matchPackagePrefixes\" : [ \"io.github.resilience4j:\" ], \"groupName\" : \"resilience4j\" } ] } group:springAmqp \u00b6 Group Java Spring AMQP packages { \"packageRules\" : [ { \"groupName\" : \"spring amqp\" , \"matchPackagePrefixes\" : [ \"org.springframework.amqp:\" ] } ] } group:springAndroid \u00b6 Group Java Spring Android packages { \"packageRules\" : [ { \"groupName\" : \"spring android\" , \"matchPackagePrefixes\" : [ \"org.springframework.android:\" ] } ] } group:springBatch \u00b6 Group Java Spring Batch packages { \"packageRules\" : [ { \"groupName\" : \"spring batch\" , \"matchPackagePrefixes\" : [ \"org.springframework.batch:\" ] } ] } group:springBoot \u00b6 Group Java Spring Boot packages { \"packageRules\" : [ { \"groupName\" : \"spring boot\" , \"matchPackagePrefixes\" : [ \"org.springframework.boot:\" ], \"matchPackageNames\" : [ \"org.springframework.boot\" ] } ] } group:springCloud \u00b6 Group Java Spring Cloud packages { \"packageRules\" : [ { \"groupName\" : \"spring cloud\" , \"matchPackagePrefixes\" : [ \"org.springframework.cloud:\" ] } ] } group:springCore \u00b6 Group Java Spring Core packages { \"packageRules\" : [ { \"groupName\" : \"spring core\" , \"matchPackagePrefixes\" : [ \"org.springframework:\" ] } ] } group:springData \u00b6 Group Java Spring Data packages { \"packageRules\" : [ { \"groupName\" : \"spring data\" , \"matchPackagePrefixes\" : [ \"org.springframework.data:\" ] } ] } group:springHateoas \u00b6 Group Java Spring HATEOAS packages { \"packageRules\" : [ { \"groupName\" : \"spring hateoas\" , \"matchPackagePrefixes\" : [ \"org.springframework.hateoas:\" ] } ] } group:springIntegration \u00b6 Group Java Spring Integration packages { \"packageRules\" : [ { \"groupName\" : \"spring integration\" , \"matchPackagePrefixes\" : [ \"org.springframework.integration:\" ] } ] } group:springKafka \u00b6 Group Java Spring Kafka packages { \"packageRules\" : [ { \"groupName\" : \"spring kafka\" , \"matchPackagePrefixes\" : [ \"org.springframework.kafka:\" ] } ] } group:springLdap \u00b6 Group Java Spring LDAP packages { \"packageRules\" : [ { \"groupName\" : \"spring ldap\" , \"matchPackagePrefixes\" : [ \"org.springframework.ldap:\" ] } ] } group:springMobile \u00b6 Group Java Spring Mobile packages { \"packageRules\" : [ { \"groupName\" : \"spring mobile\" , \"matchPackagePrefixes\" : [ \"org.springframework.mobile:\" ] } ] } group:springOsgi \u00b6 Group Java Spring OSGi packages { \"packageRules\" : [ { \"groupName\" : \"spring osgi\" , \"matchPackagePrefixes\" : [ \"org.springframework.osgi:\" ] } ] } group:springRestDocs \u00b6 Group Java Spring REST Docs packages { \"packageRules\" : [ { \"groupName\" : \"spring restdocs\" , \"matchPackagePrefixes\" : [ \"org.springframework.restdocs:\" ] } ] } group:springRoo \u00b6 Group Java Spring Roo packages { \"packageRules\" : [ { \"groupName\" : \"spring roo\" , \"matchPackagePrefixes\" : [ \"org.springframework.roo:\" ] } ] } group:springScala \u00b6 Group Java Spring Scala packages { \"packageRules\" : [ { \"groupName\" : \"spring scala\" , \"matchPackagePrefixes\" : [ \"org.springframework.scala:\" ] } ] } group:springSecurity \u00b6 Group Java Spring Security packages { \"packageRules\" : [ { \"groupName\" : \"spring security\" , \"matchPackagePrefixes\" : [ \"org.springframework.security:\" ] } ] } group:springSession \u00b6 Group Java Spring Session packages { \"packageRules\" : [ { \"groupName\" : \"spring session\" , \"matchPackagePrefixes\" : [ \"org.springframework.session:\" ] } ] } group:springShell \u00b6 Group Java Spring Shell packages { \"packageRules\" : [ { \"groupName\" : \"spring shell\" , \"matchPackagePrefixes\" : [ \"org.springframework.shell:\" ] } ] } group:springSocial \u00b6 Group Java Spring Social packages { \"packageRules\" : [ { \"groupName\" : \"spring social\" , \"matchPackagePrefixes\" : [ \"org.springframework.social:\" ] } ] } group:springStatemachine \u00b6 Group Java Spring Statemachine packages { \"packageRules\" : [ { \"groupName\" : \"spring statemachine\" , \"matchPackagePrefixes\" : [ \"org.springframework.statemachine:\" ] } ] } group:springWebflow \u00b6 Group Java Spring WebFlow packages { \"packageRules\" : [ { \"groupName\" : \"spring webflow\" , \"matchPackagePrefixes\" : [ \"org.springframework.webflow:\" ] } ] } group:springWs \u00b6 Group Java Spring WS packages { \"packageRules\" : [ { \"groupName\" : \"spring ws\" , \"matchPackagePrefixes\" : [ \"org.springframework.ws:\" ] } ] } group:socketio \u00b6 Group socket.io packages { \"packageRules\" : [ { \"groupName\" : \"socket.io packages\" , \"matchPackagePrefixes\" : [ \"socket.io\" ] } ] } group:postcss \u00b6 Group PostCSS packages together { \"packageRules\" : [ { \"extends\" : \"packages:postcss\" , \"groupName\" : \"postcss packages\" } ] } group:jekyllEcosystem \u00b6 Group Jekyll and related Ruby packages together { \"packageRules\" : [ { \"matchSourceUrlPrefixes\" : [ \"https://github.com/jekyll/\" , \"https://github.com/github/pages-gem\" ], \"groupName\" : \"jekyll ecosystem packages\" } ] } group:rubyOmniauth \u00b6 Group OmniAuth packages together { \"packageRules\" : [ { \"matchDatasources\" : [ \"rubygems\" ], \"matchPackagePrefixes\" : [ \"omniauth\" ], \"groupName\" : \"omniauth packages\" } ] } group:goOpenapi \u00b6 Group go-openapi packages together { \"packageRules\" : [ { \"matchDatasources\" : [ \"go\" ], \"groupName\" : \"go-openapi packages\" , \"groupSlug\" : \"go-openapi\" , \"matchPackagePrefixes\" : [ \"github.com/go-openapi/\" ] } ] } group:kubernetes \u00b6 Group kubernetes packages together { \"packageRules\" : [ { \"matchDatasources\" : [ \"go\" ], \"groupName\" : \"kubernetes packages\" , \"groupSlug\" : \"kubernetes-go\" , \"matchPackagePrefixes\" : [ \"k8s.io/api\" , \"k8s.io/apiextensions-apiserver\" , \"k8s.io/apimachinery\" , \"k8s.io/apiserver\" , \"k8s.io/cli-runtime\" , \"k8s.io/client-go\" , \"k8s.io/cloud-provider\" , \"k8s.io/cluster-bootstrap\" , \"k8s.io/code-generator\" , \"k8s.io/component-base\" , \"k8s.io/controller-manager\" , \"k8s.io/cri-api\" , \"k8s.io/csi-translation-lib\" , \"k8s.io/kube-aggregator\" , \"k8s.io/kube-controller-manager\" , \"k8s.io/kube-proxy\" , \"k8s.io/kube-scheduler\" , \"k8s.io/kubectl\" , \"k8s.io/kubelet\" , \"k8s.io/legacy-cloud-providers\" , \"k8s.io/metrics\" , \"k8s.io/mount-utils\" , \"k8s.io/pod-security-admission\" , \"k8s.io/sample-apiserver\" , \"k8s.io/sample-cli-plugin\" , \"k8s.io/sample-controller\" ] } ] } group:googleapis \u00b6 Group googleapis packages together { \"packageRules\" : [ { \"extends\" : \"packages:googleapis\" , \"groupName\" : \"googleapis packages\" } ] } group:linters \u00b6 Group various lint packages together { \"packageRules\" : [ { \"extends\" : \"packages:linters\" , \"groupName\" : \"linters\" } ] } group:jsUnitTest \u00b6 Group JS unit test packages together { \"packageRules\" : [ { \"extends\" : \"packages:jsUnitTest\" , \"groupName\" : \"JS unit test packages\" } ] } group:jsUnitTestNonMajor \u00b6 Group JS unit test packages together { \"packageRules\" : [ { \"extends\" : \"packages:jsUnitTest\" , \"matchUpdateTypes\" : [ \"minor\" , \"patch\" ], \"groupName\" : \"JS unit test packages\" } ] } group:unitTest \u00b6 Group all unit test packages together { \"packageRules\" : [ { \"extends\" : \"packages:unitTest\" , \"groupName\" : \"unit test packages\" } ] } group:unitTestNonMajor \u00b6 Group all unit test packages together { \"packageRules\" : [ { \"extends\" : \"packages:unitTest\" , \"matchUpdateTypes\" : [ \"minor\" , \"patch\" ], \"groupName\" : \"unit test packages\" } ] } group:jsTest \u00b6 Group JS test packages together { \"packageRules\" : [ { \"extends\" : \"packages:jsTest\" , \"groupName\" : \"JS test packages\" } ] } group:jsTestMonMajor \u00b6 Group non-major JS test package updates together { \"packageRules\" : [ { \"extends\" : \"packages:jsTest\" , \"matchUpdateTypes\" : [ \"minor\" , \"patch\" ], \"groupName\" : \"JS test packages\" } ] } group:test \u00b6 Group all test packages together { \"packageRules\" : [ { \"extends\" : \"packages:test\" , \"groupName\" : \"test packages\" } ] } group:testNonMajor \u00b6 Group all non-major test package updates together { \"packageRules\" : [ { \"extends\" : \"packages:test\" , \"matchUpdateTypes\" : [ \"minor\" , \"patch\" ], \"groupName\" : \"test packages\" } ] } group:jestPlusTSJest \u00b6 Add ts-jest major update to Jest monorepo { \"packageRules\" : [ { \"matchSourceUrlPrefixes\" : [ \"https://github.com/kulshekhar/ts-jest\" ], \"matchUpdateTypes\" : [ \"major\" ], \"groupName\" : \"jest monorepo\" } ] } group:jestPlusTypes \u00b6 Add @types/jest update to Jest monorepo { \"packageRules\" : [ { \"matchPackageNames\" : [ \"@types/jest\" ], \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"jest monorepo\" } ] } group:acotMonorepo \u00b6 Group packages from acot monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:acot\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"acot monorepo\" } ] } group:ag-gridMonorepo \u00b6 Group packages from ag-grid monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:ag-grid\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"ag-grid monorepo\" } ] } group:arcus.event-gridMonorepo \u00b6 Group packages from arcus.event-grid monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:arcus.event-grid\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"arcus.event-grid monorepo\" } ] } group:arcus.securityMonorepo \u00b6 Group packages from arcus.security monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:arcus.security\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"arcus.security monorepo\" } ] } group:arcus.messagingMonorepo \u00b6 Group packages from arcus.messaging monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:arcus.messaging\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"arcus.messaging monorepo\" } ] } group:arcus.observabilityMonorepo \u00b6 Group packages from arcus.observability monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:arcus.observability\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"arcus.observability monorepo\" } ] } group:arcus.webapiMonorepo \u00b6 Group packages from arcus.webapi monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:arcus.webapi\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"arcus.webapi monorepo\" } ] } group:arcus.background-jobsMonorepo \u00b6 Group packages from arcus.background-jobs monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:arcus.background-jobs\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"arcus.background-jobs monorepo\" } ] } group:algolia-react-instantsearchMonorepo \u00b6 Group packages from algolia-react-instantsearch monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:algolia-react-instantsearch\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"algolia-react-instantsearch monorepo\" } ] } group:algoliasearch-client-javascriptMonorepo \u00b6 Group packages from algoliasearch-client-javascript monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:algoliasearch-client-javascript\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"algoliasearch-client-javascript monorepo\" } ] } group:algoliasearch-autocompleteMonorepo \u00b6 Group packages from algoliasearch-autocomplete monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:algoliasearch-autocomplete\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"algoliasearch-autocomplete monorepo\" } ] } group:angular-eslintMonorepo \u00b6 Group packages from angular-eslint monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:angular-eslint\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"angular-eslint monorepo\" } ] } group:apollo-serverMonorepo \u00b6 Group packages from apollo-server monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:apollo-server\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"apollo-server monorepo\" } ] } group:aspnet-api-versioningMonorepo \u00b6 Group packages from aspnet-api-versioning monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:aspnet-api-versioning\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"aspnet-api-versioning monorepo\" } ] } group:aspnet aspnetwebstackMonorepo \u00b6 Group packages from aspnet aspnetwebstack monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:aspnet aspnetwebstack\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"aspnet aspnetwebstack monorepo\" } ] } group:aspnet extensionsMonorepo \u00b6 Group packages from aspnet extensions monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:aspnet extensions\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"aspnet extensions monorepo\" } ] } group:aws-cdkMonorepo \u00b6 Group packages from aws-cdk monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:aws-cdk\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"aws-cdk monorepo\" } ] } group:aws-sdk-js-v3Monorepo \u00b6 Group packages from aws-sdk-js-v3 monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:aws-sdk-js-v3\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"aws-sdk-js-v3 monorepo\" } ] } group:aws-sdk-netMonorepo \u00b6 Group packages from aws-sdk-net monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:aws-sdk-net\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"aws-sdk-net monorepo\" } ] } group:azure azure-libraries-for-netMonorepo \u00b6 Group packages from azure azure-libraries-for-net monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:azure azure-libraries-for-net\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"azure azure-libraries-for-net monorepo\" } ] } group:azure azure-sdk-for-netMonorepo \u00b6 Group packages from azure azure-sdk-for-net monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:azure azure-sdk-for-net\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"azure azure-sdk-for-net monorepo\" } ] } group:azure azure-storage-netMonorepo \u00b6 Group packages from azure azure-storage-net monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:azure azure-storage-net\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"azure azure-storage-net monorepo\" } ] } group:bugsnag-jsMonorepo \u00b6 Group packages from bugsnag-js monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:bugsnag-js\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"bugsnag-js monorepo\" } ] } group:chakra-uiMonorepo \u00b6 Group packages from chakra-ui monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:chakra-ui\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"chakra-ui monorepo\" } ] } group:contentful-rich-textMonorepo \u00b6 Group packages from contentful-rich-text monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:contentful-rich-text\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"contentful-rich-text monorepo\" } ] } group:datadog-browser-sdkMonorepo \u00b6 Group packages from datadog-browser-sdk monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:datadog-browser-sdk\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"datadog-browser-sdk monorepo\" } ] } group:date-ioMonorepo \u00b6 Group packages from date-io monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:date-io\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"date-io monorepo\" } ] } group:denoMonorepo \u00b6 Group packages from deno monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:deno\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"deno monorepo\" } ] } group:devextreme-reactiveMonorepo \u00b6 Group packages from devextreme-reactive monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:devextreme-reactive\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"devextreme-reactive monorepo\" } ] } group:dnd-kitMonorepo \u00b6 Group packages from dnd-kit monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:dnd-kit\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"dnd-kit monorepo\" } ] } group:elastic-apm-agent-rum-jsMonorepo \u00b6 Group packages from elastic-apm-agent-rum-js monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:elastic-apm-agent-rum-js\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"elastic-apm-agent-rum-js monorepo\" } ] } group:electron-forgeMonorepo \u00b6 Group packages from electron-forge monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:electron-forge\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"electron-forge monorepo\" } ] } group:ember-decoratorsMonorepo \u00b6 Group packages from ember-decorators monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:ember-decorators\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"ember-decorators monorepo\" } ] } group:graphql-modulesMonorepo \u00b6 Group packages from graphql-modules monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:graphql-modules\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"graphql-modules monorepo\" } ] } group:groovyMonorepo \u00b6 Group packages from groovy monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:groovy\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"groovy monorepo\" } ] } group:ionic-nativeMonorepo \u00b6 Group packages from ionic-native monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:ionic-native\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"ionic-native monorepo\" } ] } group:jsplumbMonorepo \u00b6 Group packages from jsplumb monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:jsplumb\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"jsplumb monorepo\" } ] } group:mdc-reactMonorepo \u00b6 Group packages from mdc-react monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:mdc-react\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"mdc-react monorepo\" } ] } group:ngx-formlyMonorepo \u00b6 Group packages from ngx-formly monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:ngx-formly\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"ngx-formly monorepo\" } ] } group:ngxs-storeMonorepo \u00b6 Group packages from ngxs-store monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:ngxs-store\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"ngxs-store monorepo\" } ] } group:reach-uiMonorepo \u00b6 Group packages from reach-ui monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:reach-ui\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"reach-ui monorepo\" } ] } group:react-adminMonorepo \u00b6 Group packages from react-admin monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:react-admin\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"react-admin monorepo\" } ] } group:react-apolloMonorepo \u00b6 Group packages from react-apollo monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:react-apollo\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"react-apollo monorepo\" } ] } group:react-dndMonorepo \u00b6 Group packages from react-dnd monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:react-dnd\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"react-dnd monorepo\" } ] } group:react-navigationMonorepo \u00b6 Group packages from react-navigation monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:react-navigation\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"react-navigation monorepo\" } ] } group:react-pageMonorepo \u00b6 Group packages from react-page monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:react-page\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"react-page monorepo\" } ] } group:reactivestack-cookiesMonorepo \u00b6 Group packages from reactivestack-cookies monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:reactivestack-cookies\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"reactivestack-cookies monorepo\" } ] } group:reg-suitMonorepo \u00b6 Group packages from reg-suit monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:reg-suit\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"reg-suit monorepo\" } ] } group:semantic-releaseMonorepo \u00b6 Group packages from semantic-release monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:semantic-release\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"semantic-release monorepo\" } ] } group:system.io.abstractionsMonorepo \u00b6 Group packages from system.io.abstractions monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:system.io.abstractions\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"system.io.abstractions monorepo\" } ] } group:telus-tdsMonorepo \u00b6 Group packages from telus-tds monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:telus-tds\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"telus-tds monorepo\" } ] } group:telus-tds-coreMonorepo \u00b6 Group packages from telus-tds-core monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:telus-tds-core\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"telus-tds-core monorepo\" } ] } group:shopify-app-bridgeMonorepo \u00b6 Group packages from shopify-app-bridge monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:shopify-app-bridge\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"shopify-app-bridge monorepo\" } ] } group:theme-uiMonorepo \u00b6 Group packages from theme-ui monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:theme-ui\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"theme-ui monorepo\" } ] } group:tsoaMonorepo \u00b6 Group packages from tsoa monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:tsoa\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"tsoa monorepo\" } ] } group:typescript-eslintMonorepo \u00b6 Group packages from typescript-eslint monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:typescript-eslint\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"typescript-eslint monorepo\" } ] } group:typography-jsMonorepo \u00b6 Group packages from typography-js monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:typography-js\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"typography-js monorepo\" } ] } group:vue-cliMonorepo \u00b6 Group packages from vue-cli monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:vue-cli\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"vue-cli monorepo\" } ] } group:accountsMonorepo \u00b6 Group packages from accounts monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:accounts\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"accounts monorepo\" } ] } group:angularjsMonorepo \u00b6 Group packages from angularjs monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:angularjs\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"angularjs monorepo\" } ] } group:angularMonorepo \u00b6 Group packages from angular monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:angular\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"angular monorepo\" } ] } group:angular-cliMonorepo \u00b6 Group packages from angular-cli monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:angular-cli\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"angular-cli monorepo\" } ] } group:angularfireMonorepo \u00b6 Group packages from angularfire monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:angularfire\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"angularfire monorepo\" } ] } group:apolloclientMonorepo \u00b6 Group packages from apolloclient monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:apolloclient\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"apolloclient monorepo\" } ] } group:awsappsyncMonorepo \u00b6 Group packages from awsappsync monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:awsappsync\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"awsappsync monorepo\" } ] } group:babelMonorepo \u00b6 Group packages from babel monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:babel\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"babel monorepo\" } ] } group:basetMonorepo \u00b6 Group packages from baset monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:baset\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"baset monorepo\" } ] } group:braveMonorepo \u00b6 Group packages from brave monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:brave\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"brave monorepo\" } ] } group:capacitorMonorepo \u00b6 Group packages from capacitor monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:capacitor\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"capacitor monorepo\" } ] } group:chromelyMonorepo \u00b6 Group packages from chromely monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:chromely\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"chromely monorepo\" } ] } group:clarityMonorepo \u00b6 Group packages from clarity monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:clarity\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"clarity monorepo\" } ] } group:clearscriptMonorepo \u00b6 Group packages from clearscript monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:clearscript\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"clearscript monorepo\" } ] } group:commitlintMonorepo \u00b6 Group packages from commitlint monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:commitlint\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"commitlint monorepo\" } ] } group:docusaurusMonorepo \u00b6 Group packages from docusaurus monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:docusaurus\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"docusaurus monorepo\" } ] } group:dotnetMonorepo \u00b6 Group packages from dotnet monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:dotnet\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"dotnet monorepo\" } ] } group:dotnet-wcfMonorepo \u00b6 Group packages from dotnet-wcf monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:dotnet-wcf\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"dotnet-wcf monorepo\" } ] } group:dotnet-azure-ad-identitymodel-extensionsMonorepo \u00b6 Group packages from dotnet-azure-ad-identitymodel-extensions monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:dotnet-azure-ad-identitymodel-extensions\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"dotnet-azure-ad-identitymodel-extensions monorepo\" } ] } group:dropwizardMonorepo \u00b6 Group packages from dropwizard monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:dropwizard\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"dropwizard monorepo\" } ] } group:emojibaseMonorepo \u00b6 Group packages from emojibase monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:emojibase\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"emojibase monorepo\" } ] } group:emotionMonorepo \u00b6 Group packages from emotion monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:emotion\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"emotion monorepo\" } ] } group:expoMonorepo \u00b6 Group packages from expo monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:expo\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"expo monorepo\" } ] } group:feathersMonorepo \u00b6 Group packages from feathers monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:feathers\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"feathers monorepo\" } ] } group:felaMonorepo \u00b6 Group packages from fela monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:fela\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"fela monorepo\" } ] } group:fimbullinterMonorepo \u00b6 Group packages from fimbullinter monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:fimbullinter\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"fimbullinter monorepo\" } ] } group:flopflipMonorepo \u00b6 Group packages from flopflip monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:flopflip\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"flopflip monorepo\" } ] } group:fontsourceMonorepo \u00b6 Group packages from fontsource monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:fontsource\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"fontsource monorepo\" } ] } group:formatjsMonorepo \u00b6 Group packages from formatjs monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:formatjs\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"formatjs monorepo\" } ] } group:framework7Monorepo \u00b6 Group packages from framework7 monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:framework7\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"framework7 monorepo\" } ] } group:gatsbyMonorepo \u00b6 Group packages from gatsby monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:gatsby\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"gatsby monorepo\" } ] } group:graphqlcodegeneratorMonorepo \u00b6 Group packages from graphqlcodegenerator monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:graphqlcodegenerator\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"graphqlcodegenerator monorepo\" } ] } group:graphql-meshMonorepo \u00b6 Group packages from graphql-mesh monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:graphql-mesh\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"graphql-mesh monorepo\" } ] } group:graphql-toolsMonorepo \u00b6 Group packages from graphql-tools monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:graphql-tools\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"graphql-tools monorepo\" } ] } group:guavaMonorepo \u00b6 Group packages from guava monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:guava\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"guava monorepo\" } ] } group:javahamcrestMonorepo \u00b6 Group packages from javahamcrest monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:javahamcrest\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"javahamcrest monorepo\" } ] } group:HangfireMonorepo \u00b6 Group packages from Hangfire monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:Hangfire\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"Hangfire monorepo\" } ] } group:hapijsMonorepo \u00b6 Group packages from hapijs monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:hapijs\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"hapijs monorepo\" } ] } group:hotchocolateMonorepo \u00b6 Group packages from hotchocolate monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:hotchocolate\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"hotchocolate monorepo\" } ] } group:infrastructure-uiMonorepo \u00b6 Group packages from infrastructure-ui monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:infrastructure-ui\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"infrastructure-ui monorepo\" } ] } group:istanbuljsMonorepo \u00b6 Group packages from istanbuljs monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:istanbuljs\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"istanbuljs monorepo\" } ] } group:jasmineMonorepo \u00b6 Group packages from jasmine monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:jasmine\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"jasmine monorepo\" } ] } group:javascriptengineswitcherMonorepo \u00b6 Group packages from javascriptengineswitcher monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:javascriptengineswitcher\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"javascriptengineswitcher monorepo\" } ] } group:jerseyMonorepo \u00b6 Group packages from jersey monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:jersey\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"jersey monorepo\" } ] } group:jestMonorepo \u00b6 Group packages from jest monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:jest\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"jest monorepo\" } ] } group:junit5Monorepo \u00b6 Group packages from junit5 monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:junit5\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"junit5 monorepo\" } ] } group:lernaMonorepo \u00b6 Group packages from lerna monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:lerna\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"lerna monorepo\" } ] } group:linguijsMonorepo \u00b6 Group packages from linguijs monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:linguijs\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"linguijs monorepo\" } ] } group:lodashMonorepo \u00b6 Group packages from lodash monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:lodash\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"lodash monorepo\" } ] } group:loopbackMonorepo \u00b6 Group packages from loopback monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:loopback\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"loopback monorepo\" } ] } group:lrnwebcomponentsMonorepo \u00b6 Group packages from lrnwebcomponents monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:lrnwebcomponents\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"lrnwebcomponents monorepo\" } ] } group:mapstructMonorepo \u00b6 Group packages from mapstruct monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:mapstruct\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"mapstruct monorepo\" } ] } group:masstransitMonorepo \u00b6 Group packages from masstransit monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:masstransit\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"masstransit monorepo\" } ] } group:material-components-webMonorepo \u00b6 Group packages from material-components-web monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:material-components-web\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"material-components-web monorepo\" } ] } group:mdxMonorepo \u00b6 Group packages from mdx monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:mdx\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"mdx monorepo\" } ] } group:material-uiMonorepo \u00b6 Group packages from material-ui monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:material-ui\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"material-ui monorepo\" } ] } group:mikro-ormMonorepo \u00b6 Group packages from mikro-orm monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:mikro-orm\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"mikro-orm monorepo\" } ] } group:mockitoMonorepo \u00b6 Group packages from mockito monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:mockito\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"mockito monorepo\" } ] } group:mstestMonorepo \u00b6 Group packages from mstest monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:mstest\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"mstest monorepo\" } ] } group:nestMonorepo \u00b6 Group packages from nest monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:nest\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"nest monorepo\" } ] } group:nettyMonorepo \u00b6 Group packages from netty monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:netty\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"netty monorepo\" } ] } group:neutrinoMonorepo \u00b6 Group packages from neutrino monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:neutrino\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"neutrino monorepo\" } ] } group:nexpectMonorepo \u00b6 Group packages from nexpect monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:nexpect\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"nexpect monorepo\" } ] } group:nextjsMonorepo \u00b6 Group packages from nextjs monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:nextjs\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"nextjs monorepo\" } ] } group:nivoMonorepo \u00b6 Group packages from nivo monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:nivo\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"nivo monorepo\" } ] } group:ngrxMonorepo \u00b6 Group packages from ngrx monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:ngrx\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"ngrx monorepo\" } ] } group:nrwlMonorepo \u00b6 Group packages from nrwl monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:nrwl\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"nrwl monorepo\" } ] } group:nswagMonorepo \u00b6 Group packages from nswag monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:nswag\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"nswag monorepo\" } ] } group:nuxtjsMonorepo \u00b6 Group packages from nuxtjs monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:nuxtjs\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"nuxtjs monorepo\" } ] } group:orleansMonorepo \u00b6 Group packages from orleans monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:orleans\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"orleans monorepo\" } ] } group:feignMonorepo \u00b6 Group packages from feign monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:feign\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"feign monorepo\" } ] } group:opentelemetry-jsMonorepo \u00b6 Group packages from opentelemetry-js monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:opentelemetry-js\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"opentelemetry-js monorepo\" } ] } group:opentelemetry-dotnetMonorepo \u00b6 Group packages from opentelemetry-dotnet monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:opentelemetry-dotnet\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"opentelemetry-dotnet monorepo\" } ] } group:opentelemetry-goMonorepo \u00b6 Group packages from opentelemetry-go monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:opentelemetry-go\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"opentelemetry-go monorepo\" } ] } group:parcelMonorepo \u00b6 Group packages from parcel monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:parcel\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"parcel monorepo\" } ] } group:percy-cliMonorepo \u00b6 Group packages from percy-cli monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:percy-cli\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"percy-cli monorepo\" } ] } group:picassojsMonorepo \u00b6 Group packages from picassojs monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:picassojs\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"picassojs monorepo\" } ] } group:pixijsMonorepo \u00b6 Group packages from pixijs monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:pixijs\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"pixijs monorepo\" } ] } group:pnpjsMonorepo \u00b6 Group packages from pnpjs monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:pnpjs\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"pnpjs monorepo\" } ] } group:playwrightMonorepo \u00b6 Group packages from playwright monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:playwright\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"playwright monorepo\" } ] } group:pollyjsMonorepo \u00b6 Group packages from pollyjs monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:pollyjs\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"pollyjs monorepo\" } ] } group:pouchdbMonorepo \u00b6 Group packages from pouchdb monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:pouchdb\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"pouchdb monorepo\" } ] } group:prismaMonorepo \u00b6 Group packages from prisma monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:prisma\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"prisma monorepo\" } ] } group:quartznetMonorepo \u00b6 Group packages from quartznet monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:quartznet\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"quartznet monorepo\" } ] } group:reactMonorepo \u00b6 Group packages from react monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:react\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"react monorepo\" } ] } group:react-routerMonorepo \u00b6 Group packages from react-router monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:react-router\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"react-router monorepo\" } ] } group:reakitMonorepo \u00b6 Group packages from reakit monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:reakit\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"reakit monorepo\" } ] } group:redwoodMonorepo \u00b6 Group packages from redwood monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:redwood\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"redwood monorepo\" } ] } group:remarkMonorepo \u00b6 Group packages from remark monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:remark\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"remark monorepo\" } ] } group:router5Monorepo \u00b6 Group packages from router5 monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:router5\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"router5 monorepo\" } ] } group:rust-futuresMonorepo \u00b6 Group packages from rust-futures monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:rust-futures\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"rust-futures monorepo\" } ] } group:rust-wasm-bindgenMonorepo \u00b6 Group packages from rust-wasm-bindgen monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:rust-wasm-bindgen\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"rust-wasm-bindgen monorepo\" } ] } group:sentry-dotnetMonorepo \u00b6 Group packages from sentry-dotnet monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:sentry-dotnet\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"sentry-dotnet monorepo\" } ] } group:sentry-javascriptMonorepo \u00b6 Group packages from sentry-javascript monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:sentry-javascript\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"sentry-javascript monorepo\" } ] } group:sentry-rubyMonorepo \u00b6 Group packages from sentry-ruby monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:sentry-ruby\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"sentry-ruby monorepo\" } ] } group:sitecore-jssMonorepo \u00b6 Group packages from sitecore-jss monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:sitecore-jss\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"sitecore-jss monorepo\" } ] } group:springfoxMonorepo \u00b6 Group packages from springfox monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:springfox\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"springfox monorepo\" } ] } group:sanityMonorepo \u00b6 Group packages from sanity monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:sanity\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"sanity monorepo\" } ] } group:sendgrid-nodejsMonorepo \u00b6 Group packages from sendgrid-nodejs monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:sendgrid-nodejs\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"sendgrid-nodejs monorepo\" } ] } group:steeltoeMonorepo \u00b6 Group packages from steeltoe monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:steeltoe\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"steeltoe monorepo\" } ] } group:storybookMonorepo \u00b6 Group packages from storybook monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:storybook\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"storybook monorepo\" } ] } group:strapiMonorepo \u00b6 Group packages from strapi monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:strapi\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"strapi monorepo\" } ] } group:stryker-jsMonorepo \u00b6 Group packages from stryker-js monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:stryker-js\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"stryker-js monorepo\" } ] } group:surveyjsMonorepo \u00b6 Group packages from surveyjs monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:surveyjs\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"surveyjs monorepo\" } ] } group:swashbuckle-aspnetcoreMonorepo \u00b6 Group packages from swashbuckle-aspnetcore monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:swashbuckle-aspnetcore\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"swashbuckle-aspnetcore monorepo\" } ] } group:tauriMonorepo \u00b6 Group packages from tauri monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:tauri\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"tauri monorepo\" } ] } group:treatMonorepo \u00b6 Group packages from treat monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:treat\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"treat monorepo\" } ] } group:typefacesMonorepo \u00b6 Group packages from typefaces monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:typefaces\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"typefaces monorepo\" } ] } group:uppyMonorepo \u00b6 Group packages from uppy monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:uppy\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"uppy monorepo\" } ] } group:vueMonorepo \u00b6 Group packages from vue monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:vue\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"vue monorepo\" } ] } group:vuepressMonorepo \u00b6 Group packages from vuepress monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:vuepress\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"vuepress monorepo\" } ] } group:webdriverioMonorepo \u00b6 Group packages from webdriverio monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:webdriverio\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"webdriverio monorepo\" } ] } group:workboxMonorepo \u00b6 Group packages from workbox monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:workbox\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"workbox monorepo\" } ] } group:vstestMonorepo \u00b6 Group packages from vstest monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:vstest\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"vstest monorepo\" } ] } group:xtermMonorepo \u00b6 Group packages from xterm monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:xterm\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"xterm monorepo\" } ] } group:zxing-netMonorepo \u00b6 Group packages from zxing-net monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:zxing-net\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"zxing-net monorepo\" } ] } group:apache-camelMonorepo \u00b6 Group packages from apache-camel monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:apache-camel\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"apache-camel monorepo\" } ] } group:babel6Monorepo \u00b6 Group packages from babel6 monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:babel6\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"babel6 monorepo\" } ] } group:wordpressMonorepo \u00b6 Group packages from wordpress monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:wordpress\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"wordpress monorepo\" } ] } group:angularmaterialMonorepo \u00b6 Group packages from angularmaterial monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:angularmaterial\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"angularmaterial monorepo\" } ] } group:aws-java-sdkMonorepo \u00b6 Group packages from aws-java-sdk monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:aws-java-sdk\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"aws-java-sdk monorepo\" } ] } group:aws-java-sdk-v2Monorepo \u00b6 Group packages from aws-java-sdk-v2 monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:aws-java-sdk-v2\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"aws-java-sdk-v2 monorepo\" } ] } group:embroiderMonorepo \u00b6 Group packages from embroider monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:embroider\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"embroider monorepo\" } ] } group:fullcalendarMonorepo \u00b6 Group packages from fullcalendar monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:fullcalendar\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"fullcalendar monorepo\" } ] } group:monorepos \u00b6 Group known monorepo packages together { \"ignoreDeps\" : [], \"extends\" : [ \"group:acotMonorepo\" , \"group:ag-gridMonorepo\" , \"group:arcus.event-gridMonorepo\" , \"group:arcus.securityMonorepo\" , \"group:arcus.messagingMonorepo\" , \"group:arcus.observabilityMonorepo\" , \"group:arcus.webapiMonorepo\" , \"group:arcus.background-jobsMonorepo\" , \"group:algolia-react-instantsearchMonorepo\" , \"group:algoliasearch-client-javascriptMonorepo\" , \"group:algoliasearch-autocompleteMonorepo\" , \"group:angular-eslintMonorepo\" , \"group:apollo-serverMonorepo\" , \"group:aspnet-api-versioningMonorepo\" , \"group:aspnet aspnetwebstackMonorepo\" , \"group:aspnet extensionsMonorepo\" , \"group:aws-cdkMonorepo\" , \"group:aws-sdk-js-v3Monorepo\" , \"group:aws-sdk-netMonorepo\" , \"group:azure azure-libraries-for-netMonorepo\" , \"group:azure azure-sdk-for-netMonorepo\" , \"group:azure azure-storage-netMonorepo\" , \"group:bugsnag-jsMonorepo\" , \"group:chakra-uiMonorepo\" , \"group:contentful-rich-textMonorepo\" , \"group:datadog-browser-sdkMonorepo\" , \"group:date-ioMonorepo\" , \"group:denoMonorepo\" , \"group:devextreme-reactiveMonorepo\" , \"group:dnd-kitMonorepo\" , \"group:elastic-apm-agent-rum-jsMonorepo\" , \"group:electron-forgeMonorepo\" , \"group:ember-decoratorsMonorepo\" , \"group:graphql-modulesMonorepo\" , \"group:groovyMonorepo\" , \"group:ionic-nativeMonorepo\" , \"group:jsplumbMonorepo\" , \"group:mdc-reactMonorepo\" , \"group:ngx-formlyMonorepo\" , \"group:ngxs-storeMonorepo\" , \"group:reach-uiMonorepo\" , \"group:react-adminMonorepo\" , \"group:react-apolloMonorepo\" , \"group:react-dndMonorepo\" , \"group:react-navigationMonorepo\" , \"group:react-pageMonorepo\" , \"group:reactivestack-cookiesMonorepo\" , \"group:reg-suitMonorepo\" , \"group:semantic-releaseMonorepo\" , \"group:system.io.abstractionsMonorepo\" , \"group:telus-tdsMonorepo\" , \"group:telus-tds-coreMonorepo\" , \"group:shopify-app-bridgeMonorepo\" , \"group:theme-uiMonorepo\" , \"group:tsoaMonorepo\" , \"group:typescript-eslintMonorepo\" , \"group:typography-jsMonorepo\" , \"group:vue-cliMonorepo\" , \"group:accountsMonorepo\" , \"group:angularjsMonorepo\" , \"group:angularMonorepo\" , \"group:angular-cliMonorepo\" , \"group:angularfireMonorepo\" , \"group:apolloclientMonorepo\" , \"group:awsappsyncMonorepo\" , \"group:babelMonorepo\" , \"group:basetMonorepo\" , \"group:braveMonorepo\" , \"group:capacitorMonorepo\" , \"group:chromelyMonorepo\" , \"group:clarityMonorepo\" , \"group:clearscriptMonorepo\" , \"group:commitlintMonorepo\" , \"group:docusaurusMonorepo\" , \"group:dotnetMonorepo\" , \"group:dotnet-wcfMonorepo\" , \"group:dotnet-azure-ad-identitymodel-extensionsMonorepo\" , \"group:dropwizardMonorepo\" , \"group:emojibaseMonorepo\" , \"group:emotionMonorepo\" , \"group:expoMonorepo\" , \"group:feathersMonorepo\" , \"group:felaMonorepo\" , \"group:fimbullinterMonorepo\" , \"group:flopflipMonorepo\" , \"group:fontsourceMonorepo\" , \"group:formatjsMonorepo\" , \"group:framework7Monorepo\" , \"group:gatsbyMonorepo\" , \"group:graphqlcodegeneratorMonorepo\" , \"group:graphql-meshMonorepo\" , \"group:graphql-toolsMonorepo\" , \"group:guavaMonorepo\" , \"group:javahamcrestMonorepo\" , \"group:HangfireMonorepo\" , \"group:hapijsMonorepo\" , \"group:hotchocolateMonorepo\" , \"group:infrastructure-uiMonorepo\" , \"group:istanbuljsMonorepo\" , \"group:jasmineMonorepo\" , \"group:javascriptengineswitcherMonorepo\" , \"group:jerseyMonorepo\" , \"group:jestMonorepo\" , \"group:junit5Monorepo\" , \"group:lernaMonorepo\" , \"group:linguijsMonorepo\" , \"group:lodashMonorepo\" , \"group:loopbackMonorepo\" , \"group:lrnwebcomponentsMonorepo\" , \"group:mapstructMonorepo\" , \"group:masstransitMonorepo\" , \"group:material-components-webMonorepo\" , \"group:mdxMonorepo\" , \"group:material-uiMonorepo\" , \"group:mikro-ormMonorepo\" , \"group:mockitoMonorepo\" , \"group:mstestMonorepo\" , \"group:nestMonorepo\" , \"group:nettyMonorepo\" , \"group:neutrinoMonorepo\" , \"group:nexpectMonorepo\" , \"group:nextjsMonorepo\" , \"group:nivoMonorepo\" , \"group:ngrxMonorepo\" , \"group:nrwlMonorepo\" , \"group:nswagMonorepo\" , \"group:nuxtjsMonorepo\" , \"group:orleansMonorepo\" , \"group:feignMonorepo\" , \"group:opentelemetry-jsMonorepo\" , \"group:opentelemetry-dotnetMonorepo\" , \"group:opentelemetry-goMonorepo\" , \"group:parcelMonorepo\" , \"group:percy-cliMonorepo\" , \"group:picassojsMonorepo\" , \"group:pixijsMonorepo\" , \"group:pnpjsMonorepo\" , \"group:playwrightMonorepo\" , \"group:pollyjsMonorepo\" , \"group:pouchdbMonorepo\" , \"group:prismaMonorepo\" , \"group:quartznetMonorepo\" , \"group:reactMonorepo\" , \"group:react-routerMonorepo\" , \"group:reakitMonorepo\" , \"group:redwoodMonorepo\" , \"group:remarkMonorepo\" , \"group:router5Monorepo\" , \"group:rust-futuresMonorepo\" , \"group:rust-wasm-bindgenMonorepo\" , \"group:sentry-dotnetMonorepo\" , \"group:sentry-javascriptMonorepo\" , \"group:sentry-rubyMonorepo\" , \"group:sitecore-jssMonorepo\" , \"group:springfoxMonorepo\" , \"group:sanityMonorepo\" , \"group:sendgrid-nodejsMonorepo\" , \"group:steeltoeMonorepo\" , \"group:storybookMonorepo\" , \"group:strapiMonorepo\" , \"group:stryker-jsMonorepo\" , \"group:surveyjsMonorepo\" , \"group:swashbuckle-aspnetcoreMonorepo\" , \"group:tauriMonorepo\" , \"group:treatMonorepo\" , \"group:typefacesMonorepo\" , \"group:uppyMonorepo\" , \"group:vueMonorepo\" , \"group:vuepressMonorepo\" , \"group:webdriverioMonorepo\" , \"group:workboxMonorepo\" , \"group:vstestMonorepo\" , \"group:xtermMonorepo\" , \"group:zxing-netMonorepo\" , \"group:apache-camelMonorepo\" , \"group:babel6Monorepo\" , \"group:wordpressMonorepo\" , \"group:angularmaterialMonorepo\" , \"group:aws-java-sdkMonorepo\" , \"group:aws-java-sdk-v2Monorepo\" , \"group:embroiderMonorepo\" , \"group:fullcalendarMonorepo\" ] }","title":"Group Presets"},{"location":"presets-group/#groupall","text":"Group all updates together { \"groupName\" : \"all dependencies\" , \"separateMajorMinor\" : false , \"groupSlug\" : \"all\" , \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"*\" ], \"groupName\" : \"all dependencies\" , \"groupSlug\" : \"all\" } ], \"lockFileMaintenance\" : { \"enabled\" : false } }","title":"group:all"},{"location":"presets-group/#groupallnonmajor","text":"Group all minor and patch updates together { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"*\" ], \"matchUpdateTypes\" : [ \"minor\" , \"patch\" ], \"groupName\" : \"all non-major dependencies\" , \"groupSlug\" : \"all-minor-patch\" } ] }","title":"group:allNonMajor"},{"location":"presets-group/#groupnodejs","text":"Group anything that looks like Node.js together so that it's updated together { \"packageRules\" : [ { \"matchDatasources\" : [ \"docker\" ], \"matchPackageNames\" : [ \"node\" ], \"matchPackagePatterns\" : [ \"/node$\" ], \"excludePackageNames\" : [ \"calico/node\" , \"kindest/node\" ], \"commitMessageTopic\" : \"Node.js\" } ] }","title":"group:nodeJs"},{"location":"presets-group/#grouprecommended","text":"Use curated list of recommended non-monorepo package groupings { \"extends\" : [ \"group:nodeJs\" , \"group:allApollographql\" , \"group:codemirror\" , \"group:fortawesome\" , \"group:fusionjs\" , \"group:glimmer\" , \"group:goOpenapi\" , \"group:hibernateCore\" , \"group:hibernateValidator\" , \"group:hibernateOgm\" , \"group:hibernateCommons\" , \"group:illuminate\" , \"group:jekyllEcosystem\" , \"group:jestPlusTSJest\" , \"group:jestPlusTypes\" , \"group:kubernetes\" , \"group:phpstan\" , \"group:polymer\" , \"group:resilience4j\" , \"group:rubyOmniauth\" , \"group:socketio\" , \"group:springAmqp\" , \"group:springAndroid\" , \"group:springBatch\" , \"group:springBoot\" , \"group:springCloud\" , \"group:springCore\" , \"group:springData\" , \"group:springHateoas\" , \"group:springIntegration\" , \"group:springKafka\" , \"group:springLdap\" , \"group:springMobile\" , \"group:springOsgi\" , \"group:springRestDocs\" , \"group:springRoo\" , \"group:springScala\" , \"group:springSecurity\" , \"group:springSession\" , \"group:springShell\" , \"group:springSocial\" , \"group:springStatemachine\" , \"group:springWebflow\" , \"group:springWs\" , \"group:symfony\" ], \"ignoreDeps\" : [] }","title":"group:recommended"},{"location":"presets-group/#groupallapollographql","text":"Group all packages published by Apollo GraphQL together { \"packageRules\" : [ { \"extends\" : \"packages:apollographql\" , \"groupName\" : \"Apollo GraphQL packages\" } ] }","title":"group:allApollographql"},{"location":"presets-group/#groupcodemirror","text":"Group CodeMirror packages together { \"packageRules\" : [ { \"groupName\" : \"CodeMirror\" , \"matchPackagePrefixes\" : [ \"@codemirror/\" ] } ] }","title":"group:codemirror"},{"location":"presets-group/#groupdefinitelytyped","text":"Group all @types packages together { \"packageRules\" : [ { \"groupName\" : \"definitelyTyped\" , \"matchPackagePrefixes\" : [ \"@types/\" ] } ] }","title":"group:definitelyTyped"},{"location":"presets-group/#groupdotnetcore","text":".NET Core Docker containers { \"packageRules\" : [ { \"matchDatasources\" : [ \"docker\" ], \"matchPackagePrefixes\" : [ \"mcr.microsoft.com/dotnet/\" ], \"groupName\" : \".NET Core Docker containers\" } ] }","title":"group:dotNetCore"},{"location":"presets-group/#groupfortawesome","text":"Group all packages by Font Awesome together { \"packageRules\" : [ { \"groupName\" : \"Font Awesome\" , \"matchPackagePrefixes\" : [ \"@fortawesome/\" ] } ] }","title":"group:fortawesome"},{"location":"presets-group/#groupfusionjs","text":"Group Fusion.js packages together { \"matchPackageNames\" : [ \"fusion-cli\" , \"fusion-core\" , \"fusion-test-utils\" , \"fusion-tokens\" ], \"matchPackagePrefixes\" : [ \"fusion-plugin-\" , \"fusion-react\" , \"^usion-apollo\" ] }","title":"group:fusionjs"},{"location":"presets-group/#groupglimmer","text":"Group Glimmer.js packages together { \"packageRules\" : [ { \"groupName\" : \"Glimmer.js packages\" , \"groupSlug\" : \"glimmer\" , \"matchPackageNames\" : [ \"@glimmer/component\" , \"@glimmer/tracking\" ] } ] }","title":"group:glimmer"},{"location":"presets-group/#groupilluminate","text":"Group PHP Illuminate packages together { \"packageRules\" : [ { \"matchPackagePrefixes\" : [ \"illuminate/\" ], \"groupName\" : \"illuminate packages\" , \"groupSlug\" : \"illuminate\" } ] }","title":"group:illuminate"},{"location":"presets-group/#groupsymfony","text":"Group PHP Symfony packages together { \"packageRules\" : [ { \"matchPackagePrefixes\" : [ \"symfony/\" ], \"groupName\" : \"symfony packages\" , \"groupSlug\" : \"symfony\" } ] }","title":"group:symfony"},{"location":"presets-group/#groupphpstan","text":"Group PHPStan packages together { \"packageRules\" : [ { \"matchDatasources\" : [ \"packagist\" ], \"matchPackagePatterns\" : [ \"^phpstan\\\\/phpstan$\" , \"\\\\/phpstan-\" ], \"groupName\" : \"PHPStan packages\" } ] }","title":"group:phpstan"},{"location":"presets-group/#grouppolymer","text":"Group all @polymer packages together { \"packageRules\" : [ { \"groupName\" : \"polymer packages\" , \"matchPackagePrefixes\" : [ \"@polymer/\" ] } ] }","title":"group:polymer"},{"location":"presets-group/#grouphibernatecore","text":"Group Java Hibernate Core packages { \"packageRules\" : [ { \"matchPackagePrefixes\" : [ \"org.hibernate:\" ], \"groupName\" : \"hibernate core\" } ] }","title":"group:hibernateCore"},{"location":"presets-group/#grouphibernatevalidator","text":"Group Java Hibernate Validator packages { \"packageRules\" : [ { \"matchPackagePrefixes\" : [ \"org.hibernate.validator:\" ], \"groupName\" : \"hibernate validator\" } ] }","title":"group:hibernateValidator"},{"location":"presets-group/#grouphibernateogm","text":"Group Java Hibernate OGM packages { \"packageRules\" : [ { \"matchPackagePrefixes\" : [ \"org.hibernate.ogm:\" ], \"groupName\" : \"hibernate ogm\" } ] }","title":"group:hibernateOgm"},{"location":"presets-group/#grouphibernatecommons","text":"Group Java Hibernate Commons packages { \"packageRules\" : [ { \"matchPackagePrefixes\" : [ \"org.hibernate.common:\" ], \"groupName\" : \"hibernate commons\" } ] }","title":"group:hibernateCommons"},{"location":"presets-group/#groupresilience4j","text":"Group Java Resilience4j packages { \"packageRules\" : [ { \"matchPackagePrefixes\" : [ \"io.github.resilience4j:\" ], \"groupName\" : \"resilience4j\" } ] }","title":"group:resilience4j"},{"location":"presets-group/#groupspringamqp","text":"Group Java Spring AMQP packages { \"packageRules\" : [ { \"groupName\" : \"spring amqp\" , \"matchPackagePrefixes\" : [ \"org.springframework.amqp:\" ] } ] }","title":"group:springAmqp"},{"location":"presets-group/#groupspringandroid","text":"Group Java Spring Android packages { \"packageRules\" : [ { \"groupName\" : \"spring android\" , \"matchPackagePrefixes\" : [ \"org.springframework.android:\" ] } ] }","title":"group:springAndroid"},{"location":"presets-group/#groupspringbatch","text":"Group Java Spring Batch packages { \"packageRules\" : [ { \"groupName\" : \"spring batch\" , \"matchPackagePrefixes\" : [ \"org.springframework.batch:\" ] } ] }","title":"group:springBatch"},{"location":"presets-group/#groupspringboot","text":"Group Java Spring Boot packages { \"packageRules\" : [ { \"groupName\" : \"spring boot\" , \"matchPackagePrefixes\" : [ \"org.springframework.boot:\" ], \"matchPackageNames\" : [ \"org.springframework.boot\" ] } ] }","title":"group:springBoot"},{"location":"presets-group/#groupspringcloud","text":"Group Java Spring Cloud packages { \"packageRules\" : [ { \"groupName\" : \"spring cloud\" , \"matchPackagePrefixes\" : [ \"org.springframework.cloud:\" ] } ] }","title":"group:springCloud"},{"location":"presets-group/#groupspringcore","text":"Group Java Spring Core packages { \"packageRules\" : [ { \"groupName\" : \"spring core\" , \"matchPackagePrefixes\" : [ \"org.springframework:\" ] } ] }","title":"group:springCore"},{"location":"presets-group/#groupspringdata","text":"Group Java Spring Data packages { \"packageRules\" : [ { \"groupName\" : \"spring data\" , \"matchPackagePrefixes\" : [ \"org.springframework.data:\" ] } ] }","title":"group:springData"},{"location":"presets-group/#groupspringhateoas","text":"Group Java Spring HATEOAS packages { \"packageRules\" : [ { \"groupName\" : \"spring hateoas\" , \"matchPackagePrefixes\" : [ \"org.springframework.hateoas:\" ] } ] }","title":"group:springHateoas"},{"location":"presets-group/#groupspringintegration","text":"Group Java Spring Integration packages { \"packageRules\" : [ { \"groupName\" : \"spring integration\" , \"matchPackagePrefixes\" : [ \"org.springframework.integration:\" ] } ] }","title":"group:springIntegration"},{"location":"presets-group/#groupspringkafka","text":"Group Java Spring Kafka packages { \"packageRules\" : [ { \"groupName\" : \"spring kafka\" , \"matchPackagePrefixes\" : [ \"org.springframework.kafka:\" ] } ] }","title":"group:springKafka"},{"location":"presets-group/#groupspringldap","text":"Group Java Spring LDAP packages { \"packageRules\" : [ { \"groupName\" : \"spring ldap\" , \"matchPackagePrefixes\" : [ \"org.springframework.ldap:\" ] } ] }","title":"group:springLdap"},{"location":"presets-group/#groupspringmobile","text":"Group Java Spring Mobile packages { \"packageRules\" : [ { \"groupName\" : \"spring mobile\" , \"matchPackagePrefixes\" : [ \"org.springframework.mobile:\" ] } ] }","title":"group:springMobile"},{"location":"presets-group/#groupspringosgi","text":"Group Java Spring OSGi packages { \"packageRules\" : [ { \"groupName\" : \"spring osgi\" , \"matchPackagePrefixes\" : [ \"org.springframework.osgi:\" ] } ] }","title":"group:springOsgi"},{"location":"presets-group/#groupspringrestdocs","text":"Group Java Spring REST Docs packages { \"packageRules\" : [ { \"groupName\" : \"spring restdocs\" , \"matchPackagePrefixes\" : [ \"org.springframework.restdocs:\" ] } ] }","title":"group:springRestDocs"},{"location":"presets-group/#groupspringroo","text":"Group Java Spring Roo packages { \"packageRules\" : [ { \"groupName\" : \"spring roo\" , \"matchPackagePrefixes\" : [ \"org.springframework.roo:\" ] } ] }","title":"group:springRoo"},{"location":"presets-group/#groupspringscala","text":"Group Java Spring Scala packages { \"packageRules\" : [ { \"groupName\" : \"spring scala\" , \"matchPackagePrefixes\" : [ \"org.springframework.scala:\" ] } ] }","title":"group:springScala"},{"location":"presets-group/#groupspringsecurity","text":"Group Java Spring Security packages { \"packageRules\" : [ { \"groupName\" : \"spring security\" , \"matchPackagePrefixes\" : [ \"org.springframework.security:\" ] } ] }","title":"group:springSecurity"},{"location":"presets-group/#groupspringsession","text":"Group Java Spring Session packages { \"packageRules\" : [ { \"groupName\" : \"spring session\" , \"matchPackagePrefixes\" : [ \"org.springframework.session:\" ] } ] }","title":"group:springSession"},{"location":"presets-group/#groupspringshell","text":"Group Java Spring Shell packages { \"packageRules\" : [ { \"groupName\" : \"spring shell\" , \"matchPackagePrefixes\" : [ \"org.springframework.shell:\" ] } ] }","title":"group:springShell"},{"location":"presets-group/#groupspringsocial","text":"Group Java Spring Social packages { \"packageRules\" : [ { \"groupName\" : \"spring social\" , \"matchPackagePrefixes\" : [ \"org.springframework.social:\" ] } ] }","title":"group:springSocial"},{"location":"presets-group/#groupspringstatemachine","text":"Group Java Spring Statemachine packages { \"packageRules\" : [ { \"groupName\" : \"spring statemachine\" , \"matchPackagePrefixes\" : [ \"org.springframework.statemachine:\" ] } ] }","title":"group:springStatemachine"},{"location":"presets-group/#groupspringwebflow","text":"Group Java Spring WebFlow packages { \"packageRules\" : [ { \"groupName\" : \"spring webflow\" , \"matchPackagePrefixes\" : [ \"org.springframework.webflow:\" ] } ] }","title":"group:springWebflow"},{"location":"presets-group/#groupspringws","text":"Group Java Spring WS packages { \"packageRules\" : [ { \"groupName\" : \"spring ws\" , \"matchPackagePrefixes\" : [ \"org.springframework.ws:\" ] } ] }","title":"group:springWs"},{"location":"presets-group/#groupsocketio","text":"Group socket.io packages { \"packageRules\" : [ { \"groupName\" : \"socket.io packages\" , \"matchPackagePrefixes\" : [ \"socket.io\" ] } ] }","title":"group:socketio"},{"location":"presets-group/#grouppostcss","text":"Group PostCSS packages together { \"packageRules\" : [ { \"extends\" : \"packages:postcss\" , \"groupName\" : \"postcss packages\" } ] }","title":"group:postcss"},{"location":"presets-group/#groupjekyllecosystem","text":"Group Jekyll and related Ruby packages together { \"packageRules\" : [ { \"matchSourceUrlPrefixes\" : [ \"https://github.com/jekyll/\" , \"https://github.com/github/pages-gem\" ], \"groupName\" : \"jekyll ecosystem packages\" } ] }","title":"group:jekyllEcosystem"},{"location":"presets-group/#grouprubyomniauth","text":"Group OmniAuth packages together { \"packageRules\" : [ { \"matchDatasources\" : [ \"rubygems\" ], \"matchPackagePrefixes\" : [ \"omniauth\" ], \"groupName\" : \"omniauth packages\" } ] }","title":"group:rubyOmniauth"},{"location":"presets-group/#groupgoopenapi","text":"Group go-openapi packages together { \"packageRules\" : [ { \"matchDatasources\" : [ \"go\" ], \"groupName\" : \"go-openapi packages\" , \"groupSlug\" : \"go-openapi\" , \"matchPackagePrefixes\" : [ \"github.com/go-openapi/\" ] } ] }","title":"group:goOpenapi"},{"location":"presets-group/#groupkubernetes","text":"Group kubernetes packages together { \"packageRules\" : [ { \"matchDatasources\" : [ \"go\" ], \"groupName\" : \"kubernetes packages\" , \"groupSlug\" : \"kubernetes-go\" , \"matchPackagePrefixes\" : [ \"k8s.io/api\" , \"k8s.io/apiextensions-apiserver\" , \"k8s.io/apimachinery\" , \"k8s.io/apiserver\" , \"k8s.io/cli-runtime\" , \"k8s.io/client-go\" , \"k8s.io/cloud-provider\" , \"k8s.io/cluster-bootstrap\" , \"k8s.io/code-generator\" , \"k8s.io/component-base\" , \"k8s.io/controller-manager\" , \"k8s.io/cri-api\" , \"k8s.io/csi-translation-lib\" , \"k8s.io/kube-aggregator\" , \"k8s.io/kube-controller-manager\" , \"k8s.io/kube-proxy\" , \"k8s.io/kube-scheduler\" , \"k8s.io/kubectl\" , \"k8s.io/kubelet\" , \"k8s.io/legacy-cloud-providers\" , \"k8s.io/metrics\" , \"k8s.io/mount-utils\" , \"k8s.io/pod-security-admission\" , \"k8s.io/sample-apiserver\" , \"k8s.io/sample-cli-plugin\" , \"k8s.io/sample-controller\" ] } ] }","title":"group:kubernetes"},{"location":"presets-group/#groupgoogleapis","text":"Group googleapis packages together { \"packageRules\" : [ { \"extends\" : \"packages:googleapis\" , \"groupName\" : \"googleapis packages\" } ] }","title":"group:googleapis"},{"location":"presets-group/#grouplinters","text":"Group various lint packages together { \"packageRules\" : [ { \"extends\" : \"packages:linters\" , \"groupName\" : \"linters\" } ] }","title":"group:linters"},{"location":"presets-group/#groupjsunittest","text":"Group JS unit test packages together { \"packageRules\" : [ { \"extends\" : \"packages:jsUnitTest\" , \"groupName\" : \"JS unit test packages\" } ] }","title":"group:jsUnitTest"},{"location":"presets-group/#groupjsunittestnonmajor","text":"Group JS unit test packages together { \"packageRules\" : [ { \"extends\" : \"packages:jsUnitTest\" , \"matchUpdateTypes\" : [ \"minor\" , \"patch\" ], \"groupName\" : \"JS unit test packages\" } ] }","title":"group:jsUnitTestNonMajor"},{"location":"presets-group/#groupunittest","text":"Group all unit test packages together { \"packageRules\" : [ { \"extends\" : \"packages:unitTest\" , \"groupName\" : \"unit test packages\" } ] }","title":"group:unitTest"},{"location":"presets-group/#groupunittestnonmajor","text":"Group all unit test packages together { \"packageRules\" : [ { \"extends\" : \"packages:unitTest\" , \"matchUpdateTypes\" : [ \"minor\" , \"patch\" ], \"groupName\" : \"unit test packages\" } ] }","title":"group:unitTestNonMajor"},{"location":"presets-group/#groupjstest","text":"Group JS test packages together { \"packageRules\" : [ { \"extends\" : \"packages:jsTest\" , \"groupName\" : \"JS test packages\" } ] }","title":"group:jsTest"},{"location":"presets-group/#groupjstestmonmajor","text":"Group non-major JS test package updates together { \"packageRules\" : [ { \"extends\" : \"packages:jsTest\" , \"matchUpdateTypes\" : [ \"minor\" , \"patch\" ], \"groupName\" : \"JS test packages\" } ] }","title":"group:jsTestMonMajor"},{"location":"presets-group/#grouptest","text":"Group all test packages together { \"packageRules\" : [ { \"extends\" : \"packages:test\" , \"groupName\" : \"test packages\" } ] }","title":"group:test"},{"location":"presets-group/#grouptestnonmajor","text":"Group all non-major test package updates together { \"packageRules\" : [ { \"extends\" : \"packages:test\" , \"matchUpdateTypes\" : [ \"minor\" , \"patch\" ], \"groupName\" : \"test packages\" } ] }","title":"group:testNonMajor"},{"location":"presets-group/#groupjestplustsjest","text":"Add ts-jest major update to Jest monorepo { \"packageRules\" : [ { \"matchSourceUrlPrefixes\" : [ \"https://github.com/kulshekhar/ts-jest\" ], \"matchUpdateTypes\" : [ \"major\" ], \"groupName\" : \"jest monorepo\" } ] }","title":"group:jestPlusTSJest"},{"location":"presets-group/#groupjestplustypes","text":"Add @types/jest update to Jest monorepo { \"packageRules\" : [ { \"matchPackageNames\" : [ \"@types/jest\" ], \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"jest monorepo\" } ] }","title":"group:jestPlusTypes"},{"location":"presets-group/#groupacotmonorepo","text":"Group packages from acot monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:acot\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"acot monorepo\" } ] }","title":"group:acotMonorepo"},{"location":"presets-group/#groupag-gridmonorepo","text":"Group packages from ag-grid monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:ag-grid\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"ag-grid monorepo\" } ] }","title":"group:ag-gridMonorepo"},{"location":"presets-group/#grouparcusevent-gridmonorepo","text":"Group packages from arcus.event-grid monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:arcus.event-grid\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"arcus.event-grid monorepo\" } ] }","title":"group:arcus.event-gridMonorepo"},{"location":"presets-group/#grouparcussecuritymonorepo","text":"Group packages from arcus.security monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:arcus.security\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"arcus.security monorepo\" } ] }","title":"group:arcus.securityMonorepo"},{"location":"presets-group/#grouparcusmessagingmonorepo","text":"Group packages from arcus.messaging monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:arcus.messaging\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"arcus.messaging monorepo\" } ] }","title":"group:arcus.messagingMonorepo"},{"location":"presets-group/#grouparcusobservabilitymonorepo","text":"Group packages from arcus.observability monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:arcus.observability\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"arcus.observability monorepo\" } ] }","title":"group:arcus.observabilityMonorepo"},{"location":"presets-group/#grouparcuswebapimonorepo","text":"Group packages from arcus.webapi monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:arcus.webapi\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"arcus.webapi monorepo\" } ] }","title":"group:arcus.webapiMonorepo"},{"location":"presets-group/#grouparcusbackground-jobsmonorepo","text":"Group packages from arcus.background-jobs monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:arcus.background-jobs\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"arcus.background-jobs monorepo\" } ] }","title":"group:arcus.background-jobsMonorepo"},{"location":"presets-group/#groupalgolia-react-instantsearchmonorepo","text":"Group packages from algolia-react-instantsearch monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:algolia-react-instantsearch\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"algolia-react-instantsearch monorepo\" } ] }","title":"group:algolia-react-instantsearchMonorepo"},{"location":"presets-group/#groupalgoliasearch-client-javascriptmonorepo","text":"Group packages from algoliasearch-client-javascript monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:algoliasearch-client-javascript\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"algoliasearch-client-javascript monorepo\" } ] }","title":"group:algoliasearch-client-javascriptMonorepo"},{"location":"presets-group/#groupalgoliasearch-autocompletemonorepo","text":"Group packages from algoliasearch-autocomplete monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:algoliasearch-autocomplete\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"algoliasearch-autocomplete monorepo\" } ] }","title":"group:algoliasearch-autocompleteMonorepo"},{"location":"presets-group/#groupangular-eslintmonorepo","text":"Group packages from angular-eslint monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:angular-eslint\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"angular-eslint monorepo\" } ] }","title":"group:angular-eslintMonorepo"},{"location":"presets-group/#groupapollo-servermonorepo","text":"Group packages from apollo-server monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:apollo-server\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"apollo-server monorepo\" } ] }","title":"group:apollo-serverMonorepo"},{"location":"presets-group/#groupaspnet-api-versioningmonorepo","text":"Group packages from aspnet-api-versioning monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:aspnet-api-versioning\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"aspnet-api-versioning monorepo\" } ] }","title":"group:aspnet-api-versioningMonorepo"},{"location":"presets-group/#groupaspnet-aspnetwebstackmonorepo","text":"Group packages from aspnet aspnetwebstack monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:aspnet aspnetwebstack\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"aspnet aspnetwebstack monorepo\" } ] }","title":"group:aspnet aspnetwebstackMonorepo"},{"location":"presets-group/#groupaspnet-extensionsmonorepo","text":"Group packages from aspnet extensions monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:aspnet extensions\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"aspnet extensions monorepo\" } ] }","title":"group:aspnet extensionsMonorepo"},{"location":"presets-group/#groupaws-cdkmonorepo","text":"Group packages from aws-cdk monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:aws-cdk\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"aws-cdk monorepo\" } ] }","title":"group:aws-cdkMonorepo"},{"location":"presets-group/#groupaws-sdk-js-v3monorepo","text":"Group packages from aws-sdk-js-v3 monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:aws-sdk-js-v3\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"aws-sdk-js-v3 monorepo\" } ] }","title":"group:aws-sdk-js-v3Monorepo"},{"location":"presets-group/#groupaws-sdk-netmonorepo","text":"Group packages from aws-sdk-net monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:aws-sdk-net\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"aws-sdk-net monorepo\" } ] }","title":"group:aws-sdk-netMonorepo"},{"location":"presets-group/#groupazure-azure-libraries-for-netmonorepo","text":"Group packages from azure azure-libraries-for-net monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:azure azure-libraries-for-net\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"azure azure-libraries-for-net monorepo\" } ] }","title":"group:azure azure-libraries-for-netMonorepo"},{"location":"presets-group/#groupazure-azure-sdk-for-netmonorepo","text":"Group packages from azure azure-sdk-for-net monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:azure azure-sdk-for-net\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"azure azure-sdk-for-net monorepo\" } ] }","title":"group:azure azure-sdk-for-netMonorepo"},{"location":"presets-group/#groupazure-azure-storage-netmonorepo","text":"Group packages from azure azure-storage-net monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:azure azure-storage-net\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"azure azure-storage-net monorepo\" } ] }","title":"group:azure azure-storage-netMonorepo"},{"location":"presets-group/#groupbugsnag-jsmonorepo","text":"Group packages from bugsnag-js monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:bugsnag-js\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"bugsnag-js monorepo\" } ] }","title":"group:bugsnag-jsMonorepo"},{"location":"presets-group/#groupchakra-uimonorepo","text":"Group packages from chakra-ui monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:chakra-ui\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"chakra-ui monorepo\" } ] }","title":"group:chakra-uiMonorepo"},{"location":"presets-group/#groupcontentful-rich-textmonorepo","text":"Group packages from contentful-rich-text monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:contentful-rich-text\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"contentful-rich-text monorepo\" } ] }","title":"group:contentful-rich-textMonorepo"},{"location":"presets-group/#groupdatadog-browser-sdkmonorepo","text":"Group packages from datadog-browser-sdk monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:datadog-browser-sdk\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"datadog-browser-sdk monorepo\" } ] }","title":"group:datadog-browser-sdkMonorepo"},{"location":"presets-group/#groupdate-iomonorepo","text":"Group packages from date-io monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:date-io\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"date-io monorepo\" } ] }","title":"group:date-ioMonorepo"},{"location":"presets-group/#groupdenomonorepo","text":"Group packages from deno monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:deno\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"deno monorepo\" } ] }","title":"group:denoMonorepo"},{"location":"presets-group/#groupdevextreme-reactivemonorepo","text":"Group packages from devextreme-reactive monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:devextreme-reactive\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"devextreme-reactive monorepo\" } ] }","title":"group:devextreme-reactiveMonorepo"},{"location":"presets-group/#groupdnd-kitmonorepo","text":"Group packages from dnd-kit monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:dnd-kit\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"dnd-kit monorepo\" } ] }","title":"group:dnd-kitMonorepo"},{"location":"presets-group/#groupelastic-apm-agent-rum-jsmonorepo","text":"Group packages from elastic-apm-agent-rum-js monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:elastic-apm-agent-rum-js\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"elastic-apm-agent-rum-js monorepo\" } ] }","title":"group:elastic-apm-agent-rum-jsMonorepo"},{"location":"presets-group/#groupelectron-forgemonorepo","text":"Group packages from electron-forge monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:electron-forge\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"electron-forge monorepo\" } ] }","title":"group:electron-forgeMonorepo"},{"location":"presets-group/#groupember-decoratorsmonorepo","text":"Group packages from ember-decorators monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:ember-decorators\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"ember-decorators monorepo\" } ] }","title":"group:ember-decoratorsMonorepo"},{"location":"presets-group/#groupgraphql-modulesmonorepo","text":"Group packages from graphql-modules monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:graphql-modules\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"graphql-modules monorepo\" } ] }","title":"group:graphql-modulesMonorepo"},{"location":"presets-group/#groupgroovymonorepo","text":"Group packages from groovy monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:groovy\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"groovy monorepo\" } ] }","title":"group:groovyMonorepo"},{"location":"presets-group/#groupionic-nativemonorepo","text":"Group packages from ionic-native monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:ionic-native\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"ionic-native monorepo\" } ] }","title":"group:ionic-nativeMonorepo"},{"location":"presets-group/#groupjsplumbmonorepo","text":"Group packages from jsplumb monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:jsplumb\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"jsplumb monorepo\" } ] }","title":"group:jsplumbMonorepo"},{"location":"presets-group/#groupmdc-reactmonorepo","text":"Group packages from mdc-react monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:mdc-react\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"mdc-react monorepo\" } ] }","title":"group:mdc-reactMonorepo"},{"location":"presets-group/#groupngx-formlymonorepo","text":"Group packages from ngx-formly monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:ngx-formly\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"ngx-formly monorepo\" } ] }","title":"group:ngx-formlyMonorepo"},{"location":"presets-group/#groupngxs-storemonorepo","text":"Group packages from ngxs-store monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:ngxs-store\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"ngxs-store monorepo\" } ] }","title":"group:ngxs-storeMonorepo"},{"location":"presets-group/#groupreach-uimonorepo","text":"Group packages from reach-ui monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:reach-ui\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"reach-ui monorepo\" } ] }","title":"group:reach-uiMonorepo"},{"location":"presets-group/#groupreact-adminmonorepo","text":"Group packages from react-admin monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:react-admin\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"react-admin monorepo\" } ] }","title":"group:react-adminMonorepo"},{"location":"presets-group/#groupreact-apollomonorepo","text":"Group packages from react-apollo monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:react-apollo\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"react-apollo monorepo\" } ] }","title":"group:react-apolloMonorepo"},{"location":"presets-group/#groupreact-dndmonorepo","text":"Group packages from react-dnd monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:react-dnd\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"react-dnd monorepo\" } ] }","title":"group:react-dndMonorepo"},{"location":"presets-group/#groupreact-navigationmonorepo","text":"Group packages from react-navigation monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:react-navigation\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"react-navigation monorepo\" } ] }","title":"group:react-navigationMonorepo"},{"location":"presets-group/#groupreact-pagemonorepo","text":"Group packages from react-page monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:react-page\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"react-page monorepo\" } ] }","title":"group:react-pageMonorepo"},{"location":"presets-group/#groupreactivestack-cookiesmonorepo","text":"Group packages from reactivestack-cookies monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:reactivestack-cookies\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"reactivestack-cookies monorepo\" } ] }","title":"group:reactivestack-cookiesMonorepo"},{"location":"presets-group/#groupreg-suitmonorepo","text":"Group packages from reg-suit monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:reg-suit\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"reg-suit monorepo\" } ] }","title":"group:reg-suitMonorepo"},{"location":"presets-group/#groupsemantic-releasemonorepo","text":"Group packages from semantic-release monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:semantic-release\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"semantic-release monorepo\" } ] }","title":"group:semantic-releaseMonorepo"},{"location":"presets-group/#groupsystemioabstractionsmonorepo","text":"Group packages from system.io.abstractions monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:system.io.abstractions\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"system.io.abstractions monorepo\" } ] }","title":"group:system.io.abstractionsMonorepo"},{"location":"presets-group/#grouptelus-tdsmonorepo","text":"Group packages from telus-tds monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:telus-tds\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"telus-tds monorepo\" } ] }","title":"group:telus-tdsMonorepo"},{"location":"presets-group/#grouptelus-tds-coremonorepo","text":"Group packages from telus-tds-core monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:telus-tds-core\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"telus-tds-core monorepo\" } ] }","title":"group:telus-tds-coreMonorepo"},{"location":"presets-group/#groupshopify-app-bridgemonorepo","text":"Group packages from shopify-app-bridge monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:shopify-app-bridge\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"shopify-app-bridge monorepo\" } ] }","title":"group:shopify-app-bridgeMonorepo"},{"location":"presets-group/#grouptheme-uimonorepo","text":"Group packages from theme-ui monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:theme-ui\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"theme-ui monorepo\" } ] }","title":"group:theme-uiMonorepo"},{"location":"presets-group/#grouptsoamonorepo","text":"Group packages from tsoa monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:tsoa\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"tsoa monorepo\" } ] }","title":"group:tsoaMonorepo"},{"location":"presets-group/#grouptypescript-eslintmonorepo","text":"Group packages from typescript-eslint monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:typescript-eslint\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"typescript-eslint monorepo\" } ] }","title":"group:typescript-eslintMonorepo"},{"location":"presets-group/#grouptypography-jsmonorepo","text":"Group packages from typography-js monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:typography-js\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"typography-js monorepo\" } ] }","title":"group:typography-jsMonorepo"},{"location":"presets-group/#groupvue-climonorepo","text":"Group packages from vue-cli monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:vue-cli\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"vue-cli monorepo\" } ] }","title":"group:vue-cliMonorepo"},{"location":"presets-group/#groupaccountsmonorepo","text":"Group packages from accounts monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:accounts\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"accounts monorepo\" } ] }","title":"group:accountsMonorepo"},{"location":"presets-group/#groupangularjsmonorepo","text":"Group packages from angularjs monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:angularjs\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"angularjs monorepo\" } ] }","title":"group:angularjsMonorepo"},{"location":"presets-group/#groupangularmonorepo","text":"Group packages from angular monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:angular\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"angular monorepo\" } ] }","title":"group:angularMonorepo"},{"location":"presets-group/#groupangular-climonorepo","text":"Group packages from angular-cli monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:angular-cli\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"angular-cli monorepo\" } ] }","title":"group:angular-cliMonorepo"},{"location":"presets-group/#groupangularfiremonorepo","text":"Group packages from angularfire monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:angularfire\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"angularfire monorepo\" } ] }","title":"group:angularfireMonorepo"},{"location":"presets-group/#groupapolloclientmonorepo","text":"Group packages from apolloclient monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:apolloclient\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"apolloclient monorepo\" } ] }","title":"group:apolloclientMonorepo"},{"location":"presets-group/#groupawsappsyncmonorepo","text":"Group packages from awsappsync monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:awsappsync\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"awsappsync monorepo\" } ] }","title":"group:awsappsyncMonorepo"},{"location":"presets-group/#groupbabelmonorepo","text":"Group packages from babel monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:babel\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"babel monorepo\" } ] }","title":"group:babelMonorepo"},{"location":"presets-group/#groupbasetmonorepo","text":"Group packages from baset monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:baset\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"baset monorepo\" } ] }","title":"group:basetMonorepo"},{"location":"presets-group/#groupbravemonorepo","text":"Group packages from brave monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:brave\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"brave monorepo\" } ] }","title":"group:braveMonorepo"},{"location":"presets-group/#groupcapacitormonorepo","text":"Group packages from capacitor monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:capacitor\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"capacitor monorepo\" } ] }","title":"group:capacitorMonorepo"},{"location":"presets-group/#groupchromelymonorepo","text":"Group packages from chromely monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:chromely\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"chromely monorepo\" } ] }","title":"group:chromelyMonorepo"},{"location":"presets-group/#groupclaritymonorepo","text":"Group packages from clarity monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:clarity\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"clarity monorepo\" } ] }","title":"group:clarityMonorepo"},{"location":"presets-group/#groupclearscriptmonorepo","text":"Group packages from clearscript monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:clearscript\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"clearscript monorepo\" } ] }","title":"group:clearscriptMonorepo"},{"location":"presets-group/#groupcommitlintmonorepo","text":"Group packages from commitlint monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:commitlint\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"commitlint monorepo\" } ] }","title":"group:commitlintMonorepo"},{"location":"presets-group/#groupdocusaurusmonorepo","text":"Group packages from docusaurus monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:docusaurus\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"docusaurus monorepo\" } ] }","title":"group:docusaurusMonorepo"},{"location":"presets-group/#groupdotnetmonorepo","text":"Group packages from dotnet monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:dotnet\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"dotnet monorepo\" } ] }","title":"group:dotnetMonorepo"},{"location":"presets-group/#groupdotnet-wcfmonorepo","text":"Group packages from dotnet-wcf monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:dotnet-wcf\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"dotnet-wcf monorepo\" } ] }","title":"group:dotnet-wcfMonorepo"},{"location":"presets-group/#groupdotnet-azure-ad-identitymodel-extensionsmonorepo","text":"Group packages from dotnet-azure-ad-identitymodel-extensions monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:dotnet-azure-ad-identitymodel-extensions\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"dotnet-azure-ad-identitymodel-extensions monorepo\" } ] }","title":"group:dotnet-azure-ad-identitymodel-extensionsMonorepo"},{"location":"presets-group/#groupdropwizardmonorepo","text":"Group packages from dropwizard monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:dropwizard\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"dropwizard monorepo\" } ] }","title":"group:dropwizardMonorepo"},{"location":"presets-group/#groupemojibasemonorepo","text":"Group packages from emojibase monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:emojibase\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"emojibase monorepo\" } ] }","title":"group:emojibaseMonorepo"},{"location":"presets-group/#groupemotionmonorepo","text":"Group packages from emotion monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:emotion\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"emotion monorepo\" } ] }","title":"group:emotionMonorepo"},{"location":"presets-group/#groupexpomonorepo","text":"Group packages from expo monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:expo\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"expo monorepo\" } ] }","title":"group:expoMonorepo"},{"location":"presets-group/#groupfeathersmonorepo","text":"Group packages from feathers monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:feathers\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"feathers monorepo\" } ] }","title":"group:feathersMonorepo"},{"location":"presets-group/#groupfelamonorepo","text":"Group packages from fela monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:fela\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"fela monorepo\" } ] }","title":"group:felaMonorepo"},{"location":"presets-group/#groupfimbullintermonorepo","text":"Group packages from fimbullinter monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:fimbullinter\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"fimbullinter monorepo\" } ] }","title":"group:fimbullinterMonorepo"},{"location":"presets-group/#groupflopflipmonorepo","text":"Group packages from flopflip monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:flopflip\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"flopflip monorepo\" } ] }","title":"group:flopflipMonorepo"},{"location":"presets-group/#groupfontsourcemonorepo","text":"Group packages from fontsource monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:fontsource\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"fontsource monorepo\" } ] }","title":"group:fontsourceMonorepo"},{"location":"presets-group/#groupformatjsmonorepo","text":"Group packages from formatjs monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:formatjs\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"formatjs monorepo\" } ] }","title":"group:formatjsMonorepo"},{"location":"presets-group/#groupframework7monorepo","text":"Group packages from framework7 monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:framework7\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"framework7 monorepo\" } ] }","title":"group:framework7Monorepo"},{"location":"presets-group/#groupgatsbymonorepo","text":"Group packages from gatsby monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:gatsby\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"gatsby monorepo\" } ] }","title":"group:gatsbyMonorepo"},{"location":"presets-group/#groupgraphqlcodegeneratormonorepo","text":"Group packages from graphqlcodegenerator monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:graphqlcodegenerator\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"graphqlcodegenerator monorepo\" } ] }","title":"group:graphqlcodegeneratorMonorepo"},{"location":"presets-group/#groupgraphql-meshmonorepo","text":"Group packages from graphql-mesh monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:graphql-mesh\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"graphql-mesh monorepo\" } ] }","title":"group:graphql-meshMonorepo"},{"location":"presets-group/#groupgraphql-toolsmonorepo","text":"Group packages from graphql-tools monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:graphql-tools\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"graphql-tools monorepo\" } ] }","title":"group:graphql-toolsMonorepo"},{"location":"presets-group/#groupguavamonorepo","text":"Group packages from guava monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:guava\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"guava monorepo\" } ] }","title":"group:guavaMonorepo"},{"location":"presets-group/#groupjavahamcrestmonorepo","text":"Group packages from javahamcrest monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:javahamcrest\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"javahamcrest monorepo\" } ] }","title":"group:javahamcrestMonorepo"},{"location":"presets-group/#grouphangfiremonorepo","text":"Group packages from Hangfire monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:Hangfire\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"Hangfire monorepo\" } ] }","title":"group:HangfireMonorepo"},{"location":"presets-group/#grouphapijsmonorepo","text":"Group packages from hapijs monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:hapijs\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"hapijs monorepo\" } ] }","title":"group:hapijsMonorepo"},{"location":"presets-group/#grouphotchocolatemonorepo","text":"Group packages from hotchocolate monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:hotchocolate\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"hotchocolate monorepo\" } ] }","title":"group:hotchocolateMonorepo"},{"location":"presets-group/#groupinfrastructure-uimonorepo","text":"Group packages from infrastructure-ui monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:infrastructure-ui\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"infrastructure-ui monorepo\" } ] }","title":"group:infrastructure-uiMonorepo"},{"location":"presets-group/#groupistanbuljsmonorepo","text":"Group packages from istanbuljs monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:istanbuljs\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"istanbuljs monorepo\" } ] }","title":"group:istanbuljsMonorepo"},{"location":"presets-group/#groupjasminemonorepo","text":"Group packages from jasmine monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:jasmine\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"jasmine monorepo\" } ] }","title":"group:jasmineMonorepo"},{"location":"presets-group/#groupjavascriptengineswitchermonorepo","text":"Group packages from javascriptengineswitcher monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:javascriptengineswitcher\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"javascriptengineswitcher monorepo\" } ] }","title":"group:javascriptengineswitcherMonorepo"},{"location":"presets-group/#groupjerseymonorepo","text":"Group packages from jersey monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:jersey\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"jersey monorepo\" } ] }","title":"group:jerseyMonorepo"},{"location":"presets-group/#groupjestmonorepo","text":"Group packages from jest monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:jest\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"jest monorepo\" } ] }","title":"group:jestMonorepo"},{"location":"presets-group/#groupjunit5monorepo","text":"Group packages from junit5 monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:junit5\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"junit5 monorepo\" } ] }","title":"group:junit5Monorepo"},{"location":"presets-group/#grouplernamonorepo","text":"Group packages from lerna monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:lerna\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"lerna monorepo\" } ] }","title":"group:lernaMonorepo"},{"location":"presets-group/#grouplinguijsmonorepo","text":"Group packages from linguijs monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:linguijs\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"linguijs monorepo\" } ] }","title":"group:linguijsMonorepo"},{"location":"presets-group/#grouplodashmonorepo","text":"Group packages from lodash monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:lodash\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"lodash monorepo\" } ] }","title":"group:lodashMonorepo"},{"location":"presets-group/#grouploopbackmonorepo","text":"Group packages from loopback monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:loopback\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"loopback monorepo\" } ] }","title":"group:loopbackMonorepo"},{"location":"presets-group/#grouplrnwebcomponentsmonorepo","text":"Group packages from lrnwebcomponents monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:lrnwebcomponents\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"lrnwebcomponents monorepo\" } ] }","title":"group:lrnwebcomponentsMonorepo"},{"location":"presets-group/#groupmapstructmonorepo","text":"Group packages from mapstruct monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:mapstruct\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"mapstruct monorepo\" } ] }","title":"group:mapstructMonorepo"},{"location":"presets-group/#groupmasstransitmonorepo","text":"Group packages from masstransit monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:masstransit\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"masstransit monorepo\" } ] }","title":"group:masstransitMonorepo"},{"location":"presets-group/#groupmaterial-components-webmonorepo","text":"Group packages from material-components-web monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:material-components-web\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"material-components-web monorepo\" } ] }","title":"group:material-components-webMonorepo"},{"location":"presets-group/#groupmdxmonorepo","text":"Group packages from mdx monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:mdx\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"mdx monorepo\" } ] }","title":"group:mdxMonorepo"},{"location":"presets-group/#groupmaterial-uimonorepo","text":"Group packages from material-ui monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:material-ui\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"material-ui monorepo\" } ] }","title":"group:material-uiMonorepo"},{"location":"presets-group/#groupmikro-ormmonorepo","text":"Group packages from mikro-orm monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:mikro-orm\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"mikro-orm monorepo\" } ] }","title":"group:mikro-ormMonorepo"},{"location":"presets-group/#groupmockitomonorepo","text":"Group packages from mockito monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:mockito\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"mockito monorepo\" } ] }","title":"group:mockitoMonorepo"},{"location":"presets-group/#groupmstestmonorepo","text":"Group packages from mstest monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:mstest\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"mstest monorepo\" } ] }","title":"group:mstestMonorepo"},{"location":"presets-group/#groupnestmonorepo","text":"Group packages from nest monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:nest\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"nest monorepo\" } ] }","title":"group:nestMonorepo"},{"location":"presets-group/#groupnettymonorepo","text":"Group packages from netty monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:netty\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"netty monorepo\" } ] }","title":"group:nettyMonorepo"},{"location":"presets-group/#groupneutrinomonorepo","text":"Group packages from neutrino monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:neutrino\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"neutrino monorepo\" } ] }","title":"group:neutrinoMonorepo"},{"location":"presets-group/#groupnexpectmonorepo","text":"Group packages from nexpect monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:nexpect\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"nexpect monorepo\" } ] }","title":"group:nexpectMonorepo"},{"location":"presets-group/#groupnextjsmonorepo","text":"Group packages from nextjs monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:nextjs\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"nextjs monorepo\" } ] }","title":"group:nextjsMonorepo"},{"location":"presets-group/#groupnivomonorepo","text":"Group packages from nivo monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:nivo\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"nivo monorepo\" } ] }","title":"group:nivoMonorepo"},{"location":"presets-group/#groupngrxmonorepo","text":"Group packages from ngrx monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:ngrx\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"ngrx monorepo\" } ] }","title":"group:ngrxMonorepo"},{"location":"presets-group/#groupnrwlmonorepo","text":"Group packages from nrwl monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:nrwl\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"nrwl monorepo\" } ] }","title":"group:nrwlMonorepo"},{"location":"presets-group/#groupnswagmonorepo","text":"Group packages from nswag monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:nswag\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"nswag monorepo\" } ] }","title":"group:nswagMonorepo"},{"location":"presets-group/#groupnuxtjsmonorepo","text":"Group packages from nuxtjs monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:nuxtjs\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"nuxtjs monorepo\" } ] }","title":"group:nuxtjsMonorepo"},{"location":"presets-group/#grouporleansmonorepo","text":"Group packages from orleans monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:orleans\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"orleans monorepo\" } ] }","title":"group:orleansMonorepo"},{"location":"presets-group/#groupfeignmonorepo","text":"Group packages from feign monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:feign\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"feign monorepo\" } ] }","title":"group:feignMonorepo"},{"location":"presets-group/#groupopentelemetry-jsmonorepo","text":"Group packages from opentelemetry-js monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:opentelemetry-js\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"opentelemetry-js monorepo\" } ] }","title":"group:opentelemetry-jsMonorepo"},{"location":"presets-group/#groupopentelemetry-dotnetmonorepo","text":"Group packages from opentelemetry-dotnet monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:opentelemetry-dotnet\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"opentelemetry-dotnet monorepo\" } ] }","title":"group:opentelemetry-dotnetMonorepo"},{"location":"presets-group/#groupopentelemetry-gomonorepo","text":"Group packages from opentelemetry-go monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:opentelemetry-go\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"opentelemetry-go monorepo\" } ] }","title":"group:opentelemetry-goMonorepo"},{"location":"presets-group/#groupparcelmonorepo","text":"Group packages from parcel monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:parcel\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"parcel monorepo\" } ] }","title":"group:parcelMonorepo"},{"location":"presets-group/#grouppercy-climonorepo","text":"Group packages from percy-cli monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:percy-cli\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"percy-cli monorepo\" } ] }","title":"group:percy-cliMonorepo"},{"location":"presets-group/#grouppicassojsmonorepo","text":"Group packages from picassojs monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:picassojs\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"picassojs monorepo\" } ] }","title":"group:picassojsMonorepo"},{"location":"presets-group/#grouppixijsmonorepo","text":"Group packages from pixijs monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:pixijs\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"pixijs monorepo\" } ] }","title":"group:pixijsMonorepo"},{"location":"presets-group/#grouppnpjsmonorepo","text":"Group packages from pnpjs monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:pnpjs\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"pnpjs monorepo\" } ] }","title":"group:pnpjsMonorepo"},{"location":"presets-group/#groupplaywrightmonorepo","text":"Group packages from playwright monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:playwright\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"playwright monorepo\" } ] }","title":"group:playwrightMonorepo"},{"location":"presets-group/#grouppollyjsmonorepo","text":"Group packages from pollyjs monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:pollyjs\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"pollyjs monorepo\" } ] }","title":"group:pollyjsMonorepo"},{"location":"presets-group/#grouppouchdbmonorepo","text":"Group packages from pouchdb monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:pouchdb\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"pouchdb monorepo\" } ] }","title":"group:pouchdbMonorepo"},{"location":"presets-group/#groupprismamonorepo","text":"Group packages from prisma monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:prisma\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"prisma monorepo\" } ] }","title":"group:prismaMonorepo"},{"location":"presets-group/#groupquartznetmonorepo","text":"Group packages from quartznet monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:quartznet\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"quartznet monorepo\" } ] }","title":"group:quartznetMonorepo"},{"location":"presets-group/#groupreactmonorepo","text":"Group packages from react monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:react\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"react monorepo\" } ] }","title":"group:reactMonorepo"},{"location":"presets-group/#groupreact-routermonorepo","text":"Group packages from react-router monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:react-router\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"react-router monorepo\" } ] }","title":"group:react-routerMonorepo"},{"location":"presets-group/#groupreakitmonorepo","text":"Group packages from reakit monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:reakit\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"reakit monorepo\" } ] }","title":"group:reakitMonorepo"},{"location":"presets-group/#groupredwoodmonorepo","text":"Group packages from redwood monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:redwood\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"redwood monorepo\" } ] }","title":"group:redwoodMonorepo"},{"location":"presets-group/#groupremarkmonorepo","text":"Group packages from remark monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:remark\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"remark monorepo\" } ] }","title":"group:remarkMonorepo"},{"location":"presets-group/#grouprouter5monorepo","text":"Group packages from router5 monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:router5\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"router5 monorepo\" } ] }","title":"group:router5Monorepo"},{"location":"presets-group/#grouprust-futuresmonorepo","text":"Group packages from rust-futures monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:rust-futures\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"rust-futures monorepo\" } ] }","title":"group:rust-futuresMonorepo"},{"location":"presets-group/#grouprust-wasm-bindgenmonorepo","text":"Group packages from rust-wasm-bindgen monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:rust-wasm-bindgen\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"rust-wasm-bindgen monorepo\" } ] }","title":"group:rust-wasm-bindgenMonorepo"},{"location":"presets-group/#groupsentry-dotnetmonorepo","text":"Group packages from sentry-dotnet monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:sentry-dotnet\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"sentry-dotnet monorepo\" } ] }","title":"group:sentry-dotnetMonorepo"},{"location":"presets-group/#groupsentry-javascriptmonorepo","text":"Group packages from sentry-javascript monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:sentry-javascript\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"sentry-javascript monorepo\" } ] }","title":"group:sentry-javascriptMonorepo"},{"location":"presets-group/#groupsentry-rubymonorepo","text":"Group packages from sentry-ruby monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:sentry-ruby\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"sentry-ruby monorepo\" } ] }","title":"group:sentry-rubyMonorepo"},{"location":"presets-group/#groupsitecore-jssmonorepo","text":"Group packages from sitecore-jss monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:sitecore-jss\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"sitecore-jss monorepo\" } ] }","title":"group:sitecore-jssMonorepo"},{"location":"presets-group/#groupspringfoxmonorepo","text":"Group packages from springfox monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:springfox\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"springfox monorepo\" } ] }","title":"group:springfoxMonorepo"},{"location":"presets-group/#groupsanitymonorepo","text":"Group packages from sanity monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:sanity\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"sanity monorepo\" } ] }","title":"group:sanityMonorepo"},{"location":"presets-group/#groupsendgrid-nodejsmonorepo","text":"Group packages from sendgrid-nodejs monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:sendgrid-nodejs\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"sendgrid-nodejs monorepo\" } ] }","title":"group:sendgrid-nodejsMonorepo"},{"location":"presets-group/#groupsteeltoemonorepo","text":"Group packages from steeltoe monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:steeltoe\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"steeltoe monorepo\" } ] }","title":"group:steeltoeMonorepo"},{"location":"presets-group/#groupstorybookmonorepo","text":"Group packages from storybook monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:storybook\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"storybook monorepo\" } ] }","title":"group:storybookMonorepo"},{"location":"presets-group/#groupstrapimonorepo","text":"Group packages from strapi monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:strapi\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"strapi monorepo\" } ] }","title":"group:strapiMonorepo"},{"location":"presets-group/#groupstryker-jsmonorepo","text":"Group packages from stryker-js monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:stryker-js\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"stryker-js monorepo\" } ] }","title":"group:stryker-jsMonorepo"},{"location":"presets-group/#groupsurveyjsmonorepo","text":"Group packages from surveyjs monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:surveyjs\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"surveyjs monorepo\" } ] }","title":"group:surveyjsMonorepo"},{"location":"presets-group/#groupswashbuckle-aspnetcoremonorepo","text":"Group packages from swashbuckle-aspnetcore monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:swashbuckle-aspnetcore\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"swashbuckle-aspnetcore monorepo\" } ] }","title":"group:swashbuckle-aspnetcoreMonorepo"},{"location":"presets-group/#grouptaurimonorepo","text":"Group packages from tauri monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:tauri\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"tauri monorepo\" } ] }","title":"group:tauriMonorepo"},{"location":"presets-group/#grouptreatmonorepo","text":"Group packages from treat monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:treat\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"treat monorepo\" } ] }","title":"group:treatMonorepo"},{"location":"presets-group/#grouptypefacesmonorepo","text":"Group packages from typefaces monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:typefaces\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"typefaces monorepo\" } ] }","title":"group:typefacesMonorepo"},{"location":"presets-group/#groupuppymonorepo","text":"Group packages from uppy monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:uppy\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"uppy monorepo\" } ] }","title":"group:uppyMonorepo"},{"location":"presets-group/#groupvuemonorepo","text":"Group packages from vue monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:vue\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"vue monorepo\" } ] }","title":"group:vueMonorepo"},{"location":"presets-group/#groupvuepressmonorepo","text":"Group packages from vuepress monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:vuepress\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"vuepress monorepo\" } ] }","title":"group:vuepressMonorepo"},{"location":"presets-group/#groupwebdriveriomonorepo","text":"Group packages from webdriverio monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:webdriverio\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"webdriverio monorepo\" } ] }","title":"group:webdriverioMonorepo"},{"location":"presets-group/#groupworkboxmonorepo","text":"Group packages from workbox monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:workbox\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"workbox monorepo\" } ] }","title":"group:workboxMonorepo"},{"location":"presets-group/#groupvstestmonorepo","text":"Group packages from vstest monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:vstest\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"vstest monorepo\" } ] }","title":"group:vstestMonorepo"},{"location":"presets-group/#groupxtermmonorepo","text":"Group packages from xterm monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:xterm\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"xterm monorepo\" } ] }","title":"group:xtermMonorepo"},{"location":"presets-group/#groupzxing-netmonorepo","text":"Group packages from zxing-net monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:zxing-net\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"zxing-net monorepo\" } ] }","title":"group:zxing-netMonorepo"},{"location":"presets-group/#groupapache-camelmonorepo","text":"Group packages from apache-camel monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:apache-camel\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"apache-camel monorepo\" } ] }","title":"group:apache-camelMonorepo"},{"location":"presets-group/#groupbabel6monorepo","text":"Group packages from babel6 monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:babel6\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"babel6 monorepo\" } ] }","title":"group:babel6Monorepo"},{"location":"presets-group/#groupwordpressmonorepo","text":"Group packages from wordpress monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:wordpress\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"wordpress monorepo\" } ] }","title":"group:wordpressMonorepo"},{"location":"presets-group/#groupangularmaterialmonorepo","text":"Group packages from angularmaterial monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:angularmaterial\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"angularmaterial monorepo\" } ] }","title":"group:angularmaterialMonorepo"},{"location":"presets-group/#groupaws-java-sdkmonorepo","text":"Group packages from aws-java-sdk monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:aws-java-sdk\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"aws-java-sdk monorepo\" } ] }","title":"group:aws-java-sdkMonorepo"},{"location":"presets-group/#groupaws-java-sdk-v2monorepo","text":"Group packages from aws-java-sdk-v2 monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:aws-java-sdk-v2\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"aws-java-sdk-v2 monorepo\" } ] }","title":"group:aws-java-sdk-v2Monorepo"},{"location":"presets-group/#groupembroidermonorepo","text":"Group packages from embroider monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:embroider\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"embroider monorepo\" } ] }","title":"group:embroiderMonorepo"},{"location":"presets-group/#groupfullcalendarmonorepo","text":"Group packages from fullcalendar monorepo together { \"packageRules\" : [ { \"extends\" : \"monorepo:fullcalendar\" , \"matchUpdateTypes\" : [ \"digest\" , \"patch\" , \"minor\" , \"major\" ], \"groupName\" : \"fullcalendar monorepo\" } ] }","title":"group:fullcalendarMonorepo"},{"location":"presets-group/#groupmonorepos","text":"Group known monorepo packages together { \"ignoreDeps\" : [], \"extends\" : [ \"group:acotMonorepo\" , \"group:ag-gridMonorepo\" , \"group:arcus.event-gridMonorepo\" , \"group:arcus.securityMonorepo\" , \"group:arcus.messagingMonorepo\" , \"group:arcus.observabilityMonorepo\" , \"group:arcus.webapiMonorepo\" , \"group:arcus.background-jobsMonorepo\" , \"group:algolia-react-instantsearchMonorepo\" , \"group:algoliasearch-client-javascriptMonorepo\" , \"group:algoliasearch-autocompleteMonorepo\" , \"group:angular-eslintMonorepo\" , \"group:apollo-serverMonorepo\" , \"group:aspnet-api-versioningMonorepo\" , \"group:aspnet aspnetwebstackMonorepo\" , \"group:aspnet extensionsMonorepo\" , \"group:aws-cdkMonorepo\" , \"group:aws-sdk-js-v3Monorepo\" , \"group:aws-sdk-netMonorepo\" , \"group:azure azure-libraries-for-netMonorepo\" , \"group:azure azure-sdk-for-netMonorepo\" , \"group:azure azure-storage-netMonorepo\" , \"group:bugsnag-jsMonorepo\" , \"group:chakra-uiMonorepo\" , \"group:contentful-rich-textMonorepo\" , \"group:datadog-browser-sdkMonorepo\" , \"group:date-ioMonorepo\" , \"group:denoMonorepo\" , \"group:devextreme-reactiveMonorepo\" , \"group:dnd-kitMonorepo\" , \"group:elastic-apm-agent-rum-jsMonorepo\" , \"group:electron-forgeMonorepo\" , \"group:ember-decoratorsMonorepo\" , \"group:graphql-modulesMonorepo\" , \"group:groovyMonorepo\" , \"group:ionic-nativeMonorepo\" , \"group:jsplumbMonorepo\" , \"group:mdc-reactMonorepo\" , \"group:ngx-formlyMonorepo\" , \"group:ngxs-storeMonorepo\" , \"group:reach-uiMonorepo\" , \"group:react-adminMonorepo\" , \"group:react-apolloMonorepo\" , \"group:react-dndMonorepo\" , \"group:react-navigationMonorepo\" , \"group:react-pageMonorepo\" , \"group:reactivestack-cookiesMonorepo\" , \"group:reg-suitMonorepo\" , \"group:semantic-releaseMonorepo\" , \"group:system.io.abstractionsMonorepo\" , \"group:telus-tdsMonorepo\" , \"group:telus-tds-coreMonorepo\" , \"group:shopify-app-bridgeMonorepo\" , \"group:theme-uiMonorepo\" , \"group:tsoaMonorepo\" , \"group:typescript-eslintMonorepo\" , \"group:typography-jsMonorepo\" , \"group:vue-cliMonorepo\" , \"group:accountsMonorepo\" , \"group:angularjsMonorepo\" , \"group:angularMonorepo\" , \"group:angular-cliMonorepo\" , \"group:angularfireMonorepo\" , \"group:apolloclientMonorepo\" , \"group:awsappsyncMonorepo\" , \"group:babelMonorepo\" , \"group:basetMonorepo\" , \"group:braveMonorepo\" , \"group:capacitorMonorepo\" , \"group:chromelyMonorepo\" , \"group:clarityMonorepo\" , \"group:clearscriptMonorepo\" , \"group:commitlintMonorepo\" , \"group:docusaurusMonorepo\" , \"group:dotnetMonorepo\" , \"group:dotnet-wcfMonorepo\" , \"group:dotnet-azure-ad-identitymodel-extensionsMonorepo\" , \"group:dropwizardMonorepo\" , \"group:emojibaseMonorepo\" , \"group:emotionMonorepo\" , \"group:expoMonorepo\" , \"group:feathersMonorepo\" , \"group:felaMonorepo\" , \"group:fimbullinterMonorepo\" , \"group:flopflipMonorepo\" , \"group:fontsourceMonorepo\" , \"group:formatjsMonorepo\" , \"group:framework7Monorepo\" , \"group:gatsbyMonorepo\" , \"group:graphqlcodegeneratorMonorepo\" , \"group:graphql-meshMonorepo\" , \"group:graphql-toolsMonorepo\" , \"group:guavaMonorepo\" , \"group:javahamcrestMonorepo\" , \"group:HangfireMonorepo\" , \"group:hapijsMonorepo\" , \"group:hotchocolateMonorepo\" , \"group:infrastructure-uiMonorepo\" , \"group:istanbuljsMonorepo\" , \"group:jasmineMonorepo\" , \"group:javascriptengineswitcherMonorepo\" , \"group:jerseyMonorepo\" , \"group:jestMonorepo\" , \"group:junit5Monorepo\" , \"group:lernaMonorepo\" , \"group:linguijsMonorepo\" , \"group:lodashMonorepo\" , \"group:loopbackMonorepo\" , \"group:lrnwebcomponentsMonorepo\" , \"group:mapstructMonorepo\" , \"group:masstransitMonorepo\" , \"group:material-components-webMonorepo\" , \"group:mdxMonorepo\" , \"group:material-uiMonorepo\" , \"group:mikro-ormMonorepo\" , \"group:mockitoMonorepo\" , \"group:mstestMonorepo\" , \"group:nestMonorepo\" , \"group:nettyMonorepo\" , \"group:neutrinoMonorepo\" , \"group:nexpectMonorepo\" , \"group:nextjsMonorepo\" , \"group:nivoMonorepo\" , \"group:ngrxMonorepo\" , \"group:nrwlMonorepo\" , \"group:nswagMonorepo\" , \"group:nuxtjsMonorepo\" , \"group:orleansMonorepo\" , \"group:feignMonorepo\" , \"group:opentelemetry-jsMonorepo\" , \"group:opentelemetry-dotnetMonorepo\" , \"group:opentelemetry-goMonorepo\" , \"group:parcelMonorepo\" , \"group:percy-cliMonorepo\" , \"group:picassojsMonorepo\" , \"group:pixijsMonorepo\" , \"group:pnpjsMonorepo\" , \"group:playwrightMonorepo\" , \"group:pollyjsMonorepo\" , \"group:pouchdbMonorepo\" , \"group:prismaMonorepo\" , \"group:quartznetMonorepo\" , \"group:reactMonorepo\" , \"group:react-routerMonorepo\" , \"group:reakitMonorepo\" , \"group:redwoodMonorepo\" , \"group:remarkMonorepo\" , \"group:router5Monorepo\" , \"group:rust-futuresMonorepo\" , \"group:rust-wasm-bindgenMonorepo\" , \"group:sentry-dotnetMonorepo\" , \"group:sentry-javascriptMonorepo\" , \"group:sentry-rubyMonorepo\" , \"group:sitecore-jssMonorepo\" , \"group:springfoxMonorepo\" , \"group:sanityMonorepo\" , \"group:sendgrid-nodejsMonorepo\" , \"group:steeltoeMonorepo\" , \"group:storybookMonorepo\" , \"group:strapiMonorepo\" , \"group:stryker-jsMonorepo\" , \"group:surveyjsMonorepo\" , \"group:swashbuckle-aspnetcoreMonorepo\" , \"group:tauriMonorepo\" , \"group:treatMonorepo\" , \"group:typefacesMonorepo\" , \"group:uppyMonorepo\" , \"group:vueMonorepo\" , \"group:vuepressMonorepo\" , \"group:webdriverioMonorepo\" , \"group:workboxMonorepo\" , \"group:vstestMonorepo\" , \"group:xtermMonorepo\" , \"group:zxing-netMonorepo\" , \"group:apache-camelMonorepo\" , \"group:babel6Monorepo\" , \"group:wordpressMonorepo\" , \"group:angularmaterialMonorepo\" , \"group:aws-java-sdkMonorepo\" , \"group:aws-java-sdk-v2Monorepo\" , \"group:embroiderMonorepo\" , \"group:fullcalendarMonorepo\" ] }","title":"group:monorepos"},{"location":"presets-helpers/","text":"helpers:disableTypesNodeMajor \u00b6 Disable major updates to @types/node { \"packageRules\" : [ { \"matchPackageNames\" : [ \"@types/node\" ], \"matchUpdateTypes\" : [ \"major\" ], \"enabled\" : false } ] } helpers:followTypescriptNext \u00b6 Keep typescript version in sync with the next tag { \"extends\" : [ \":followTag(typescript, next)\" ] } helpers:followTypescriptRc \u00b6 Keep typescript version in sync with the rc tag { \"extends\" : [ \":followTag(typescript, rc)\" ] } helpers:pinGitHubActionDigests \u00b6 Pin github-action digests { \"packageRules\" : [ { \"matchDepTypes\" : [ \"action\" ], \"pinDigests\" : true } ] }","title":"Helper Presets"},{"location":"presets-helpers/#helpersdisabletypesnodemajor","text":"Disable major updates to @types/node { \"packageRules\" : [ { \"matchPackageNames\" : [ \"@types/node\" ], \"matchUpdateTypes\" : [ \"major\" ], \"enabled\" : false } ] }","title":"helpers:disableTypesNodeMajor"},{"location":"presets-helpers/#helpersfollowtypescriptnext","text":"Keep typescript version in sync with the next tag { \"extends\" : [ \":followTag(typescript, next)\" ] }","title":"helpers:followTypescriptNext"},{"location":"presets-helpers/#helpersfollowtypescriptrc","text":"Keep typescript version in sync with the rc tag { \"extends\" : [ \":followTag(typescript, rc)\" ] }","title":"helpers:followTypescriptRc"},{"location":"presets-helpers/#helperspingithubactiondigests","text":"Pin github-action digests { \"packageRules\" : [ { \"matchDepTypes\" : [ \"action\" ], \"pinDigests\" : true } ] }","title":"helpers:pinGitHubActionDigests"},{"location":"presets-monorepo/","text":"monorepo:acot \u00b6 acot monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/acot-a11y/acot\" ] } monorepo:ag-grid \u00b6 ag-grid monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/ag-grid/ag-grid\" ] } monorepo:arcus.event-grid \u00b6 arcus.event-grid monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/arcus-azure/arcus.eventgrid\" ] } monorepo:arcus.security \u00b6 arcus.security monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/arcus-azure/arcus.security\" ] } monorepo:arcus.messaging \u00b6 arcus.messaging monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/arcus-azure/arcus.messaging\" ] } monorepo:arcus.observability \u00b6 arcus.observability monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/arcus-azure/arcus.observability\" ] } monorepo:arcus.webapi \u00b6 arcus.webapi monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/arcus-azure/arcus.webapi\" ] } monorepo:arcus.background-jobs \u00b6 arcus.background-jobs monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/arcus-azure/arcus.backgroundjobs\" ] } monorepo:algolia-react-instantsearch \u00b6 algolia-react-instantsearch monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/algolia/react-instantsearch\" ] } monorepo:algoliasearch-client-javascript \u00b6 algoliasearch-client-javascript monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/algolia/algoliasearch-client-javascript\" ] } monorepo:algoliasearch-autocomplete \u00b6 algoliasearch-autocomplete monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/algolia/autocomplete\" ] } monorepo:angular-eslint \u00b6 angular-eslint monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/angular-eslint/angular-eslint\" ] } monorepo:apollo-server \u00b6 apollo-server monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/apollographql/apollo-server\" ] } monorepo:aspnet-api-versioning \u00b6 aspnet-api-versioning monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/Microsoft/aspnet-api-versioning\" ] } monorepo:aspnet aspnetwebstack \u00b6 aspnet aspnetwebstack monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/aspnet/AspNetWebStack\" ] } monorepo:aspnet extensions \u00b6 aspnet extensions monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/aspnet/Extensions\" ] } monorepo:aws-cdk \u00b6 aws-cdk monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/aws/aws-cdk\" ] } monorepo:aws-sdk-js-v3 \u00b6 aws-sdk-js-v3 monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/aws/aws-sdk-js-v3\" ] } monorepo:aws-sdk-net \u00b6 aws-sdk-net monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/aws/aws-sdk-net\" ] } monorepo:azure azure-libraries-for-net \u00b6 azure azure-libraries-for-net monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/Azure/azure-libraries-for-net\" ] } monorepo:azure azure-sdk-for-net \u00b6 azure azure-sdk-for-net monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/Azure/azure-sdk-for-net\" ] } monorepo:azure azure-storage-net \u00b6 azure azure-storage-net monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/Azure/azure-storage-net\" ] } monorepo:bugsnag-js \u00b6 bugsnag-js monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/bugsnag/bugsnag-js\" ] } monorepo:chakra-ui \u00b6 chakra-ui monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/chakra-ui/chakra-ui\" ] } monorepo:contentful-rich-text \u00b6 contentful-rich-text monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/contentful/rich-text\" ] } monorepo:datadog-browser-sdk \u00b6 datadog-browser-sdk monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/DataDog/browser-sdk\" ] } monorepo:date-io \u00b6 date-io monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/dmtrKovalenko/date-io\" ] } monorepo:deno \u00b6 deno monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/denoland/deno\" ] } monorepo:devextreme-reactive \u00b6 devextreme-reactive monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/DevExpress/devextreme-reactive\" ] } monorepo:dnd-kit \u00b6 dnd-kit monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/clauderic/dnd-kit\" ] } monorepo:elastic-apm-agent-rum-js \u00b6 elastic-apm-agent-rum-js monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/elastic/apm-agent-rum-js\" ] } monorepo:electron-forge \u00b6 electron-forge monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/electron-userland/electron-forge\" ] } monorepo:ember-decorators \u00b6 ember-decorators monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/ember-decorators/ember-decorators\" ] } monorepo:graphql-modules \u00b6 graphql-modules monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/Urigo/graphql-modules\" ] } monorepo:groovy \u00b6 groovy monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/apache/groovy\" ] } monorepo:ionic-native \u00b6 ionic-native monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/ionic-team/ionic-native\" ] } monorepo:jsplumb \u00b6 jsplumb monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/jsplumb/jsplumb\" ] } monorepo:mdc-react \u00b6 mdc-react monorepo { \"matchSourceUrlPrefixes\" : [ \"material-components/material-components-web-react\" ] } monorepo:ngx-formly \u00b6 ngx-formly monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/ngx-formly/ngx-formly\" ] } monorepo:ngxs-store \u00b6 ngxs-store monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/ngxs/store\" ] } monorepo:reach-ui \u00b6 reach-ui monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/reach/reach-ui\" ] } monorepo:react-admin \u00b6 react-admin monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/marmelab/react-admin\" ] } monorepo:react-apollo \u00b6 react-apollo monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/apollographql/react-apollo\" ] } monorepo:react-dnd \u00b6 react-dnd monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/react-dnd/react-dnd\" ] } monorepo:react-navigation \u00b6 react-navigation monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/react-navigation/react-navigation\" ] } monorepo:react-page \u00b6 react-page monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/react-page/react-page\" ] } monorepo:reactivestack-cookies \u00b6 reactivestack-cookies monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/reactivestack/cookies\" ] } monorepo:reg-suit \u00b6 reg-suit monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/reg-viz/reg-suit\" ] } monorepo:semantic-release \u00b6 semantic-release monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/semantic-release/\" ] } monorepo:system.io.abstractions \u00b6 system.io.abstractions monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/System-IO-Abstractions/System.IO.Abstractions/\" ] } monorepo:telus-tds \u00b6 telus-tds monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/telusdigital/tds\" ] } monorepo:telus-tds-core \u00b6 telus-tds-core monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/telus/tds-core\" ] } monorepo:shopify-app-bridge \u00b6 shopify-app-bridge monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/Shopify/app-bridge\" ] } monorepo:theme-ui \u00b6 theme-ui monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/system-ui/theme-ui\" ] } monorepo:tsoa \u00b6 tsoa monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/lukeautry/tsoa\" ] } monorepo:typescript-eslint \u00b6 typescript-eslint monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/typescript-eslint/typescript-eslint\" ] } monorepo:typography-js \u00b6 typography-js monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/KyleAMathews/typography.js\" ] } monorepo:vue-cli \u00b6 vue-cli monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/vuejs/vue-cli\" ] } monorepo:accounts \u00b6 accounts monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/accounts-js/accounts\" ] } monorepo:angularjs \u00b6 angularjs monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/angular/angular.js\" ] } monorepo:angular \u00b6 angular monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/angular/angular\" ] } monorepo:angular-cli \u00b6 angular-cli monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/angular/angular-cli\" ] } monorepo:angularfire \u00b6 angularfire monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/angular/angularfire\" ] } monorepo:apolloclient \u00b6 apolloclient monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/apollographql/apollo-client\" ] } monorepo:awsappsync \u00b6 awsappsync monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/awslabs/aws-mobile-appsync-sdk-js\" ] } monorepo:babel \u00b6 babel monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/babel/babel\" ] } monorepo:baset \u00b6 baset monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/igmat/baset\" ] } monorepo:brave \u00b6 brave monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/openzipkin/brave\" ] } monorepo:capacitor \u00b6 capacitor monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/ionic-team/capacitor\" ] } monorepo:chromely \u00b6 chromely monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/chromelyapps/Chromely\" ] } monorepo:clarity \u00b6 clarity monorepo { \"matchPackagePatterns\" : [ \"^@cds/\" , \"^@clr/\" ] } monorepo:clearscript \u00b6 clearscript monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/microsoft/ClearScript\" , \"https://github.com/Microsoft/ClearScript\" ] } monorepo:commitlint \u00b6 commitlint monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/conventional-changelog/commitlint\" ] } monorepo:docusaurus \u00b6 docusaurus monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/facebook/docusaurus\" ] } monorepo:dotnet \u00b6 dotnet monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/dotnet/aspnetcore\" , \"https://github.com/dotnet/efcore\" , \"https://github.com/dotnet/extensions\" , \"https://github.com/dotnet/runtime\" ] } monorepo:dotnet-wcf \u00b6 dotnet-wcf monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/dotnet/wcf\" ] } monorepo:dotnet-azure-ad-identitymodel-extensions \u00b6 dotnet-azure-ad-identitymodel-extensions monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet\" ] } monorepo:dropwizard \u00b6 dropwizard monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/dropwizard/dropwizard\" ] } monorepo:emojibase \u00b6 emojibase monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/milesj/emojibase\" ] } monorepo:emotion \u00b6 emotion monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/emotion-js/emotion\" ] } monorepo:expo \u00b6 expo monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/expo/expo\" ] } monorepo:feathers \u00b6 feathers monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/feathersjs/feathers\" ] } monorepo:fela \u00b6 fela monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/robinweser/fela\" ] } monorepo:fimbullinter \u00b6 fimbullinter monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/fimbullinter/wotan\" ] } monorepo:flopflip \u00b6 flopflip monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/tdeekens/flopflip\" ] } monorepo:fontsource \u00b6 fontsource monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/fontsource/fontsource\" ] } monorepo:formatjs \u00b6 formatjs monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/formatjs/formatjs\" ] } monorepo:framework7 \u00b6 framework7 monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/framework7io/framework7\" ] } monorepo:gatsby \u00b6 gatsby monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/gatsbyjs/gatsby\" ] } monorepo:graphqlcodegenerator \u00b6 graphqlcodegenerator monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/dotansimha/graphql-code-generator\" , \"https://github.com/dotansimha/graphql-codegen\" ] } monorepo:graphql-mesh \u00b6 graphql-mesh monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/Urigo/graphql-mesh\" ] } monorepo:graphql-tools \u00b6 graphql-tools monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/ardatan/graphql-tools\" ] } monorepo:guava \u00b6 guava monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/google/guava\" ] } monorepo:javahamcrest \u00b6 javahamcrest monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/hamcrest/JavaHamcrest\" ] } monorepo:Hangfire \u00b6 Hangfire monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/HangfireIO/Hangfire\" ] } monorepo:hapijs \u00b6 hapijs monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/hapijs\" ] } monorepo:hotchocolate \u00b6 hotchocolate monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/ChilliCream/hotchocolate\" ] } monorepo:infrastructure-ui \u00b6 infrastructure-ui monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/instructure/instructure-ui\" ] } monorepo:istanbuljs \u00b6 istanbuljs monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/istanbuljs/istanbuljs\" ] } monorepo:jasmine \u00b6 jasmine monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/jasmine/jasmine\" ] } monorepo:javascriptengineswitcher \u00b6 javascriptengineswitcher monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/Taritsyn/JavaScriptEngineSwitcher\" ] } monorepo:jersey \u00b6 jersey monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/eclipse-ee4j/jersey\" ] } monorepo:jest \u00b6 jest monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/facebook/jest\" ] } monorepo:junit5 \u00b6 junit5 monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/junit-team/junit5\" ] } monorepo:lerna \u00b6 lerna monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/lerna/lerna\" ] } monorepo:linguijs \u00b6 linguijs monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/lingui/js-lingui\" ] } monorepo:lodash \u00b6 lodash monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/lodash/\" ] } monorepo:loopback \u00b6 loopback monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/strongloop/loopback-next\" , \"https://github.com/loopbackio/loopback-next\" ] } monorepo:lrnwebcomponents \u00b6 lrnwebcomponents monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/elmsln/lrnwebcomponents\" ] } monorepo:mapstruct \u00b6 mapstruct monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/mapstruct/mapstruct\" ] } monorepo:masstransit \u00b6 masstransit monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/MassTransit/MassTransit\" ] } monorepo:material-components-web \u00b6 material-components-web monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/material-components/material-components-web\" ] } monorepo:mdx \u00b6 mdx monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/mdx-js/mdx\" ] } monorepo:material-ui \u00b6 material-ui monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/mui-org/material-ui\" , \"https://github.com/mui/material-ui\" ] } monorepo:mikro-orm \u00b6 mikro-orm monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/mikro-orm/mikro-orm\" ] } monorepo:mockito \u00b6 mockito monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/mockito/mockito\" ] } monorepo:mstest \u00b6 mstest monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/microsoft/testfx\" ] } monorepo:nest \u00b6 nest monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/nestjs/nest\" , \"https://github.com/nestjs/passport\" ] } monorepo:netty \u00b6 netty monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/netty/netty\" ] } monorepo:neutrino \u00b6 neutrino monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/neutrinojs/neutrino\" , \"https://github.com/mozilla-neutrino/neutrino-dev\" ] } monorepo:nexpect \u00b6 nexpect monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/fluffynuts/NExpect\" ] } monorepo:nextjs \u00b6 nextjs monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/zeit/next.js\" , \"https://github.com/vercel/next.js\" ] } monorepo:nivo \u00b6 nivo monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/plouc/nivo\" ] } monorepo:ngrx \u00b6 ngrx monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/ngrx/\" ] } monorepo:nrwl \u00b6 nrwl monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/nrwl/\" ] } monorepo:nswag \u00b6 nswag monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/RicoSuter/NSwag\" ] } monorepo:nuxtjs \u00b6 nuxtjs monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/nuxt/nuxt.js\" ] } monorepo:orleans \u00b6 orleans monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/dotnet/orleans\" ] } monorepo:feign \u00b6 feign monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/OpenFeign/feign\" ] } monorepo:opentelemetry-js \u00b6 opentelemetry-js monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/open-telemetry/opentelemetry-js\" ] } monorepo:opentelemetry-dotnet \u00b6 opentelemetry-dotnet monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/open-telemetry/opentelemetry-dotnet\" ] } monorepo:opentelemetry-go \u00b6 opentelemetry-go monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/open-telemetry/opentelemetry-go\" ] } monorepo:parcel \u00b6 parcel monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/parcel-bundler/parcel\" ] } monorepo:percy-cli \u00b6 percy-cli monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/percy/cli\" ] } monorepo:picassojs \u00b6 picassojs monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/qlik-oss/picasso.js\" ] } monorepo:pixijs \u00b6 pixijs monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/pixijs/pixi.js\" ] } monorepo:pnpjs \u00b6 pnpjs monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/pnp/pnpjs\" ] } monorepo:playwright \u00b6 playwright monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/Microsoft/playwright\" ] } monorepo:pollyjs \u00b6 pollyjs monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/Netflix/pollyjs\" ] } monorepo:pouchdb \u00b6 pouchdb monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/pouchdb/pouchdb\" ] } monorepo:prisma \u00b6 prisma monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/prisma/prisma\" ] } monorepo:quartznet \u00b6 quartznet monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/quartznet/quartznet\" ] } monorepo:react \u00b6 react monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/facebook/react\" ] } monorepo:react-router \u00b6 react-router monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/ReactTraining/react-router\" , \"https://github.com/remix-run/react-router\" ] } monorepo:reakit \u00b6 reakit monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/reakit/reakit\" ] } monorepo:redwood \u00b6 redwood monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/redwoodjs/redwood\" ] } monorepo:remark \u00b6 remark monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/remarkjs/remark\" ] } monorepo:router5 \u00b6 router5 monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/router5/router5\" ] } monorepo:rust-futures \u00b6 rust-futures monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/rust-lang/futures-rs\" ] } monorepo:rust-wasm-bindgen \u00b6 rust-wasm-bindgen monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/rustwasm/wasm-bindgen\" ] } monorepo:sentry-dotnet \u00b6 sentry-dotnet monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/getsentry/sentry-dotnet\" ] } monorepo:sentry-javascript \u00b6 sentry-javascript monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/getsentry/sentry-javascript\" ] } monorepo:sentry-ruby \u00b6 sentry-ruby monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/getsentry/sentry-ruby\" ] } monorepo:sitecore-jss \u00b6 sitecore-jss monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/Sitecore/jss\" ] } monorepo:springfox \u00b6 springfox monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/springfox/springfox\" ] } monorepo:sanity \u00b6 sanity monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/sanity-io/sanity\" ] } monorepo:sendgrid-nodejs \u00b6 sendgrid-nodejs monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/sendgrid/sendgrid-nodejs\" ] } monorepo:steeltoe \u00b6 steeltoe monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/SteeltoeOSS/steeltoe\" ] } monorepo:storybook \u00b6 storybook monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/storybookjs/storybook\" ] } monorepo:strapi \u00b6 strapi monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/strapi/strapi\" ] } monorepo:stryker-js \u00b6 stryker-js monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/stryker-mutator/stryker-js\" ] } monorepo:surveyjs \u00b6 surveyjs monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/surveyjs/surveyjs\" ] } monorepo:swashbuckle-aspnetcore \u00b6 swashbuckle-aspnetcore monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/domaindrivendev/Swashbuckle.AspNetCore\" ] } monorepo:tauri \u00b6 tauri monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/tauri-apps/tauri\" ] } monorepo:treat \u00b6 treat monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/seek-oss/treat\" ] } monorepo:typefaces \u00b6 typefaces monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/KyleAMathews/typefaces\" ] } monorepo:uppy \u00b6 uppy monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/transloadit/uppy\" ] } monorepo:vue \u00b6 vue monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/vuejs/vue\" , \"https://github.com/vuejs/core\" ] } monorepo:vuepress \u00b6 vuepress monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/vuejs/vuepress\" ] } monorepo:webdriverio \u00b6 webdriverio monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/webdriverio/webdriverio\" ] } monorepo:workbox \u00b6 workbox monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/googlechrome/workbox\" ] } monorepo:vstest \u00b6 vstest monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/microsoft/vstest\" ] } monorepo:xterm \u00b6 xterm monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/xtermjs/xterm.js\" ] } monorepo:zxing-net \u00b6 zxing-net monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/micjahn/ZXing.Net\" ] } monorepo:apache-camel \u00b6 apache-camel monorepo { \"matchPackagePatterns\" : [ \"^org.apache.camel:\" ] } monorepo:babel6 \u00b6 babel6 monorepo { \"matchPackagePatterns\" : [ \"^babel6$\" ] } monorepo:wordpress \u00b6 wordpress monorepo { \"matchPackagePatterns\" : [ \"^@wordpress/\" ] } monorepo:angularmaterial \u00b6 angularmaterial monorepo { \"matchPackagePatterns\" : [ \"^@angular/material\" , \"^@angular/cdk\" ] } monorepo:aws-java-sdk \u00b6 aws-java-sdk monorepo { \"matchPackagePatterns\" : [ \"^com.amazonaws:aws-java-sdk-\" ] } monorepo:aws-java-sdk-v2 \u00b6 aws-java-sdk-v2 monorepo { \"matchPackagePatterns\" : [ \"^software.amazon.awssdk:\" ] } monorepo:embroider \u00b6 embroider monorepo { \"matchPackagePatterns\" : [ \"^@embroider/\" ] } monorepo:fullcalendar \u00b6 fullcalendar monorepo { \"matchPackagePatterns\" : [ \"^@fullcalendar/\" ] }","title":"Monorepo Presets"},{"location":"presets-monorepo/#monorepoacot","text":"acot monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/acot-a11y/acot\" ] }","title":"monorepo:acot"},{"location":"presets-monorepo/#monorepoag-grid","text":"ag-grid monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/ag-grid/ag-grid\" ] }","title":"monorepo:ag-grid"},{"location":"presets-monorepo/#monorepoarcusevent-grid","text":"arcus.event-grid monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/arcus-azure/arcus.eventgrid\" ] }","title":"monorepo:arcus.event-grid"},{"location":"presets-monorepo/#monorepoarcussecurity","text":"arcus.security monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/arcus-azure/arcus.security\" ] }","title":"monorepo:arcus.security"},{"location":"presets-monorepo/#monorepoarcusmessaging","text":"arcus.messaging monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/arcus-azure/arcus.messaging\" ] }","title":"monorepo:arcus.messaging"},{"location":"presets-monorepo/#monorepoarcusobservability","text":"arcus.observability monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/arcus-azure/arcus.observability\" ] }","title":"monorepo:arcus.observability"},{"location":"presets-monorepo/#monorepoarcuswebapi","text":"arcus.webapi monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/arcus-azure/arcus.webapi\" ] }","title":"monorepo:arcus.webapi"},{"location":"presets-monorepo/#monorepoarcusbackground-jobs","text":"arcus.background-jobs monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/arcus-azure/arcus.backgroundjobs\" ] }","title":"monorepo:arcus.background-jobs"},{"location":"presets-monorepo/#monorepoalgolia-react-instantsearch","text":"algolia-react-instantsearch monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/algolia/react-instantsearch\" ] }","title":"monorepo:algolia-react-instantsearch"},{"location":"presets-monorepo/#monorepoalgoliasearch-client-javascript","text":"algoliasearch-client-javascript monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/algolia/algoliasearch-client-javascript\" ] }","title":"monorepo:algoliasearch-client-javascript"},{"location":"presets-monorepo/#monorepoalgoliasearch-autocomplete","text":"algoliasearch-autocomplete monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/algolia/autocomplete\" ] }","title":"monorepo:algoliasearch-autocomplete"},{"location":"presets-monorepo/#monorepoangular-eslint","text":"angular-eslint monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/angular-eslint/angular-eslint\" ] }","title":"monorepo:angular-eslint"},{"location":"presets-monorepo/#monorepoapollo-server","text":"apollo-server monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/apollographql/apollo-server\" ] }","title":"monorepo:apollo-server"},{"location":"presets-monorepo/#monorepoaspnet-api-versioning","text":"aspnet-api-versioning monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/Microsoft/aspnet-api-versioning\" ] }","title":"monorepo:aspnet-api-versioning"},{"location":"presets-monorepo/#monorepoaspnet-aspnetwebstack","text":"aspnet aspnetwebstack monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/aspnet/AspNetWebStack\" ] }","title":"monorepo:aspnet aspnetwebstack"},{"location":"presets-monorepo/#monorepoaspnet-extensions","text":"aspnet extensions monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/aspnet/Extensions\" ] }","title":"monorepo:aspnet extensions"},{"location":"presets-monorepo/#monorepoaws-cdk","text":"aws-cdk monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/aws/aws-cdk\" ] }","title":"monorepo:aws-cdk"},{"location":"presets-monorepo/#monorepoaws-sdk-js-v3","text":"aws-sdk-js-v3 monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/aws/aws-sdk-js-v3\" ] }","title":"monorepo:aws-sdk-js-v3"},{"location":"presets-monorepo/#monorepoaws-sdk-net","text":"aws-sdk-net monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/aws/aws-sdk-net\" ] }","title":"monorepo:aws-sdk-net"},{"location":"presets-monorepo/#monorepoazure-azure-libraries-for-net","text":"azure azure-libraries-for-net monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/Azure/azure-libraries-for-net\" ] }","title":"monorepo:azure azure-libraries-for-net"},{"location":"presets-monorepo/#monorepoazure-azure-sdk-for-net","text":"azure azure-sdk-for-net monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/Azure/azure-sdk-for-net\" ] }","title":"monorepo:azure azure-sdk-for-net"},{"location":"presets-monorepo/#monorepoazure-azure-storage-net","text":"azure azure-storage-net monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/Azure/azure-storage-net\" ] }","title":"monorepo:azure azure-storage-net"},{"location":"presets-monorepo/#monorepobugsnag-js","text":"bugsnag-js monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/bugsnag/bugsnag-js\" ] }","title":"monorepo:bugsnag-js"},{"location":"presets-monorepo/#monorepochakra-ui","text":"chakra-ui monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/chakra-ui/chakra-ui\" ] }","title":"monorepo:chakra-ui"},{"location":"presets-monorepo/#monorepocontentful-rich-text","text":"contentful-rich-text monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/contentful/rich-text\" ] }","title":"monorepo:contentful-rich-text"},{"location":"presets-monorepo/#monorepodatadog-browser-sdk","text":"datadog-browser-sdk monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/DataDog/browser-sdk\" ] }","title":"monorepo:datadog-browser-sdk"},{"location":"presets-monorepo/#monorepodate-io","text":"date-io monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/dmtrKovalenko/date-io\" ] }","title":"monorepo:date-io"},{"location":"presets-monorepo/#monorepodeno","text":"deno monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/denoland/deno\" ] }","title":"monorepo:deno"},{"location":"presets-monorepo/#monorepodevextreme-reactive","text":"devextreme-reactive monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/DevExpress/devextreme-reactive\" ] }","title":"monorepo:devextreme-reactive"},{"location":"presets-monorepo/#monorepodnd-kit","text":"dnd-kit monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/clauderic/dnd-kit\" ] }","title":"monorepo:dnd-kit"},{"location":"presets-monorepo/#monorepoelastic-apm-agent-rum-js","text":"elastic-apm-agent-rum-js monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/elastic/apm-agent-rum-js\" ] }","title":"monorepo:elastic-apm-agent-rum-js"},{"location":"presets-monorepo/#monorepoelectron-forge","text":"electron-forge monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/electron-userland/electron-forge\" ] }","title":"monorepo:electron-forge"},{"location":"presets-monorepo/#monorepoember-decorators","text":"ember-decorators monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/ember-decorators/ember-decorators\" ] }","title":"monorepo:ember-decorators"},{"location":"presets-monorepo/#monorepographql-modules","text":"graphql-modules monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/Urigo/graphql-modules\" ] }","title":"monorepo:graphql-modules"},{"location":"presets-monorepo/#monorepogroovy","text":"groovy monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/apache/groovy\" ] }","title":"monorepo:groovy"},{"location":"presets-monorepo/#monorepoionic-native","text":"ionic-native monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/ionic-team/ionic-native\" ] }","title":"monorepo:ionic-native"},{"location":"presets-monorepo/#monorepojsplumb","text":"jsplumb monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/jsplumb/jsplumb\" ] }","title":"monorepo:jsplumb"},{"location":"presets-monorepo/#monorepomdc-react","text":"mdc-react monorepo { \"matchSourceUrlPrefixes\" : [ \"material-components/material-components-web-react\" ] }","title":"monorepo:mdc-react"},{"location":"presets-monorepo/#monorepongx-formly","text":"ngx-formly monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/ngx-formly/ngx-formly\" ] }","title":"monorepo:ngx-formly"},{"location":"presets-monorepo/#monorepongxs-store","text":"ngxs-store monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/ngxs/store\" ] }","title":"monorepo:ngxs-store"},{"location":"presets-monorepo/#monoreporeach-ui","text":"reach-ui monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/reach/reach-ui\" ] }","title":"monorepo:reach-ui"},{"location":"presets-monorepo/#monoreporeact-admin","text":"react-admin monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/marmelab/react-admin\" ] }","title":"monorepo:react-admin"},{"location":"presets-monorepo/#monoreporeact-apollo","text":"react-apollo monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/apollographql/react-apollo\" ] }","title":"monorepo:react-apollo"},{"location":"presets-monorepo/#monoreporeact-dnd","text":"react-dnd monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/react-dnd/react-dnd\" ] }","title":"monorepo:react-dnd"},{"location":"presets-monorepo/#monoreporeact-navigation","text":"react-navigation monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/react-navigation/react-navigation\" ] }","title":"monorepo:react-navigation"},{"location":"presets-monorepo/#monoreporeact-page","text":"react-page monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/react-page/react-page\" ] }","title":"monorepo:react-page"},{"location":"presets-monorepo/#monoreporeactivestack-cookies","text":"reactivestack-cookies monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/reactivestack/cookies\" ] }","title":"monorepo:reactivestack-cookies"},{"location":"presets-monorepo/#monoreporeg-suit","text":"reg-suit monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/reg-viz/reg-suit\" ] }","title":"monorepo:reg-suit"},{"location":"presets-monorepo/#monoreposemantic-release","text":"semantic-release monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/semantic-release/\" ] }","title":"monorepo:semantic-release"},{"location":"presets-monorepo/#monoreposystemioabstractions","text":"system.io.abstractions monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/System-IO-Abstractions/System.IO.Abstractions/\" ] }","title":"monorepo:system.io.abstractions"},{"location":"presets-monorepo/#monorepotelus-tds","text":"telus-tds monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/telusdigital/tds\" ] }","title":"monorepo:telus-tds"},{"location":"presets-monorepo/#monorepotelus-tds-core","text":"telus-tds-core monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/telus/tds-core\" ] }","title":"monorepo:telus-tds-core"},{"location":"presets-monorepo/#monoreposhopify-app-bridge","text":"shopify-app-bridge monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/Shopify/app-bridge\" ] }","title":"monorepo:shopify-app-bridge"},{"location":"presets-monorepo/#monorepotheme-ui","text":"theme-ui monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/system-ui/theme-ui\" ] }","title":"monorepo:theme-ui"},{"location":"presets-monorepo/#monorepotsoa","text":"tsoa monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/lukeautry/tsoa\" ] }","title":"monorepo:tsoa"},{"location":"presets-monorepo/#monorepotypescript-eslint","text":"typescript-eslint monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/typescript-eslint/typescript-eslint\" ] }","title":"monorepo:typescript-eslint"},{"location":"presets-monorepo/#monorepotypography-js","text":"typography-js monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/KyleAMathews/typography.js\" ] }","title":"monorepo:typography-js"},{"location":"presets-monorepo/#monorepovue-cli","text":"vue-cli monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/vuejs/vue-cli\" ] }","title":"monorepo:vue-cli"},{"location":"presets-monorepo/#monorepoaccounts","text":"accounts monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/accounts-js/accounts\" ] }","title":"monorepo:accounts"},{"location":"presets-monorepo/#monorepoangularjs","text":"angularjs monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/angular/angular.js\" ] }","title":"monorepo:angularjs"},{"location":"presets-monorepo/#monorepoangular","text":"angular monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/angular/angular\" ] }","title":"monorepo:angular"},{"location":"presets-monorepo/#monorepoangular-cli","text":"angular-cli monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/angular/angular-cli\" ] }","title":"monorepo:angular-cli"},{"location":"presets-monorepo/#monorepoangularfire","text":"angularfire monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/angular/angularfire\" ] }","title":"monorepo:angularfire"},{"location":"presets-monorepo/#monorepoapolloclient","text":"apolloclient monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/apollographql/apollo-client\" ] }","title":"monorepo:apolloclient"},{"location":"presets-monorepo/#monorepoawsappsync","text":"awsappsync monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/awslabs/aws-mobile-appsync-sdk-js\" ] }","title":"monorepo:awsappsync"},{"location":"presets-monorepo/#monorepobabel","text":"babel monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/babel/babel\" ] }","title":"monorepo:babel"},{"location":"presets-monorepo/#monorepobaset","text":"baset monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/igmat/baset\" ] }","title":"monorepo:baset"},{"location":"presets-monorepo/#monorepobrave","text":"brave monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/openzipkin/brave\" ] }","title":"monorepo:brave"},{"location":"presets-monorepo/#monorepocapacitor","text":"capacitor monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/ionic-team/capacitor\" ] }","title":"monorepo:capacitor"},{"location":"presets-monorepo/#monorepochromely","text":"chromely monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/chromelyapps/Chromely\" ] }","title":"monorepo:chromely"},{"location":"presets-monorepo/#monorepoclarity","text":"clarity monorepo { \"matchPackagePatterns\" : [ \"^@cds/\" , \"^@clr/\" ] }","title":"monorepo:clarity"},{"location":"presets-monorepo/#monorepoclearscript","text":"clearscript monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/microsoft/ClearScript\" , \"https://github.com/Microsoft/ClearScript\" ] }","title":"monorepo:clearscript"},{"location":"presets-monorepo/#monorepocommitlint","text":"commitlint monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/conventional-changelog/commitlint\" ] }","title":"monorepo:commitlint"},{"location":"presets-monorepo/#monorepodocusaurus","text":"docusaurus monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/facebook/docusaurus\" ] }","title":"monorepo:docusaurus"},{"location":"presets-monorepo/#monorepodotnet","text":"dotnet monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/dotnet/aspnetcore\" , \"https://github.com/dotnet/efcore\" , \"https://github.com/dotnet/extensions\" , \"https://github.com/dotnet/runtime\" ] }","title":"monorepo:dotnet"},{"location":"presets-monorepo/#monorepodotnet-wcf","text":"dotnet-wcf monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/dotnet/wcf\" ] }","title":"monorepo:dotnet-wcf"},{"location":"presets-monorepo/#monorepodotnet-azure-ad-identitymodel-extensions","text":"dotnet-azure-ad-identitymodel-extensions monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet\" ] }","title":"monorepo:dotnet-azure-ad-identitymodel-extensions"},{"location":"presets-monorepo/#monorepodropwizard","text":"dropwizard monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/dropwizard/dropwizard\" ] }","title":"monorepo:dropwizard"},{"location":"presets-monorepo/#monorepoemojibase","text":"emojibase monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/milesj/emojibase\" ] }","title":"monorepo:emojibase"},{"location":"presets-monorepo/#monorepoemotion","text":"emotion monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/emotion-js/emotion\" ] }","title":"monorepo:emotion"},{"location":"presets-monorepo/#monorepoexpo","text":"expo monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/expo/expo\" ] }","title":"monorepo:expo"},{"location":"presets-monorepo/#monorepofeathers","text":"feathers monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/feathersjs/feathers\" ] }","title":"monorepo:feathers"},{"location":"presets-monorepo/#monorepofela","text":"fela monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/robinweser/fela\" ] }","title":"monorepo:fela"},{"location":"presets-monorepo/#monorepofimbullinter","text":"fimbullinter monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/fimbullinter/wotan\" ] }","title":"monorepo:fimbullinter"},{"location":"presets-monorepo/#monorepoflopflip","text":"flopflip monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/tdeekens/flopflip\" ] }","title":"monorepo:flopflip"},{"location":"presets-monorepo/#monorepofontsource","text":"fontsource monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/fontsource/fontsource\" ] }","title":"monorepo:fontsource"},{"location":"presets-monorepo/#monorepoformatjs","text":"formatjs monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/formatjs/formatjs\" ] }","title":"monorepo:formatjs"},{"location":"presets-monorepo/#monorepoframework7","text":"framework7 monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/framework7io/framework7\" ] }","title":"monorepo:framework7"},{"location":"presets-monorepo/#monorepogatsby","text":"gatsby monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/gatsbyjs/gatsby\" ] }","title":"monorepo:gatsby"},{"location":"presets-monorepo/#monorepographqlcodegenerator","text":"graphqlcodegenerator monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/dotansimha/graphql-code-generator\" , \"https://github.com/dotansimha/graphql-codegen\" ] }","title":"monorepo:graphqlcodegenerator"},{"location":"presets-monorepo/#monorepographql-mesh","text":"graphql-mesh monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/Urigo/graphql-mesh\" ] }","title":"monorepo:graphql-mesh"},{"location":"presets-monorepo/#monorepographql-tools","text":"graphql-tools monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/ardatan/graphql-tools\" ] }","title":"monorepo:graphql-tools"},{"location":"presets-monorepo/#monorepoguava","text":"guava monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/google/guava\" ] }","title":"monorepo:guava"},{"location":"presets-monorepo/#monorepojavahamcrest","text":"javahamcrest monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/hamcrest/JavaHamcrest\" ] }","title":"monorepo:javahamcrest"},{"location":"presets-monorepo/#monorepohangfire","text":"Hangfire monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/HangfireIO/Hangfire\" ] }","title":"monorepo:Hangfire"},{"location":"presets-monorepo/#monorepohapijs","text":"hapijs monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/hapijs\" ] }","title":"monorepo:hapijs"},{"location":"presets-monorepo/#monorepohotchocolate","text":"hotchocolate monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/ChilliCream/hotchocolate\" ] }","title":"monorepo:hotchocolate"},{"location":"presets-monorepo/#monorepoinfrastructure-ui","text":"infrastructure-ui monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/instructure/instructure-ui\" ] }","title":"monorepo:infrastructure-ui"},{"location":"presets-monorepo/#monorepoistanbuljs","text":"istanbuljs monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/istanbuljs/istanbuljs\" ] }","title":"monorepo:istanbuljs"},{"location":"presets-monorepo/#monorepojasmine","text":"jasmine monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/jasmine/jasmine\" ] }","title":"monorepo:jasmine"},{"location":"presets-monorepo/#monorepojavascriptengineswitcher","text":"javascriptengineswitcher monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/Taritsyn/JavaScriptEngineSwitcher\" ] }","title":"monorepo:javascriptengineswitcher"},{"location":"presets-monorepo/#monorepojersey","text":"jersey monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/eclipse-ee4j/jersey\" ] }","title":"monorepo:jersey"},{"location":"presets-monorepo/#monorepojest","text":"jest monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/facebook/jest\" ] }","title":"monorepo:jest"},{"location":"presets-monorepo/#monorepojunit5","text":"junit5 monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/junit-team/junit5\" ] }","title":"monorepo:junit5"},{"location":"presets-monorepo/#monorepolerna","text":"lerna monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/lerna/lerna\" ] }","title":"monorepo:lerna"},{"location":"presets-monorepo/#monorepolinguijs","text":"linguijs monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/lingui/js-lingui\" ] }","title":"monorepo:linguijs"},{"location":"presets-monorepo/#monorepolodash","text":"lodash monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/lodash/\" ] }","title":"monorepo:lodash"},{"location":"presets-monorepo/#monorepoloopback","text":"loopback monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/strongloop/loopback-next\" , \"https://github.com/loopbackio/loopback-next\" ] }","title":"monorepo:loopback"},{"location":"presets-monorepo/#monorepolrnwebcomponents","text":"lrnwebcomponents monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/elmsln/lrnwebcomponents\" ] }","title":"monorepo:lrnwebcomponents"},{"location":"presets-monorepo/#monorepomapstruct","text":"mapstruct monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/mapstruct/mapstruct\" ] }","title":"monorepo:mapstruct"},{"location":"presets-monorepo/#monorepomasstransit","text":"masstransit monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/MassTransit/MassTransit\" ] }","title":"monorepo:masstransit"},{"location":"presets-monorepo/#monorepomaterial-components-web","text":"material-components-web monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/material-components/material-components-web\" ] }","title":"monorepo:material-components-web"},{"location":"presets-monorepo/#monorepomdx","text":"mdx monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/mdx-js/mdx\" ] }","title":"monorepo:mdx"},{"location":"presets-monorepo/#monorepomaterial-ui","text":"material-ui monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/mui-org/material-ui\" , \"https://github.com/mui/material-ui\" ] }","title":"monorepo:material-ui"},{"location":"presets-monorepo/#monorepomikro-orm","text":"mikro-orm monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/mikro-orm/mikro-orm\" ] }","title":"monorepo:mikro-orm"},{"location":"presets-monorepo/#monorepomockito","text":"mockito monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/mockito/mockito\" ] }","title":"monorepo:mockito"},{"location":"presets-monorepo/#monorepomstest","text":"mstest monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/microsoft/testfx\" ] }","title":"monorepo:mstest"},{"location":"presets-monorepo/#monoreponest","text":"nest monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/nestjs/nest\" , \"https://github.com/nestjs/passport\" ] }","title":"monorepo:nest"},{"location":"presets-monorepo/#monoreponetty","text":"netty monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/netty/netty\" ] }","title":"monorepo:netty"},{"location":"presets-monorepo/#monoreponeutrino","text":"neutrino monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/neutrinojs/neutrino\" , \"https://github.com/mozilla-neutrino/neutrino-dev\" ] }","title":"monorepo:neutrino"},{"location":"presets-monorepo/#monoreponexpect","text":"nexpect monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/fluffynuts/NExpect\" ] }","title":"monorepo:nexpect"},{"location":"presets-monorepo/#monoreponextjs","text":"nextjs monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/zeit/next.js\" , \"https://github.com/vercel/next.js\" ] }","title":"monorepo:nextjs"},{"location":"presets-monorepo/#monoreponivo","text":"nivo monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/plouc/nivo\" ] }","title":"monorepo:nivo"},{"location":"presets-monorepo/#monorepongrx","text":"ngrx monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/ngrx/\" ] }","title":"monorepo:ngrx"},{"location":"presets-monorepo/#monoreponrwl","text":"nrwl monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/nrwl/\" ] }","title":"monorepo:nrwl"},{"location":"presets-monorepo/#monoreponswag","text":"nswag monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/RicoSuter/NSwag\" ] }","title":"monorepo:nswag"},{"location":"presets-monorepo/#monoreponuxtjs","text":"nuxtjs monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/nuxt/nuxt.js\" ] }","title":"monorepo:nuxtjs"},{"location":"presets-monorepo/#monorepoorleans","text":"orleans monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/dotnet/orleans\" ] }","title":"monorepo:orleans"},{"location":"presets-monorepo/#monorepofeign","text":"feign monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/OpenFeign/feign\" ] }","title":"monorepo:feign"},{"location":"presets-monorepo/#monorepoopentelemetry-js","text":"opentelemetry-js monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/open-telemetry/opentelemetry-js\" ] }","title":"monorepo:opentelemetry-js"},{"location":"presets-monorepo/#monorepoopentelemetry-dotnet","text":"opentelemetry-dotnet monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/open-telemetry/opentelemetry-dotnet\" ] }","title":"monorepo:opentelemetry-dotnet"},{"location":"presets-monorepo/#monorepoopentelemetry-go","text":"opentelemetry-go monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/open-telemetry/opentelemetry-go\" ] }","title":"monorepo:opentelemetry-go"},{"location":"presets-monorepo/#monorepoparcel","text":"parcel monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/parcel-bundler/parcel\" ] }","title":"monorepo:parcel"},{"location":"presets-monorepo/#monorepopercy-cli","text":"percy-cli monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/percy/cli\" ] }","title":"monorepo:percy-cli"},{"location":"presets-monorepo/#monorepopicassojs","text":"picassojs monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/qlik-oss/picasso.js\" ] }","title":"monorepo:picassojs"},{"location":"presets-monorepo/#monorepopixijs","text":"pixijs monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/pixijs/pixi.js\" ] }","title":"monorepo:pixijs"},{"location":"presets-monorepo/#monorepopnpjs","text":"pnpjs monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/pnp/pnpjs\" ] }","title":"monorepo:pnpjs"},{"location":"presets-monorepo/#monorepoplaywright","text":"playwright monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/Microsoft/playwright\" ] }","title":"monorepo:playwright"},{"location":"presets-monorepo/#monorepopollyjs","text":"pollyjs monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/Netflix/pollyjs\" ] }","title":"monorepo:pollyjs"},{"location":"presets-monorepo/#monorepopouchdb","text":"pouchdb monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/pouchdb/pouchdb\" ] }","title":"monorepo:pouchdb"},{"location":"presets-monorepo/#monorepoprisma","text":"prisma monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/prisma/prisma\" ] }","title":"monorepo:prisma"},{"location":"presets-monorepo/#monorepoquartznet","text":"quartznet monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/quartznet/quartznet\" ] }","title":"monorepo:quartznet"},{"location":"presets-monorepo/#monoreporeact","text":"react monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/facebook/react\" ] }","title":"monorepo:react"},{"location":"presets-monorepo/#monoreporeact-router","text":"react-router monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/ReactTraining/react-router\" , \"https://github.com/remix-run/react-router\" ] }","title":"monorepo:react-router"},{"location":"presets-monorepo/#monoreporeakit","text":"reakit monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/reakit/reakit\" ] }","title":"monorepo:reakit"},{"location":"presets-monorepo/#monoreporedwood","text":"redwood monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/redwoodjs/redwood\" ] }","title":"monorepo:redwood"},{"location":"presets-monorepo/#monoreporemark","text":"remark monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/remarkjs/remark\" ] }","title":"monorepo:remark"},{"location":"presets-monorepo/#monoreporouter5","text":"router5 monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/router5/router5\" ] }","title":"monorepo:router5"},{"location":"presets-monorepo/#monoreporust-futures","text":"rust-futures monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/rust-lang/futures-rs\" ] }","title":"monorepo:rust-futures"},{"location":"presets-monorepo/#monoreporust-wasm-bindgen","text":"rust-wasm-bindgen monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/rustwasm/wasm-bindgen\" ] }","title":"monorepo:rust-wasm-bindgen"},{"location":"presets-monorepo/#monoreposentry-dotnet","text":"sentry-dotnet monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/getsentry/sentry-dotnet\" ] }","title":"monorepo:sentry-dotnet"},{"location":"presets-monorepo/#monoreposentry-javascript","text":"sentry-javascript monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/getsentry/sentry-javascript\" ] }","title":"monorepo:sentry-javascript"},{"location":"presets-monorepo/#monoreposentry-ruby","text":"sentry-ruby monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/getsentry/sentry-ruby\" ] }","title":"monorepo:sentry-ruby"},{"location":"presets-monorepo/#monorepositecore-jss","text":"sitecore-jss monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/Sitecore/jss\" ] }","title":"monorepo:sitecore-jss"},{"location":"presets-monorepo/#monorepospringfox","text":"springfox monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/springfox/springfox\" ] }","title":"monorepo:springfox"},{"location":"presets-monorepo/#monoreposanity","text":"sanity monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/sanity-io/sanity\" ] }","title":"monorepo:sanity"},{"location":"presets-monorepo/#monoreposendgrid-nodejs","text":"sendgrid-nodejs monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/sendgrid/sendgrid-nodejs\" ] }","title":"monorepo:sendgrid-nodejs"},{"location":"presets-monorepo/#monoreposteeltoe","text":"steeltoe monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/SteeltoeOSS/steeltoe\" ] }","title":"monorepo:steeltoe"},{"location":"presets-monorepo/#monorepostorybook","text":"storybook monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/storybookjs/storybook\" ] }","title":"monorepo:storybook"},{"location":"presets-monorepo/#monorepostrapi","text":"strapi monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/strapi/strapi\" ] }","title":"monorepo:strapi"},{"location":"presets-monorepo/#monorepostryker-js","text":"stryker-js monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/stryker-mutator/stryker-js\" ] }","title":"monorepo:stryker-js"},{"location":"presets-monorepo/#monoreposurveyjs","text":"surveyjs monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/surveyjs/surveyjs\" ] }","title":"monorepo:surveyjs"},{"location":"presets-monorepo/#monoreposwashbuckle-aspnetcore","text":"swashbuckle-aspnetcore monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/domaindrivendev/Swashbuckle.AspNetCore\" ] }","title":"monorepo:swashbuckle-aspnetcore"},{"location":"presets-monorepo/#monorepotauri","text":"tauri monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/tauri-apps/tauri\" ] }","title":"monorepo:tauri"},{"location":"presets-monorepo/#monorepotreat","text":"treat monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/seek-oss/treat\" ] }","title":"monorepo:treat"},{"location":"presets-monorepo/#monorepotypefaces","text":"typefaces monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/KyleAMathews/typefaces\" ] }","title":"monorepo:typefaces"},{"location":"presets-monorepo/#monorepouppy","text":"uppy monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/transloadit/uppy\" ] }","title":"monorepo:uppy"},{"location":"presets-monorepo/#monorepovue","text":"vue monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/vuejs/vue\" , \"https://github.com/vuejs/core\" ] }","title":"monorepo:vue"},{"location":"presets-monorepo/#monorepovuepress","text":"vuepress monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/vuejs/vuepress\" ] }","title":"monorepo:vuepress"},{"location":"presets-monorepo/#monorepowebdriverio","text":"webdriverio monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/webdriverio/webdriverio\" ] }","title":"monorepo:webdriverio"},{"location":"presets-monorepo/#monorepoworkbox","text":"workbox monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/googlechrome/workbox\" ] }","title":"monorepo:workbox"},{"location":"presets-monorepo/#monorepovstest","text":"vstest monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/microsoft/vstest\" ] }","title":"monorepo:vstest"},{"location":"presets-monorepo/#monorepoxterm","text":"xterm monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/xtermjs/xterm.js\" ] }","title":"monorepo:xterm"},{"location":"presets-monorepo/#monorepozxing-net","text":"zxing-net monorepo { \"matchSourceUrlPrefixes\" : [ \"https://github.com/micjahn/ZXing.Net\" ] }","title":"monorepo:zxing-net"},{"location":"presets-monorepo/#monorepoapache-camel","text":"apache-camel monorepo { \"matchPackagePatterns\" : [ \"^org.apache.camel:\" ] }","title":"monorepo:apache-camel"},{"location":"presets-monorepo/#monorepobabel6","text":"babel6 monorepo { \"matchPackagePatterns\" : [ \"^babel6$\" ] }","title":"monorepo:babel6"},{"location":"presets-monorepo/#monorepowordpress","text":"wordpress monorepo { \"matchPackagePatterns\" : [ \"^@wordpress/\" ] }","title":"monorepo:wordpress"},{"location":"presets-monorepo/#monorepoangularmaterial","text":"angularmaterial monorepo { \"matchPackagePatterns\" : [ \"^@angular/material\" , \"^@angular/cdk\" ] }","title":"monorepo:angularmaterial"},{"location":"presets-monorepo/#monorepoaws-java-sdk","text":"aws-java-sdk monorepo { \"matchPackagePatterns\" : [ \"^com.amazonaws:aws-java-sdk-\" ] }","title":"monorepo:aws-java-sdk"},{"location":"presets-monorepo/#monorepoaws-java-sdk-v2","text":"aws-java-sdk-v2 monorepo { \"matchPackagePatterns\" : [ \"^software.amazon.awssdk:\" ] }","title":"monorepo:aws-java-sdk-v2"},{"location":"presets-monorepo/#monorepoembroider","text":"embroider monorepo { \"matchPackagePatterns\" : [ \"^@embroider/\" ] }","title":"monorepo:embroider"},{"location":"presets-monorepo/#monorepofullcalendar","text":"fullcalendar monorepo { \"matchPackagePatterns\" : [ \"^@fullcalendar/\" ] }","title":"monorepo:fullcalendar"},{"location":"presets-npm/","text":"npm:unpublishSafe \u00b6 Set a status check pending for 3 days from release timestamp to guard against npm unpublishing { \"npm\" : { \"stabilityDays\" : 3 } }","title":"npm Presets"},{"location":"presets-npm/#npmunpublishsafe","text":"Set a status check pending for 3 days from release timestamp to guard against npm unpublishing { \"npm\" : { \"stabilityDays\" : 3 } }","title":"npm:unpublishSafe"},{"location":"presets-packages/","text":"packages:angularJs \u00b6 All AngularJS packages { \"matchPackageNames\" : [ \"angular\" , \"angular-animate\" , \"angular-scroll\" , \"angular-sanitize\" ] } packages:react \u00b6 All React packages { \"matchPackageNames\" : [ \"@types/react\" ], \"matchPackagePrefixes\" : [ \"react\" ] } packages:apollographql \u00b6 All packages published by Apollo GraphQL { \"matchSourceUrlPrefixes\" : [ \"https://github.com/apollographql/\" ] } packages:mapbox \u00b6 All Mapbox-related packages { \"matchPackagePrefixes\" : [ \"leaflet\" , \"mapbox\" ] } packages:emberTemplateLint \u00b6 All ember-template-lint packages { \"matchPackagePrefixes\" : [ \"ember-template-lint\" ] } packages:eslint \u00b6 All ESLint packages { \"matchPackageNames\" : [ \"@types/eslint\" , \"babel-eslint\" ], \"matchPackagePrefixes\" : [ \"@typescript-eslint/\" , \"eslint\" ] } packages:stylelint \u00b6 All Stylelint packages { \"matchPackagePrefixes\" : [ \"stylelint\" ] } packages:tslint \u00b6 All TSLint packages { \"matchPackageNames\" : [ \"codelyzer\" ], \"matchPackagePatterns\" : [ \"\\\\btslint\\\\b\" ] } packages:linters \u00b6 All lint-related packages { \"extends\" : [ \"packages:emberTemplateLint\" , \"packages:eslint\" , \"packages:stylelint\" , \"packages:tslint\" ], \"matchPackageNames\" : [ \"remark-lint\" ] } packages:postcss \u00b6 All PostCSS packages { \"matchPackageNames\" : [ \"postcss\" ], \"matchPackagePrefixes\" : [ \"postcss-\" ] } packages:jsUnitTest \u00b6 Unit test packages for JavaScript { \"matchPackageNames\" : [ \"@types/chai\" , \"@types/ember-mocha\" , \"@types/ember-qunit\" , \"@types/enzyme\" , \"@types/istanbul\" , \"@types/jest\" , \"@types/mocha\" , \"@types/mock-fs\" , \"@types/proxyquire\" , \"@types/sinon\" , \"@types/supertest\" , \"coveralls\" , \"ember-exam\" , \"ember-mocha\" , \"ember-qunit\" , \"enzyme\" , \"istanbul\" , \"mock-fs\" , \"nock\" , \"nyc\" , \"proxyquire\" , \"supertest\" , \"ts-jest\" ], \"matchPackagePrefixes\" : [ \"@testing-library\" , \"chai\" , \"jest\" , \"mocha\" , \"qunit\" , \"should\" , \"sinon\" ] } packages:unitTest \u00b6 All unit test packages { \"extends\" : [ \"packages:jsUnitTest\" ] } packages:jsTest \u00b6 JavaScript test packages { \"extends\" : [ \"packages:jsUnitTest\" ] } packages:test \u00b6 Test packages { \"extends\" : [ \"packages:unitTest\" ] } packages:gatsby \u00b6 All packages published by Gatsby { \"extends\" : [ \"monorepo:gatsby\" ] } packages:googleapis \u00b6 All googleapis packages { \"matchDatasources\" : [ \"npm\" ], \"matchPackagePrefixes\" : [ \"@google-cloud/\" ] }","title":"Package Presets"},{"location":"presets-packages/#packagesangularjs","text":"All AngularJS packages { \"matchPackageNames\" : [ \"angular\" , \"angular-animate\" , \"angular-scroll\" , \"angular-sanitize\" ] }","title":"packages:angularJs"},{"location":"presets-packages/#packagesreact","text":"All React packages { \"matchPackageNames\" : [ \"@types/react\" ], \"matchPackagePrefixes\" : [ \"react\" ] }","title":"packages:react"},{"location":"presets-packages/#packagesapollographql","text":"All packages published by Apollo GraphQL { \"matchSourceUrlPrefixes\" : [ \"https://github.com/apollographql/\" ] }","title":"packages:apollographql"},{"location":"presets-packages/#packagesmapbox","text":"All Mapbox-related packages { \"matchPackagePrefixes\" : [ \"leaflet\" , \"mapbox\" ] }","title":"packages:mapbox"},{"location":"presets-packages/#packagesembertemplatelint","text":"All ember-template-lint packages { \"matchPackagePrefixes\" : [ \"ember-template-lint\" ] }","title":"packages:emberTemplateLint"},{"location":"presets-packages/#packageseslint","text":"All ESLint packages { \"matchPackageNames\" : [ \"@types/eslint\" , \"babel-eslint\" ], \"matchPackagePrefixes\" : [ \"@typescript-eslint/\" , \"eslint\" ] }","title":"packages:eslint"},{"location":"presets-packages/#packagesstylelint","text":"All Stylelint packages { \"matchPackagePrefixes\" : [ \"stylelint\" ] }","title":"packages:stylelint"},{"location":"presets-packages/#packagestslint","text":"All TSLint packages { \"matchPackageNames\" : [ \"codelyzer\" ], \"matchPackagePatterns\" : [ \"\\\\btslint\\\\b\" ] }","title":"packages:tslint"},{"location":"presets-packages/#packageslinters","text":"All lint-related packages { \"extends\" : [ \"packages:emberTemplateLint\" , \"packages:eslint\" , \"packages:stylelint\" , \"packages:tslint\" ], \"matchPackageNames\" : [ \"remark-lint\" ] }","title":"packages:linters"},{"location":"presets-packages/#packagespostcss","text":"All PostCSS packages { \"matchPackageNames\" : [ \"postcss\" ], \"matchPackagePrefixes\" : [ \"postcss-\" ] }","title":"packages:postcss"},{"location":"presets-packages/#packagesjsunittest","text":"Unit test packages for JavaScript { \"matchPackageNames\" : [ \"@types/chai\" , \"@types/ember-mocha\" , \"@types/ember-qunit\" , \"@types/enzyme\" , \"@types/istanbul\" , \"@types/jest\" , \"@types/mocha\" , \"@types/mock-fs\" , \"@types/proxyquire\" , \"@types/sinon\" , \"@types/supertest\" , \"coveralls\" , \"ember-exam\" , \"ember-mocha\" , \"ember-qunit\" , \"enzyme\" , \"istanbul\" , \"mock-fs\" , \"nock\" , \"nyc\" , \"proxyquire\" , \"supertest\" , \"ts-jest\" ], \"matchPackagePrefixes\" : [ \"@testing-library\" , \"chai\" , \"jest\" , \"mocha\" , \"qunit\" , \"should\" , \"sinon\" ] }","title":"packages:jsUnitTest"},{"location":"presets-packages/#packagesunittest","text":"All unit test packages { \"extends\" : [ \"packages:jsUnitTest\" ] }","title":"packages:unitTest"},{"location":"presets-packages/#packagesjstest","text":"JavaScript test packages { \"extends\" : [ \"packages:jsUnitTest\" ] }","title":"packages:jsTest"},{"location":"presets-packages/#packagestest","text":"Test packages { \"extends\" : [ \"packages:unitTest\" ] }","title":"packages:test"},{"location":"presets-packages/#packagesgatsby","text":"All packages published by Gatsby { \"extends\" : [ \"monorepo:gatsby\" ] }","title":"packages:gatsby"},{"location":"presets-packages/#packagesgoogleapis","text":"All googleapis packages { \"matchDatasources\" : [ \"npm\" ], \"matchPackagePrefixes\" : [ \"@google-cloud/\" ] }","title":"packages:googleapis"},{"location":"presets-preview/","text":"preview:dockerCompose \u00b6 Enable Docker Compose image updating { \"docker-compose\" : { \"enabled\" : true } } preview:dockerVersions \u00b6 Upgrade Docker tags to newer versions { \"docker\" : { \"major\" : { \"enabled\" : true }, \"minor\" : { \"enabled\" : true } } } preview:buildkite \u00b6 Enable Buildkite functionality { \"buildkite\" : { \"enabled\" : true } }","title":"Preview Presets"},{"location":"presets-preview/#previewdockercompose","text":"Enable Docker Compose image updating { \"docker-compose\" : { \"enabled\" : true } }","title":"preview:dockerCompose"},{"location":"presets-preview/#previewdockerversions","text":"Upgrade Docker tags to newer versions { \"docker\" : { \"major\" : { \"enabled\" : true }, \"minor\" : { \"enabled\" : true } } }","title":"preview:dockerVersions"},{"location":"presets-preview/#previewbuildkite","text":"Enable Buildkite functionality { \"buildkite\" : { \"enabled\" : true } }","title":"preview:buildkite"},{"location":"presets-regexManagers/","text":"regexManagers:dockerfileVersions \u00b6 Update _VERSION variables in Dockerfiles { \"regexManagers\" : [ { \"fileMatch\" : [ \"(^|/|\\\\.)Dockerfile$\" , \"(^|/)Dockerfile[^/]*$\" ], \"matchStrings\" : [ \"# renovate: datasource=(?<datasource>[a-z-]+?) depName=(?<depName>[^\\\\s]+?)(?: (lookupName|packageName)=(?<packageName>[^\\\\s]+?))?(?: versioning=(?<versioning>[a-z-0-9]+?))?\\\\s(?:ENV|ARG) .+?_VERSION=\\\"?(?<currentValue>.+?)\\\"?\\\\s\" ] } ] }","title":"Regex Manager Presets"},{"location":"presets-regexManagers/#regexmanagersdockerfileversions","text":"Update _VERSION variables in Dockerfiles { \"regexManagers\" : [ { \"fileMatch\" : [ \"(^|/|\\\\.)Dockerfile$\" , \"(^|/)Dockerfile[^/]*$\" ], \"matchStrings\" : [ \"# renovate: datasource=(?<datasource>[a-z-]+?) depName=(?<depName>[^\\\\s]+?)(?: (lookupName|packageName)=(?<packageName>[^\\\\s]+?))?(?: versioning=(?<versioning>[a-z-0-9]+?))?\\\\s(?:ENV|ARG) .+?_VERSION=\\\"?(?<currentValue>.+?)\\\"?\\\\s\" ] } ] }","title":"regexManagers:dockerfileVersions"},{"location":"presets-replacements/","text":"replacements:all \u00b6 All replacements { \"extends\" : [ \"replacements:babel-eslint-to-eslint-parser\" , \"replacements:cucumber-to-scoped\" , \"replacements:hapi-to-scoped\" , \"replacements:jade-to-pug\" , \"replacements:joi-to-scoped\" , \"replacements:joi-to-unscoped\" , \"replacements:material-ui-to-mui\" , \"replacements:renovate-pep440-to-renovatebot-pep440\" , \"replacements:rollup-node-resolve-to-scoped\" , \"replacements:xmldom-to-scoped\" ] } replacements:babel-eslint-to-eslint-parser \u00b6 babel-eslint was renamed under the @babel scope { \"packageRules\" : [ { \"matchCurrentVersion\" : \">=7.11.0\" , \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"babel-eslint\" ], \"replacementName\" : \"@babel/eslint-parser\" , \"replacementVersion\" : \"7.11.0\" } ] } replacements:cucumber-to-scoped \u00b6 cucumber became scoped { \"packageRules\" : [ { \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"cucumber\" ], \"replacementName\" : \"@cucumber/cucumber\" , \"replacementVersion\" : \"7.0.0\" } ] } replacements:hapi-to-scoped \u00b6 hapi became scoped { \"packageRules\" : [ { \"matchCurrentVersion\" : \">=18.0.0\" , \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"hapi\" ], \"replacementName\" : \"@hapi/hapi\" , \"replacementVersion\" : \"18.2.0\" } ] } replacements:jade-to-pug \u00b6 Jade was renamed to Pug { \"packageRules\" : [ { \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"jade\" ], \"replacementName\" : \"pug\" , \"replacementVersion\" : \"2.0.0\" } ] } replacements:joi-to-scoped \u00b6 joi became scoped under the hapi organization { \"packageRules\" : [ { \"matchCurrentVersion\" : \">=14.0.0 <14.4.0\" , \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"joi\" ], \"replacementName\" : \"@hapi/joi\" , \"replacementVersion\" : \"14.4.0\" } ] } replacements:joi-to-unscoped \u00b6 joi was moved out of the hapi organization { \"packageRules\" : [ { \"matchCurrentVersion\" : \">=17.0.0\" , \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"@hapi/joi\" ], \"replacementName\" : \"joi\" , \"replacementVersion\" : \"17.1.1\" } ] } replacements:redux-devtools-extension-to-scope \u00b6 the redux-devtools-extension package was renamed to @redux-devtools/extension { \"packageRules\" : [ { \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"redux-devtools-extension\" ], \"replacementName\" : \"@redux-devtools/extension\" , \"replacementVersion\" : \"3.0.0\" } ] } replacements:renovate-pep440-to-renovatebot-pep440 \u00b6 the @renovate/pep440 package was renamed to @renovatebot/pep440 { \"packageRules\" : [ { \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"@renovate/pep440\" ], \"replacementName\" : \"@renovatebot/pep440\" , \"replacementVersion\" : \"1.0.0\" } ] } replacements:rollup-node-resolve-to-scoped \u00b6 the node-resolve plugin for rollup became scoped { \"packageRules\" : [ { \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"rollup-plugin-node-resolve\" ], \"replacementName\" : \"@rollup/plugin-node-resolve\" , \"replacementVersion\" : \"6.0.0\" } ] } replacements:xmldom-to-scoped \u00b6 the xmldom package is now published as @xmldom/xmldom { \"packageRules\" : [ { \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"xmldom\" , \"xmldom-alpha\" ], \"replacementName\" : \"@xmldom/xmldom\" , \"replacementVersion\" : \"0.7.5\" } ] } replacements:material-ui-to-mui \u00b6 the material-ui monorepo org was renamed from @material-ui to @mui/ { \"packageRules\" : [ { \"matchCurrentVersion\" : \">=4.0.0 <5.0.0\" , \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"@material-ui/codemod\" ], \"replacementName\" : \"@mui/codemod\" , \"replacementVersion\" : \"5.0.0\" }, { \"matchCurrentVersion\" : \">=4.0.0 <5.0.0\" , \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"@material-ui/core\" ], \"replacementName\" : \"@mui/material\" , \"replacementVersion\" : \"5.0.0\" }, { \"matchCurrentVersion\" : \">=4.0.0 <5.0.0\" , \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"@material-ui/icons\" ], \"replacementName\" : \"@mui/icons-material\" , \"replacementVersion\" : \"5.0.0\" }, { \"matchCurrentVersion\" : \">=4.0.0 <5.0.0\" , \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"@material-ui/lab\" ], \"replacementName\" : \"@mui/labs\" , \"replacementVersion\" : \"5.0.0\" }, { \"matchCurrentVersion\" : \">=4.0.0 <5.0.0\" , \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"@material-ui/private-theming\" ], \"replacementName\" : \"@mui/private-theming\" , \"replacementVersion\" : \"5.0.0\" }, { \"matchCurrentVersion\" : \">=4.0.0 <5.0.0\" , \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"@material-ui/styled-engine\" ], \"replacementName\" : \"@mui/styled-engine\" , \"replacementVersion\" : \"5.0.0\" }, { \"matchCurrentVersion\" : \">=4.0.0 <5.0.0\" , \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"@material-ui/styled-engine-sc\" ], \"replacementName\" : \"@mui/styled-engine-sc\" , \"replacementVersion\" : \"5.0.0\" }, { \"matchCurrentVersion\" : \">=4.0.0 <5.0.0\" , \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"@material-ui/styles\" ], \"replacementName\" : \"@mui/styles\" , \"replacementVersion\" : \"5.0.0\" }, { \"matchCurrentVersion\" : \">=4.0.0 <5.0.0\" , \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"@material-ui/system\" ], \"replacementName\" : \"@mui/system\" , \"replacementVersion\" : \"5.0.0\" }, { \"matchCurrentVersion\" : \">=4.0.0 <5.0.0\" , \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"@material-ui/types\" ], \"replacementName\" : \"@mui/types\" , \"replacementVersion\" : \"5.0.0\" }, { \"matchCurrentVersion\" : \">=4.0.0 <5.0.0\" , \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"@material-ui/unstyled\" ], \"replacementName\" : \"@mui/core\" , \"replacementVersion\" : \"5.0.0\" } ] }","title":"Replacement Presets"},{"location":"presets-replacements/#replacementsall","text":"All replacements { \"extends\" : [ \"replacements:babel-eslint-to-eslint-parser\" , \"replacements:cucumber-to-scoped\" , \"replacements:hapi-to-scoped\" , \"replacements:jade-to-pug\" , \"replacements:joi-to-scoped\" , \"replacements:joi-to-unscoped\" , \"replacements:material-ui-to-mui\" , \"replacements:renovate-pep440-to-renovatebot-pep440\" , \"replacements:rollup-node-resolve-to-scoped\" , \"replacements:xmldom-to-scoped\" ] }","title":"replacements:all"},{"location":"presets-replacements/#replacementsbabel-eslint-to-eslint-parser","text":"babel-eslint was renamed under the @babel scope { \"packageRules\" : [ { \"matchCurrentVersion\" : \">=7.11.0\" , \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"babel-eslint\" ], \"replacementName\" : \"@babel/eslint-parser\" , \"replacementVersion\" : \"7.11.0\" } ] }","title":"replacements:babel-eslint-to-eslint-parser"},{"location":"presets-replacements/#replacementscucumber-to-scoped","text":"cucumber became scoped { \"packageRules\" : [ { \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"cucumber\" ], \"replacementName\" : \"@cucumber/cucumber\" , \"replacementVersion\" : \"7.0.0\" } ] }","title":"replacements:cucumber-to-scoped"},{"location":"presets-replacements/#replacementshapi-to-scoped","text":"hapi became scoped { \"packageRules\" : [ { \"matchCurrentVersion\" : \">=18.0.0\" , \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"hapi\" ], \"replacementName\" : \"@hapi/hapi\" , \"replacementVersion\" : \"18.2.0\" } ] }","title":"replacements:hapi-to-scoped"},{"location":"presets-replacements/#replacementsjade-to-pug","text":"Jade was renamed to Pug { \"packageRules\" : [ { \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"jade\" ], \"replacementName\" : \"pug\" , \"replacementVersion\" : \"2.0.0\" } ] }","title":"replacements:jade-to-pug"},{"location":"presets-replacements/#replacementsjoi-to-scoped","text":"joi became scoped under the hapi organization { \"packageRules\" : [ { \"matchCurrentVersion\" : \">=14.0.0 <14.4.0\" , \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"joi\" ], \"replacementName\" : \"@hapi/joi\" , \"replacementVersion\" : \"14.4.0\" } ] }","title":"replacements:joi-to-scoped"},{"location":"presets-replacements/#replacementsjoi-to-unscoped","text":"joi was moved out of the hapi organization { \"packageRules\" : [ { \"matchCurrentVersion\" : \">=17.0.0\" , \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"@hapi/joi\" ], \"replacementName\" : \"joi\" , \"replacementVersion\" : \"17.1.1\" } ] }","title":"replacements:joi-to-unscoped"},{"location":"presets-replacements/#replacementsredux-devtools-extension-to-scope","text":"the redux-devtools-extension package was renamed to @redux-devtools/extension { \"packageRules\" : [ { \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"redux-devtools-extension\" ], \"replacementName\" : \"@redux-devtools/extension\" , \"replacementVersion\" : \"3.0.0\" } ] }","title":"replacements:redux-devtools-extension-to-scope"},{"location":"presets-replacements/#replacementsrenovate-pep440-to-renovatebot-pep440","text":"the @renovate/pep440 package was renamed to @renovatebot/pep440 { \"packageRules\" : [ { \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"@renovate/pep440\" ], \"replacementName\" : \"@renovatebot/pep440\" , \"replacementVersion\" : \"1.0.0\" } ] }","title":"replacements:renovate-pep440-to-renovatebot-pep440"},{"location":"presets-replacements/#replacementsrollup-node-resolve-to-scoped","text":"the node-resolve plugin for rollup became scoped { \"packageRules\" : [ { \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"rollup-plugin-node-resolve\" ], \"replacementName\" : \"@rollup/plugin-node-resolve\" , \"replacementVersion\" : \"6.0.0\" } ] }","title":"replacements:rollup-node-resolve-to-scoped"},{"location":"presets-replacements/#replacementsxmldom-to-scoped","text":"the xmldom package is now published as @xmldom/xmldom { \"packageRules\" : [ { \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"xmldom\" , \"xmldom-alpha\" ], \"replacementName\" : \"@xmldom/xmldom\" , \"replacementVersion\" : \"0.7.5\" } ] }","title":"replacements:xmldom-to-scoped"},{"location":"presets-replacements/#replacementsmaterial-ui-to-mui","text":"the material-ui monorepo org was renamed from @material-ui to @mui/ { \"packageRules\" : [ { \"matchCurrentVersion\" : \">=4.0.0 <5.0.0\" , \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"@material-ui/codemod\" ], \"replacementName\" : \"@mui/codemod\" , \"replacementVersion\" : \"5.0.0\" }, { \"matchCurrentVersion\" : \">=4.0.0 <5.0.0\" , \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"@material-ui/core\" ], \"replacementName\" : \"@mui/material\" , \"replacementVersion\" : \"5.0.0\" }, { \"matchCurrentVersion\" : \">=4.0.0 <5.0.0\" , \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"@material-ui/icons\" ], \"replacementName\" : \"@mui/icons-material\" , \"replacementVersion\" : \"5.0.0\" }, { \"matchCurrentVersion\" : \">=4.0.0 <5.0.0\" , \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"@material-ui/lab\" ], \"replacementName\" : \"@mui/labs\" , \"replacementVersion\" : \"5.0.0\" }, { \"matchCurrentVersion\" : \">=4.0.0 <5.0.0\" , \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"@material-ui/private-theming\" ], \"replacementName\" : \"@mui/private-theming\" , \"replacementVersion\" : \"5.0.0\" }, { \"matchCurrentVersion\" : \">=4.0.0 <5.0.0\" , \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"@material-ui/styled-engine\" ], \"replacementName\" : \"@mui/styled-engine\" , \"replacementVersion\" : \"5.0.0\" }, { \"matchCurrentVersion\" : \">=4.0.0 <5.0.0\" , \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"@material-ui/styled-engine-sc\" ], \"replacementName\" : \"@mui/styled-engine-sc\" , \"replacementVersion\" : \"5.0.0\" }, { \"matchCurrentVersion\" : \">=4.0.0 <5.0.0\" , \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"@material-ui/styles\" ], \"replacementName\" : \"@mui/styles\" , \"replacementVersion\" : \"5.0.0\" }, { \"matchCurrentVersion\" : \">=4.0.0 <5.0.0\" , \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"@material-ui/system\" ], \"replacementName\" : \"@mui/system\" , \"replacementVersion\" : \"5.0.0\" }, { \"matchCurrentVersion\" : \">=4.0.0 <5.0.0\" , \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"@material-ui/types\" ], \"replacementName\" : \"@mui/types\" , \"replacementVersion\" : \"5.0.0\" }, { \"matchCurrentVersion\" : \">=4.0.0 <5.0.0\" , \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"@material-ui/unstyled\" ], \"replacementName\" : \"@mui/core\" , \"replacementVersion\" : \"5.0.0\" } ] }","title":"replacements:material-ui-to-mui"},{"location":"presets-schedule/","text":"schedule:earlyMondays \u00b6 Weekly schedule on early monday mornings { \"schedule\" : [ \"before 3am on Monday\" ] } schedule:daily \u00b6 Schedule daily { \"schedule\" : [ \"before 2am\" ] } schedule:weekly \u00b6 Schedule weekly { \"extends\" : [ \"schedule:earlyMondays\" ] } schedule:monthly \u00b6 Schedule monthly { \"schedule\" : [ \"before 3am on the first day of the month\" ] } schedule:quarterly \u00b6 Schedule quarterly { \"schedule\" : [ \"every 3 months on the first day of the month\" ] } schedule:yearly \u00b6 Schedule once a year (not recommended) { \"schedule\" : [ \"every 12 months on the first day of the month\" ] } schedule:weekends \u00b6 Schedule for weekends { \"schedule\" : [ \"every weekend\" ] } schedule:weekdays \u00b6 Schedule for weekdays { \"schedule\" : [ \"every weekday\" ] } schedule:nonOfficeHours \u00b6 Schedule for typical non-office hours (night time and weekends) { \"schedule\" : [ \"after 10pm every weekday\" , \"before 5am every weekday\" , \"every weekend\" ] }","title":"Schedule Presets"},{"location":"presets-schedule/#scheduleearlymondays","text":"Weekly schedule on early monday mornings { \"schedule\" : [ \"before 3am on Monday\" ] }","title":"schedule:earlyMondays"},{"location":"presets-schedule/#scheduledaily","text":"Schedule daily { \"schedule\" : [ \"before 2am\" ] }","title":"schedule:daily"},{"location":"presets-schedule/#scheduleweekly","text":"Schedule weekly { \"extends\" : [ \"schedule:earlyMondays\" ] }","title":"schedule:weekly"},{"location":"presets-schedule/#schedulemonthly","text":"Schedule monthly { \"schedule\" : [ \"before 3am on the first day of the month\" ] }","title":"schedule:monthly"},{"location":"presets-schedule/#schedulequarterly","text":"Schedule quarterly { \"schedule\" : [ \"every 3 months on the first day of the month\" ] }","title":"schedule:quarterly"},{"location":"presets-schedule/#scheduleyearly","text":"Schedule once a year (not recommended) { \"schedule\" : [ \"every 12 months on the first day of the month\" ] }","title":"schedule:yearly"},{"location":"presets-schedule/#scheduleweekends","text":"Schedule for weekends { \"schedule\" : [ \"every weekend\" ] }","title":"schedule:weekends"},{"location":"presets-schedule/#scheduleweekdays","text":"Schedule for weekdays { \"schedule\" : [ \"every weekday\" ] }","title":"schedule:weekdays"},{"location":"presets-schedule/#schedulenonofficehours","text":"Schedule for typical non-office hours (night time and weekends) { \"schedule\" : [ \"after 10pm every weekday\" , \"before 5am every weekday\" , \"every weekend\" ] }","title":"schedule:nonOfficeHours"},{"location":"presets-workarounds/","text":"workarounds:all \u00b6 A collection of workarounds for known problems with packages { \"extends\" : [ \"workarounds:mavenCommonsAncientVersion\" , \"workarounds:ignoreSpringCloudNumeric\" , \"workarounds:ignoreWeb3jCoreWithOldReleaseTimestamp\" , \"workarounds:ignoreHttp4sDigestMilestones\" , \"workarounds:typesNodeVersioning\" , \"workarounds:reduceRepologyServerLoad\" , \"workarounds:doNotUpgradeFromAlpineStableToEdge\" ] } workarounds:mavenCommonsAncientVersion \u00b6 Fix some problems with very old Maven commons versions { \"packageRules\" : [ { \"matchDatasources\" : [ \"maven\" , \"sbt-package\" ], \"matchPackagePrefixes\" : [ \"commons-\" ], \"allowedVersions\" : \"!/^200\\\\d{5}(\\\\.\\\\d+)?/\" } ] } workarounds:ignoreSpringCloudNumeric \u00b6 Ignore spring cloud 1.x releases { \"packageRules\" : [ { \"matchDatasources\" : [ \"maven\" ], \"matchPackageNames\" : [ \"org.springframework.cloud:spring-cloud-starter-parent\" ], \"allowedVersions\" : \"/^[A-Z]/\" } ] } workarounds:ignoreWeb3jCoreWithOldReleaseTimestamp \u00b6 Ignore web3j 5.0.0 release { \"packageRules\" : [ { \"matchDatasources\" : [ \"maven\" ], \"matchPackageNames\" : [ \"org.web3j:core\" ], \"allowedVersions\" : \"!/^5\\\\.0\\\\.0/\" } ] } workarounds:ignoreHttp4sDigestMilestones \u00b6 Ignore http4s digest-based 1.x milestones { \"packageRules\" : [ { \"matchManagers\" : [ \"sbt\" ], \"matchPackagePrefixes\" : [ \"org.http4s:\" ], \"allowedVersions\" : \"!/^1\\\\.0-\\\\d+-[a-fA-F0-9]{7}$/\" } ] } workarounds:typesNodeVersioning \u00b6 Use node versioning for @types/node { \"packageRules\" : [ { \"matchManagers\" : [ \"npm\" ], \"matchPackageNames\" : [ \"@types/node\" ], \"versioning\" : \"node\" } ] } workarounds:reduceRepologyServerLoad \u00b6 Limit concurrent requests to reduce load on Repology servers until we can fix this properly, see issue 10133 { \"hostRules\" : [ { \"matchHost\" : \"repology.org\" , \"concurrentRequestLimit\" : 1 } ] } workarounds:doNotUpgradeFromAlpineStableToEdge \u00b6 Do not upgrade from Alpine stable to edge { \"packageRules\" : [ { \"matchDatasources\" : [ \"docker\" ], \"matchPackageNames\" : [ \"alpine\" ], \"matchCurrentVersion\" : \"<20000000\" , \"allowedVersions\" : \"<20000000\" } ] }","title":"Workaround Presets"},{"location":"presets-workarounds/#workaroundsall","text":"A collection of workarounds for known problems with packages { \"extends\" : [ \"workarounds:mavenCommonsAncientVersion\" , \"workarounds:ignoreSpringCloudNumeric\" , \"workarounds:ignoreWeb3jCoreWithOldReleaseTimestamp\" , \"workarounds:ignoreHttp4sDigestMilestones\" , \"workarounds:typesNodeVersioning\" , \"workarounds:reduceRepologyServerLoad\" , \"workarounds:doNotUpgradeFromAlpineStableToEdge\" ] }","title":"workarounds:all"},{"location":"presets-workarounds/#workaroundsmavencommonsancientversion","text":"Fix some problems with very old Maven commons versions { \"packageRules\" : [ { \"matchDatasources\" : [ \"maven\" , \"sbt-package\" ], \"matchPackagePrefixes\" : [ \"commons-\" ], \"allowedVersions\" : \"!/^200\\\\d{5}(\\\\.\\\\d+)?/\" } ] }","title":"workarounds:mavenCommonsAncientVersion"},{"location":"presets-workarounds/#workaroundsignorespringcloudnumeric","text":"Ignore spring cloud 1.x releases { \"packageRules\" : [ { \"matchDatasources\" : [ \"maven\" ], \"matchPackageNames\" : [ \"org.springframework.cloud:spring-cloud-starter-parent\" ], \"allowedVersions\" : \"/^[A-Z]/\" } ] }","title":"workarounds:ignoreSpringCloudNumeric"},{"location":"presets-workarounds/#workaroundsignoreweb3jcorewitholdreleasetimestamp","text":"Ignore web3j 5.0.0 release { \"packageRules\" : [ { \"matchDatasources\" : [ \"maven\" ], \"matchPackageNames\" : [ \"org.web3j:core\" ], \"allowedVersions\" : \"!/^5\\\\.0\\\\.0/\" } ] }","title":"workarounds:ignoreWeb3jCoreWithOldReleaseTimestamp"},{"location":"presets-workarounds/#workaroundsignorehttp4sdigestmilestones","text":"Ignore http4s digest-based 1.x milestones { \"packageRules\" : [ { \"matchManagers\" : [ \"sbt\" ], \"matchPackagePrefixes\" : [ \"org.http4s:\" ], \"allowedVersions\" : \"!/^1\\\\.0-\\\\d+-[a-fA-F0-9]{7}$/\" } ] }","title":"workarounds:ignoreHttp4sDigestMilestones"},{"location":"presets-workarounds/#workaroundstypesnodeversioning","text":"Use node versioning for @types/node { \"packageRules\" : [ { \"matchManagers\" : [ \"npm\" ], \"matchPackageNames\" : [ \"@types/node\" ], \"versioning\" : \"node\" } ] }","title":"workarounds:typesNodeVersioning"},{"location":"presets-workarounds/#workaroundsreducerepologyserverload","text":"Limit concurrent requests to reduce load on Repology servers until we can fix this properly, see issue 10133 { \"hostRules\" : [ { \"matchHost\" : \"repology.org\" , \"concurrentRequestLimit\" : 1 } ] }","title":"workarounds:reduceRepologyServerLoad"},{"location":"presets-workarounds/#workaroundsdonotupgradefromalpinestabletoedge","text":"Do not upgrade from Alpine stable to edge { \"packageRules\" : [ { \"matchDatasources\" : [ \"docker\" ], \"matchPackageNames\" : [ \"alpine\" ], \"matchCurrentVersion\" : \"<20000000\" , \"allowedVersions\" : \"<20000000\" } ] }","title":"workarounds:doNotUpgradeFromAlpineStableToEdge"},{"location":"python/","text":"Python package manager support \u00b6 Renovate supports the following Python package managers: pip (e.g. requirements.txt , requirements.pip ) files pipenv (e.g. Pipfile ) setup.py file setup.cfg file Versioning support \u00b6 The PEP440 versioning scheme has been rewritten for JavaScript for the purposes of use in this project is published as @renovatebot/pep440 . It supports both pinned versions as well as ranges. Legacy versions ( === prefix) are ignored. How it works \u00b6 Renovate searches through each repository for package files Existing dependencies are extracted from the package files Renovate looks up the latest version on PyPI to determine if any upgrades are available If the source package includes a GitHub URL as its source, and has a \"changelog\" file or uses GitHub releases, a Release Note will be embedded in the generated PR Alternative file names \u00b6 The default file matching regex for requirements.txt aims to pick up the most popular conventions for file naming, but it's possible that some get missed. If you have a specific file or file pattern you want the Renovate bot to find, use the fileMatch field in the pip_requirements object. e.g.: { \"pip_requirements\" : { \"fileMatch\" : [ \"my/specifically-named.file\" , \"\\\\.requirements$\" ] } } Alternate registries \u00b6 By default Renovate performs all lookups on pypi.org, but you can configure alternative index URLs. There are two ways to do this: index-url in requirements.txt \u00b6 The index URL can be specified in the first line of the file. For example: --index-url http://example.com/private-pypi/ some-package==0.3.1 some-other-package==1.0.0 Sources in Pipfile \u00b6 Renovate detects any custom-configured sources in Pipfile and uses them. Specify URL in configuration \u00b6 You can use the registryUrls array to configure alternate index URL(s). e.g.: { \"python\" : { \"registryUrls\" : [ \"http://example.com/private-pypi/\" ] } } Tip The index-url found in the requirements.txt file takes precedence over a registryUrl configured like the above. To override the URL found in requirements.txt , you need to configure it in packageRules , as they are applied after package file extraction. Disabling Python support \u00b6 The most direct way to disable all Python support in Renovate is like this: { \"python\" : { \"enabled\" : false } } Alternatively, maybe you only want one package manager, such as npm . In that case this would enable only npm : { \"enabledManagers\" : [ \"npm\" ] }","title":"Python"},{"location":"python/#python-package-manager-support","text":"Renovate supports the following Python package managers: pip (e.g. requirements.txt , requirements.pip ) files pipenv (e.g. Pipfile ) setup.py file setup.cfg file","title":"Python package manager support"},{"location":"python/#versioning-support","text":"The PEP440 versioning scheme has been rewritten for JavaScript for the purposes of use in this project is published as @renovatebot/pep440 . It supports both pinned versions as well as ranges. Legacy versions ( === prefix) are ignored.","title":"Versioning support"},{"location":"python/#how-it-works","text":"Renovate searches through each repository for package files Existing dependencies are extracted from the package files Renovate looks up the latest version on PyPI to determine if any upgrades are available If the source package includes a GitHub URL as its source, and has a \"changelog\" file or uses GitHub releases, a Release Note will be embedded in the generated PR","title":"How it works"},{"location":"python/#alternative-file-names","text":"The default file matching regex for requirements.txt aims to pick up the most popular conventions for file naming, but it's possible that some get missed. If you have a specific file or file pattern you want the Renovate bot to find, use the fileMatch field in the pip_requirements object. e.g.: { \"pip_requirements\" : { \"fileMatch\" : [ \"my/specifically-named.file\" , \"\\\\.requirements$\" ] } }","title":"Alternative file names"},{"location":"python/#alternate-registries","text":"By default Renovate performs all lookups on pypi.org, but you can configure alternative index URLs. There are two ways to do this:","title":"Alternate registries"},{"location":"python/#index-url-in-requirementstxt","text":"The index URL can be specified in the first line of the file. For example: --index-url http://example.com/private-pypi/ some-package==0.3.1 some-other-package==1.0.0","title":"index-url in requirements.txt"},{"location":"python/#sources-in-pipfile","text":"Renovate detects any custom-configured sources in Pipfile and uses them.","title":"Sources in Pipfile"},{"location":"python/#specify-url-in-configuration","text":"You can use the registryUrls array to configure alternate index URL(s). e.g.: { \"python\" : { \"registryUrls\" : [ \"http://example.com/private-pypi/\" ] } } Tip The index-url found in the requirements.txt file takes precedence over a registryUrl configured like the above. To override the URL found in requirements.txt , you need to configure it in packageRules , as they are applied after package file extraction.","title":"Specify URL in configuration"},{"location":"python/#disabling-python-support","text":"The most direct way to disable all Python support in Renovate is like this: { \"python\" : { \"enabled\" : false } } Alternatively, maybe you only want one package manager, such as npm . In that case this would enable only npm : { \"enabledManagers\" : [ \"npm\" ] }","title":"Disabling Python support"},{"location":"ruby/","text":"Automated dependency updates for Ruby Bundler dependencies \u00b6 Renovate supports upgrading dependencies in Bundler's Gemfiles and their accompanying Gemfile.lock files. How it works \u00b6 Renovate searches in each repository for any Gemfiles Existing dependencies are extracted from the Gemfiles Renovate resolves the dependency on Rubygems.org (or elsewhere if configured), and checks for newer versions A PR is created which updates the Gemfile and Gemfile.lock in a single commit If the source repository has a \"changelog\" file or uses GitHub releases, then Release Notes for each version are embedded in the generated PR Warnings \u00b6 Renovate doesn't update dependencies without a version constraint. Example: gem 'some-gem', '~> 1.2.3' will update some-gem if a new version matching the constraint is available, but gem 'some-gem' won't. If you always want to have the latest available version, consider specifying gem 'some-gem', '> 0' . Enabling \u00b6 You can install the Renovate App on GitHub. Or you can check out Renovate OSS to self-host Renovate.","title":"Ruby"},{"location":"ruby/#automated-dependency-updates-for-ruby-bundler-dependencies","text":"Renovate supports upgrading dependencies in Bundler's Gemfiles and their accompanying Gemfile.lock files.","title":"Automated dependency updates for Ruby Bundler dependencies"},{"location":"ruby/#how-it-works","text":"Renovate searches in each repository for any Gemfiles Existing dependencies are extracted from the Gemfiles Renovate resolves the dependency on Rubygems.org (or elsewhere if configured), and checks for newer versions A PR is created which updates the Gemfile and Gemfile.lock in a single commit If the source repository has a \"changelog\" file or uses GitHub releases, then Release Notes for each version are embedded in the generated PR","title":"How it works"},{"location":"ruby/#warnings","text":"Renovate doesn't update dependencies without a version constraint. Example: gem 'some-gem', '~> 1.2.3' will update some-gem if a new version matching the constraint is available, but gem 'some-gem' won't. If you always want to have the latest available version, consider specifying gem 'some-gem', '> 0' .","title":"Warnings"},{"location":"ruby/#enabling","text":"You can install the Renovate App on GitHub. Or you can check out Renovate OSS to self-host Renovate.","title":"Enabling"},{"location":"rust/","text":"Automated Dependency Updates for Rust crates \u00b6 Renovate supports upgrading dependencies in Cargo.toml files and their accompanying Cargo.lock checksums. How it works \u00b6 Renovate searches in each repository for any Cargo.toml files Renovate extracts existing dependencies from [dependencies] , [dev-dependencies] and [build-dependencies] Renovate tries to find and parse a .cargo/config.toml file to discover index URLs for private registries Renovate resolves the dependency's version using the crates.io API or by cloning the index URL If Renovate finds an update, Renovate will use cargo update to update both Cargo.toml and Cargo.lock Enabling Rust Modules Updating \u00b6 Renovate updates Rust crates by default. Private crate registries and private Git dependencies \u00b6 If any dependencies are hosted in private Git repositories, Git Authentication for cargo must be set up. If any dependencies are hosted on private crate registries (i.e., not on crates.io ), then credentials should be set up in such a way that the Git command-line is able to clone the registry index. Third-party crate registries usually provide instructions to achieve this. Both of these are currently only possible when running Renovate self-hosted.","title":"Rust crates"},{"location":"rust/#automated-dependency-updates-for-rust-crates","text":"Renovate supports upgrading dependencies in Cargo.toml files and their accompanying Cargo.lock checksums.","title":"Automated Dependency Updates for Rust crates"},{"location":"rust/#how-it-works","text":"Renovate searches in each repository for any Cargo.toml files Renovate extracts existing dependencies from [dependencies] , [dev-dependencies] and [build-dependencies] Renovate tries to find and parse a .cargo/config.toml file to discover index URLs for private registries Renovate resolves the dependency's version using the crates.io API or by cloning the index URL If Renovate finds an update, Renovate will use cargo update to update both Cargo.toml and Cargo.lock","title":"How it works"},{"location":"rust/#enabling-rust-modules-updating","text":"Renovate updates Rust crates by default.","title":"Enabling Rust Modules Updating"},{"location":"rust/#private-crate-registries-and-private-git-dependencies","text":"If any dependencies are hosted in private Git repositories, Git Authentication for cargo must be set up. If any dependencies are hosted on private crate registries (i.e., not on crates.io ), then credentials should be set up in such a way that the Git command-line is able to clone the registry index. Third-party crate registries usually provide instructions to achieve this. Both of these are currently only possible when running Renovate self-hosted.","title":"Private crate registries and private Git dependencies"},{"location":"security-and-permissions/","text":"Security and Permissions \u00b6 This page talks about our security stance, and explains what permissions are needed for the different ways you can run Renovate. Security Stance \u00b6 Renovate is open source software, and comes with no guarantees or warranties of any kind. That said, we will try to fix security problems in a reasonable timeframe if possible. No certifications \u00b6 Renovate the Open Source project does not have ISO 27001 or SOC2 certifications. Mend the company, which maintains Renovate and operates the hosted Renovate App for GitHub, does have ISO 27001 and SOC2 certifications. Security / Disclosure \u00b6 If you find any bug with Renovate that may be a security problem, then e-mail us at: renovate-disclosure@whitesourcesoftware.com . This way we can evaluate the bug and hopefully fix it before it gets abused. Please give us enough time to investigate the bug before you report it anywhere else. Please do not create GitHub issues for security-related doubts or problems. Permissions \u00b6 We apply the Principle of Least Privilege (PoLP) but do need substantial privileges in order for our apps to work. Global Permissions \u00b6 These permissions are always needed to run the respective app. Permission Renovate hosted app Forking Renovate Why Dependabot alerts read read Create vulnerability fix PRs Administration read read Read branch protections and to be able to assign teams to PRs Metadata read read Mandatory for all apps Checks read and write not applicable Read and write status checks Code read and write read Read for repository content and write for creating branches Commit statuses read and write read and write Read and write commit statuses for Renovate PRs Issues read and write read and write Create dependency dashboard or Config Warning issues Pull Requests read and write read and write Create update PRs Workflows read and write not applicable Explicit permission needed in order to update workflows User permissions \u00b6 Renovate can also request users's permission to the following resources. These permissions will be requested and authorized on an individual-user basis. Permission Renovate hosted app Forking Renovate Why email read not applicable Per-user consent requested if logging into App dashboard","title":"Security and Permissions"},{"location":"security-and-permissions/#security-and-permissions","text":"This page talks about our security stance, and explains what permissions are needed for the different ways you can run Renovate.","title":"Security and Permissions"},{"location":"security-and-permissions/#security-stance","text":"Renovate is open source software, and comes with no guarantees or warranties of any kind. That said, we will try to fix security problems in a reasonable timeframe if possible.","title":"Security Stance"},{"location":"security-and-permissions/#no-certifications","text":"Renovate the Open Source project does not have ISO 27001 or SOC2 certifications. Mend the company, which maintains Renovate and operates the hosted Renovate App for GitHub, does have ISO 27001 and SOC2 certifications.","title":"No certifications"},{"location":"security-and-permissions/#security-disclosure","text":"If you find any bug with Renovate that may be a security problem, then e-mail us at: renovate-disclosure@whitesourcesoftware.com . This way we can evaluate the bug and hopefully fix it before it gets abused. Please give us enough time to investigate the bug before you report it anywhere else. Please do not create GitHub issues for security-related doubts or problems.","title":"Security / Disclosure"},{"location":"security-and-permissions/#permissions","text":"We apply the Principle of Least Privilege (PoLP) but do need substantial privileges in order for our apps to work.","title":"Permissions"},{"location":"security-and-permissions/#global-permissions","text":"These permissions are always needed to run the respective app. Permission Renovate hosted app Forking Renovate Why Dependabot alerts read read Create vulnerability fix PRs Administration read read Read branch protections and to be able to assign teams to PRs Metadata read read Mandatory for all apps Checks read and write not applicable Read and write status checks Code read and write read Read for repository content and write for creating branches Commit statuses read and write read and write Read and write commit statuses for Renovate PRs Issues read and write read and write Create dependency dashboard or Config Warning issues Pull Requests read and write read and write Create update PRs Workflows read and write not applicable Explicit permission needed in order to update workflows","title":"Global Permissions"},{"location":"security-and-permissions/#user-permissions","text":"Renovate can also request users's permission to the following resources. These permissions will be requested and authorized on an individual-user basis. Permission Renovate hosted app Forking Renovate Why email read not applicable Per-user consent requested if logging into App dashboard","title":"User permissions"},{"location":"self-hosted-configuration/","text":"Self-Hosted configuration options \u00b6 You can only use these configuration options when you're self-hosting Renovate. Please also see Self-Hosted Experimental Options . Note Config options with type=string are always non-mergeable, so mergeable=false . allowCustomCrateRegistries \u00b6 Set this to true if custom crate registries are allowed. Name Value type boolean default false cli --allow-custom-crate-registries env RENOVATE_ALLOW_CUSTOM_CRATE_REGISTRIES allowPlugins \u00b6 Set this to true if repositories are allowed to run install plugins. Name Value type boolean default false cli --allow-plugins env RENOVATE_ALLOW_PLUGINS allowPostUpgradeCommandTemplating \u00b6 Set this to true to allow templating for post-upgrade commands. Name Value type boolean default false cli --allow-post-upgrade-command-templating env RENOVATE_ALLOW_POST_UPGRADE_COMMAND_TEMPLATING Set to true to allow templating of dependency level post-upgrade commands. Let's look at an example of configuring packages with existing Angular migrations. Add two properties to config.js : allowPostUpgradeCommandTemplating and allowedPostUpgradeCommands : module . exports = { allowPostUpgradeCommandTemplating : true , allowedPostUpgradeCommands : [ '^npm ci --ignore-scripts$' , '^npx ng update' ], }; In the renovate.json file, define the commands and files to be included in the final commit. The command to install dependencies ( npm ci --ignore-scripts ) is needed because, by default, the installation of dependencies is skipped (see the skipInstalls global option). { \"packageRules\" : [ { \"matchPackageNames\" : [ \"@angular/core\" ], \"postUpgradeTasks\" : { \"commands\" : [ \"npm ci --ignore-scripts\" , \"npx ng update {{{depName}}} --from={{{currentVersion}}} --to={{{newVersion}}} --migrate-only --allow-dirty --force\" ], \"fileFilters\" : [ \"**/**\" ] } } ] } With this configuration, the executable command for @angular/core looks like this: npm ci --ignore-scripts npx ng update @angular/core --from = 10 .0.0 --to = 11 .0.0 --migrate-only --allow-dirty --force allowScripts \u00b6 Set this to true if repositories are allowed to run install scripts. Name Value type boolean default false cli --allow-scripts env RENOVATE_ALLOW_SCRIPTS allowedPostUpgradeCommands \u00b6 A list of regular expressions that decide which post-upgrade tasks are allowed. Name Value type array subType string cli --allowed-post-upgrade-commands env RENOVATE_ALLOWED_POST_UPGRADE_COMMANDS A list of regular expressions that decide which commands in postUpgradeTasks are allowed to run. If this list is empty then no tasks will be executed. For example: { \"allowedPostUpgradeCommands\" : [ \"^tslint --fix$\" , \"^tslint --[a-z]+$\" ] } autodiscover \u00b6 Autodiscover all repositories. Name Value type boolean default false cli --autodiscover env RENOVATE_AUTODISCOVER When you enable autodiscover , by default, Renovate runs on every repository that the bot account can access. You can limit which repositories Renovate can access by using the autodiscoverFilter config option. autodiscoverFilter \u00b6 Filter the list of autodiscovered repositories. Name Value type string cli --autodiscover-filter env RENOVATE_AUTODISCOVER_FILTER You can use this option to filter the list of repositories that the Renovate bot account can access through autodiscover . It takes a minimatch glob-style or regex pattern. Minimatch : { \"autodiscoverFilter\" : \"project/*\" } Regex : All text inside the start and end / will be treated as a regular expression. { \"autodiscoverFilter\" : \"/project/.*/\" } You can negate the regex by putting a ! in front: { \"autodiscoverFilter\" : \"!/project/.*/\" } baseDir \u00b6 The base directory for Renovate to store local files, including repository files and cache. If left empty, Renovate will create its own temporary directory to use. Name Value type string cli --base-dir env RENOVATE_BASE_DIR default null By default Renovate uses a temporary directory like /tmp/renovate to store its data. You can override this default with the baseDir option. For example: { \"baseDir\" : \"/my-own-different-temporary-folder\" } binarySource \u00b6 Controls how third-party tools like npm or Gradle are called: directly, via Docker sidecar containers, or via dynamic install. Name Value type string allowedValues global,docker,install default \"global\" cli --binary-source env RENOVATE_BINARY_SOURCE Renovate often needs to use third-party binaries in its PRs, like npm to update package-lock.json or go to update go.sum . By default, Renovate uses a child process to run such tools, so they must be: installed before running Renovate available in the path But you can tell Renovate to use \"sidecar\" containers for third-party tools by setting binarySource=docker . For this to work, docker needs to be installed and the Docker socket available to Renovate. Now Renovate uses docker run to create containers like Node.js or Python to run tools in as-needed. Additionally, when Renovate is run inside a container built using containerbase/buildpack , such as the official Renovate images on Docker Hub, then binarySource=install can be used. This mode means that Renovate will dynamically install the version of tools available, if supported. Supported tools for dynamic install are: composer flux jb npm Tools not on this list fall back to binarySource=global . cacheDir \u00b6 The directory where Renovate stores its cache. If left empty, Renovate creates a subdirectory within the baseDir . Name Value type string cli --cache-dir env RENOVATE_CACHE_DIR default null By default Renovate stores cache data in a temporary directory like /tmp/renovate/cache . Use the cacheDir option to override this default. The baseDir and cacheDir option may point to different directories. You can use one directory for the repo data, and another for the cache data. For example: { \"baseDir\" : \"/my-own-different-temporary-folder\" , \"cacheDir\" : \"/my-own-different-cache-folder\" } customEnvVariables \u00b6 Custom environment variables for child processes and sidecar Docker containers. Name Value type object cli --custom-env-variables env RENOVATE_CUSTOM_ENV_VARIABLES This configuration will be applied after all other environment variables so you can use it to override defaults. detectGlobalManagerConfig \u00b6 If true , Renovate will try to detect global manager configuration from the file system. Name Value type boolean default false cli --detect-global-manager-config env RENOVATE_DETECT_GLOBAL_MANAGER_CONFIG The purpose of this config option is to allow you (as a bot admin) to configure manager-specific files such as a global .npmrc file, instead of configuring it in Renovate config. This config option is disabled by default because it may prove surprising or undesirable for some users who don't expect Renovate to go into their home directory and import registry or credential information. Currently this config option is supported for the npm manager only - specifically the ~/.npmrc file. If found, it will be imported into config.npmrc with config.npmrcMerge set to true . detectHostRulesFromEnv \u00b6 If true , Renovate will try to detect host rules from environment variables. Name Value type boolean default false cli --detect-host-rules-from-env env RENOVATE_DETECT_HOST_RULES_FROM_ENV The format of the environment variables must follow: Datasource name (e.g. NPM , PYPI ) Underscore ( _ ) matchHost Underscore ( _ ) Field name ( TOKEN , USERNAME , or PASSWORD ) Hyphens ( - ) in datasource or host name must be replaced with double underscores ( __ ). Periods ( . ) in host names must be replaced with a single underscore ( _ ). Note You can't use these prefixes with the detectHostRulesFromEnv config option: npm_config_ , npm_lifecycle_ , npm_package_ . npmjs registry token example \u00b6 NPM_REGISTRY_NPMJS_ORG_TOKEN=abc123 : { \"hostRules\" : [ { \"hostType\" : \"npm\" , \"matchHost\" : \"registry.npmjs.org\" , \"token\" : \"abc123\" } ] } GitLab Tags username/password example \u00b6 GITLAB__TAGS_CODE__HOST_COMPANY_COM_USERNAME=bot GITLAB__TAGS_CODE__HOST_COMPANY_COM_PASSWORD=botpass123 : { \"hostRules\" : [ { \"hostType\" : \"gitlab-tags\" , \"matchHost\" : \"code-host.company.com\" , \"username\" : \"bot\" , \"password\" : \"botpass123\" } ] } Datasource and credentials only \u00b6 You can skip the host part, and use just the datasource and credentials. DOCKER_USERNAME=bot DOCKER_PASSWORD=botpass123 : { \"hostRules\" : [ { \"hostType\" : \"docker\" , \"username\" : \"bot\" , \"password\" : \"botpass123\" } ] } dockerChildPrefix \u00b6 Change this value to add a prefix to the Renovate Docker sidecar container names and labels. Name Value type string default \"renovate_\" cli --docker-child-prefix env RENOVATE_DOCKER_CHILD_PREFIX Adds a custom prefix to the default Renovate sidecar Docker containers name and label. For example, if you set dockerChildPrefix=myprefix_ then the final container created from the renovate/node is: called myprefix_node instead of renovate_node labeled myprefix_child instead of renovate_child Note Dangling containers are only removed when Renovate runs again with the same prefix. dockerImagePrefix \u00b6 Change this value to override the default Renovate Docker sidecar image name prefix. Name Value type string default \"docker.io/renovate\" cli --docker-image-prefix env RENOVATE_DOCKER_IMAGE_PREFIX By default Renovate pulls the sidecar Docker containers from docker.io/renovate . You can use the dockerImagePrefix option to override this default. Say you want to pull your images from ghcr.io/renovatebot . You would put this in your configuration file: { \"dockerImagePrefix\" : \"ghcr.io/renovatebot\" } If you pulled a new node image, the final image would be ghcr.io/renovatebot/node instead of docker.io/renovate/node . dockerUser \u00b6 Set the UID and GID for Docker-based binaries if you use binarySource=docker . Name Value type string cli --docker-user env RENOVATE_DOCKER_USER default null Override default user and group used by Docker-based binaries. The user-id (UID) and group-id (GID) must match the user that executes Renovate. Read the Docker run reference for more information on user and group syntax. Set this to 1001:1002 to use UID 1001 and GID 1002. For example: { \"dockerUser\" : \"1001:1002\" } If you use binarySource=docker|install read the section below. If you need to change the Docker user please make sure to use the root ( 0 ) group, otherwise you'll get in trouble with missing file and directory permissions. Like this: > export RENOVATE_DOCKER_USER=\"$(id -u):0\" # 500:0 (username:root) dryRun \u00b6 If enabled, perform a dry run by logging messages instead of creating/updating/deleting branches and PRs. Name Value type string allowedValues extract,lookup,full cli --dry-run env RENOVATE_DRY_RUN Use dryRun to preview the behavior of Renovate in logs, without making any changes to the repository files. You can choose from the following behaviors for the dryRun config option: null : Default behavior - Performs a regular Renovate run including creating/updating/deleting branches and PRs \"extract\" : Performs a very quick package file scan to identify the extracted dependencies \"lookup\" : Performs a package file scan to identify the extracted dependencies and updates available \"full\" : Performs a dry run by logging messages instead of creating/updating/deleting branches and PRs Information provided mainly in debug log level. endpoint \u00b6 Custom endpoint to use. Name Value type string cli --endpoint env RENOVATE_ENDPOINT executionTimeout \u00b6 Default execution timeout in minutes for child processes Renovate creates. Name Value type integer default 15 cli --execution-timeout env RENOVATE_EXECUTION_TIMEOUT Default execution timeout in minutes for child processes Renovate creates. If this option is not set, Renovate will fallback to 15 minutes. exposeAllEnv \u00b6 Set this to true to allow passing of all environment variables to package managers. Name Value type boolean default false cli --expose-all-env env RENOVATE_EXPOSE_ALL_ENV To keep you safe, Renovate only passes a limited set of environment variables to package managers. Confidential data can be leaked if a malicious script enumerates all environment variables. Set exposeAllEnv to true only if you have reviewed, and trust, the repositories which Renovate bot runs against. Setting this to true also allows for variable substitution in .npmrc files. force \u00b6 Any configuration set in this object will force override existing settings. Name Value type object This object is used as a \"force override\" when you need to make sure certain configuration overrides whatever is configured in the repository. For example, forcing a null (no) schedule to make sure Renovate raises PRs on a run even if the repository itself or its preset defines a schedule that's currently inactive. In practice, it is implemented by converting the force configuration into a packageRule that matches all packages. forceCli \u00b6 Decides if CLI configuration options are moved to the force config section. Name Value type boolean default true cli --force-cli env RENOVATE_FORCE_CLI This is set to true by default, meaning that any settings (such as schedule ) take maximum priority even against custom settings existing inside individual repositories. It will also override any settings in packageRules . forkMode \u00b6 Set to true to fork the source repository and create branches there instead. Name Value type boolean default false cli --fork-mode env RENOVATE_FORK_MODE You probably have no need for this option - it is an experimental setting for the Renovate hosted GitHub App. If this is set to true then Renovate will fork the repository into the personal space of the person owning the Personal Access Token. forkToken \u00b6 Will be used on GitHub when forkMode is set to true to clone the repositories. Name Value type string default \"\" cli --fork-token env RENOVATE_FORK_TOKEN You probably don't need this option - it is an experimental setting for the Renovate hosted GitHub App. This should be set to a Personal Access Token (GitHub only) when forkMode is set to true . Renovate will use this token to fork the repository into the personal space of the person owning the Personal Access Token. Renovate will then create branches on the fork and opens Pull Requests on the parent repository. gitNoVerify \u00b6 Which Git commands will be run with the --no-verify option. Name Value type array subType string allowedValues commit,push default [\"commit\",\"push\"] cli --git-no-verify env RENOVATE_GIT_NO_VERIFY Controls when Renovate passes the --no-verify flag to git . The flag can be passed to git commit and/or git push . Read the documentation for git commit --no-verify and git push --no-verify to learn exactly what each flag does. To learn more about Git hooks, read the Pro Git 2 book, section on Git Hooks . gitPrivateKey \u00b6 PGP key to use for signing Git commits. Name Value type string env RENOVATE_GIT_PRIVATE_KEY default null This should be an armored private key, so the type you get from running gpg --export-secret-keys --armor 92066A17F0D1707B4E96863955FEF5171C45FAE5 > private.key . Replace the newlines with \\n before adding the resulting single-line value to your bot's config. Note The private key can't be protected with a passphrase if running in a headless environment. Renovate will not be able to handle entering the passphrase. It will be loaded lazily . Before the first commit in a repository, Renovate will: Run gpg import (if you haven't before) Run git config user.signingkey and git config commit.gpgsign true The git commands are run locally in the cloned repo instead of globally. This reduces the chance of unintended consequences with global Git configs on shared systems. gitTimeout \u00b6 Configure the timeout with a number of milliseconds to wait for a Git task. Name Value type integer default 0 cli --git-timeout env RENOVATE_GIT_TIMEOUT To handle the case where the underlying Git processes appear to hang, configure the timeout with the number of milliseconds to wait after last received content on either stdOut or stdErr streams before sending a SIGINT kill message. gitUrl \u00b6 Overrides the default resolution for Git remote, e.g. to switch GitLab from HTTPS to SSH-based. Name Value type string allowedValues default,ssh,endpoint default \"default\" cli --git-url env RENOVATE_GIT_URL Override the default resolution for Git remote, e.g. to switch GitLab from HTTPS to SSH-based. Currently works for GitLab only. Possible values: default : use HTTPS URLs provided by the platform for Git ssh : use SSH URLs provided by the platform for Git endpoint : ignore URLs provided by the platform and use the configured endpoint directly githubTokenWarn \u00b6 Display warnings about GitHub token not being set. Name Value type boolean default true cli --github-token-warn env RENOVATE_GITHUB_TOKEN_WARN By default, Renovate logs and displays a warning when the GITHUB_COM_TOKEN is not set. By setting githubTokenWarn to false , Renovate suppresses these warnings on Pull Requests, etc. Disabling the warning is helpful for self-hosted environments that can't access the github.com domain, because the warning is useless in these environments. globalExtends \u00b6 Configuration presets to use or extend for a self-hosted config. Name Value type array subType string cli --global-extends env RENOVATE_GLOBAL_EXTENDS Unlike the extends field, which is passed through unresolved to be part of repository config, any presets in globalExtends are resolved immediately as part of global config. Use the globalExtends field if your preset has any global-only configuration options, such as the list of repositories to run against. Use the extends field instead of this if, for example, you need the ability for a repository config (e.g. renovate.json ) to be able to use ignorePresets for any preset defined in global config. logContext \u00b6 Add a global or per-repo log context to each log entry. Name Value type string cli --log-context env RENOVATE_LOG_CONTEXT logContext is included with each log entry only if logFormat=\"json\" - it is not included in the pretty log output. If left as default (null), a random short ID will be selected. logFile \u00b6 Log file path. Name Value type string cli --log-file env RENOVATE_LOG_FILE default null logFileLevel \u00b6 Set the log file log level. Name Value type string default \"debug\" cli --log-file-level env RENOVATE_LOG_FILE_LEVEL migratePresets \u00b6 Define presets here which have been removed or renamed and should be migrated automatically. Name Value type object additionalProperties [object Object] cli --migrate-presets env RENOVATE_MIGRATE_PRESETS Use this if you have repositories that extend from a particular preset, which has now been renamed or removed. This is handy if you have a large number of repositories that all extend from a particular preset which you want to rename, without the hassle of manually updating every repository individually. Use an empty string to indicate that the preset should be ignored rather than replaced. Example: modules . exports = { migratePresets : { '@company' : 'local>org/renovate-config' , }, }; In the above example any reference to the @company preset will be replaced with local>org/renovate-config . onboarding \u00b6 Require a Configuration PR first. Name Value type boolean cli --onboarding env RENOVATE_ONBOARDING default true Only set this to false if all three statements are true: You've configured Renovate entirely on the bot side (e.g. empty renovate.json in repositories) You want to run Renovate on every repository the bot has access to You want to skip all onboarding PRs onboardingBranch \u00b6 Change this value to override the default onboarding branch name. Name Value type string default \"renovate/configure\" env RENOVATE_ONBOARDING_BRANCH Note This setting is independent of branchPrefix . For example, if you configure branchPrefix to be renovate- then you'd still have the onboarding PR created with branch renovate/configure until you configure onboardingBranch=renovate-configure or similar. If you have an existing Renovate installation and you change onboardingBranch then it's possible that you'll get onboarding PRs for repositories that had previously closed the onboarding PR unmerged. onboardingCommitMessage \u00b6 Change this value to override the default onboarding commit message. Name Value type string env RENOVATE_ONBOARDING_COMMIT_MESSAGE If commitMessagePrefix or semanticCommits values are set then they will be prepended to the commit message using the same logic that is used for adding them to non-onboarding commit messages. onboardingConfig \u00b6 Configuration to use for onboarding PRs. Name Value type object default {\"$schema\":\"https://docs.renovatebot.com/renovate-schema.json\"} mergeable true cli --onboarding-config env RENOVATE_ONBOARDING_CONFIG onboardingConfigFileName \u00b6 Change this value to override the default onboarding config file name. Name Value type string default \"renovate.json\" env RENOVATE_ONBOARDING_CONFIG_FILE_NAME If set to one of the valid config file names , the onboarding PR will create a configuration file with the provided name instead of renovate.json . Falls back to renovate.json if the name provided is not valid. onboardingNoDeps \u00b6 Onboard the repository even if no dependencies are found. Name Value type boolean default false cli --onboarding-no-deps env RENOVATE_ONBOARDING_NO_DEPS Set this to true if you want Renovate to create an onboarding PR even if no dependencies are found. Otherwise, Renovate skips onboarding a repository if it finds no dependencies in it. onboardingPrTitle \u00b6 Change this value to override the default onboarding PR title. Name Value type string default \"Configure Renovate\" env RENOVATE_ONBOARDING_PR_TITLE Similarly to onboardingBranch , if you have an existing Renovate installation and you change onboardingPrTitle then it's possible that you'll get onboarding PRs for repositories that had previously closed the onboarding PR unmerged. optimizeForDisabled \u00b6 Set to true to first check for disabling in config before cloning. Name Value type boolean default false cli --optimize-for-disabled env RENOVATE_OPTIMIZE_FOR_DISABLED password \u00b6 Password for authentication. Name Value type string supportedPlatforms azure,bitbucket,bitbucket-server cli --password env RENOVATE_PASSWORD default null persistRepoData \u00b6 If set to true , repository data is kept between runs instead of deleted. Name Value type boolean default false cli --persist-repo-data env RENOVATE_PERSIST_REPO_DATA Set this to true if you want Renovate to persist repo data between runs. The intention is that this allows Renovate to do a faster git fetch between runs rather than git clone . It also may mean that ignored directories like node_modules can be preserved and save time on operations like npm install . platform \u00b6 Platform type of repository. Name Value type string allowedValues azure,bitbucket,bitbucket-server,gitea,github,gitlab default \"github\" cli --platform env RENOVATE_PLATFORM prCommitsPerRunLimit \u00b6 Set the maximum number of commits per Renovate run. By default there is no limit. Name Value type integer default 0 cli --pr-commits-per-run-limit env RENOVATE_PR_COMMITS_PER_RUN_LIMIT Parameter to reduce CI load. CI jobs are usually triggered by these events: pull-request creation, pull-request update, automerge events. Set as an integer. Default is no limit. printConfig \u00b6 If enabled, Renovate logs the fullly resolved config for each repo, plus the fully resolved presets. Name Value type boolean default false cli --print-config env RENOVATE_PRINT_CONFIG This option is useful for troubleshooting, particularly if using presets. e.g. run renovate foo/bar --print-config > config.log and the fully-resolved config will be included in the log file. privateKey \u00b6 Server-side private key. Name Value type string replaceLineReturns true cli --private-key env RENOVATE_PRIVATE_KEY default null This private key is used to decrypt config files. The corresponding public key can be used to create encrypted values for config files. If you want a simple UI to encrypt values you can put the public key in a HTML page similar to https://app.renovatebot.com/encrypt . To create the key pair with GPG use the following commands: gpg --full-generate-key and follow the prompts to generate a key. Name and email are not important to Renovate, and do not configure a passphrase. Use a 4096bit key. key generation log \u276f gpg --full-generate-key gpg (GnuPG) 2.2.24; Copyright (C) 2020 Free Software Foundation, Inc. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Please select what kind of key you want: (1) RSA and RSA (default) (2) DSA and Elgamal (3) DSA (sign only) (4) RSA (sign only) (14) Existing key from card Your selection? 1 RSA keys may be between 1024 and 4096 bits long. What keysize do you want? (3072) 4096 Requested keysize is 4096 bits Please specify how long the key should be valid. 0 = key does not expire <n> = key expires in n days <n>w = key expires in n weeks <n>m = key expires in n months <n>y = key expires in n years Key is valid for? (0) Key does not expire at all Is this correct? (y/N) y GnuPG needs to construct a user ID to identify your key. Real name: Renovate Bot Email address: renovate@whitesourcesoftware.com Comment: You selected this USER-ID: \"Renovate Bot <renovate@whitesourcesoftware.com>\" Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? O gpg: key 0649CC3899F22A66 marked as ultimately trusted gpg: revocation certificate stored as '/Users/rhys/.gnupg/openpgp-revocs.d/794B820F34B34A8DF32AADB20649CC3899F22A66.rev' public and secret key created and signed. pub rsa4096 2021-09-10 [SC] 794B820F34B34A8DF32AADB20649CEXAMPLEONLY uid Renovate Bot <renovate@whitesourcesoftware.com> sub rsa4096 2021-09-10 [E] Copy the key ID from the output ( 794B820F34B34A8DF32AADB20649CEXAMPLEONLY in the above example) or run gpg --list-secret-keys if you forgot to take a copy Run gpg --armor --export-secret-keys YOUR_NEW_KEY_ID > renovate-private-key.asc to generate an armored (text-based) private key file Run gpg --armor --export YOUR_NEW_KEY_ID > renovate-public-key.asc to generate an armored (text-based) public key file The private key should then be added to your Renovate Bot global config (either using privateKeyPath or exporting it to the RENOVATE_PRIVATE_KEY environment variable). The public key can be used to replace the existing key in https://app.renovatebot.com/encrypt for your own use. Any encrypted secrets using GPG must have a mandatory organization/group scope, and optionally can be scoped for a single repository only. The reason for this is to avoid \"replay\" attacks where someone could learn your encrypted secret and then reuse it in their own Renovate repositories. Instead, with scoped secrets it means that Renovate ensures that the organization and optionally repository values encrypted with the secret match against the running repository. Note Simple public key encryption was previously used to encrypt secrets, but this approach has been deprecated and is no longer documented. privateKeyOld \u00b6 Secondary or old private key to try. Name Value type string replaceLineReturns true cli --private-key-old env RENOVATE_PRIVATE_KEY_OLD default null Use this field if you need to perform a \"key rotation\" and support more than one keypair at a time. Decryption with this key will be tried after privateKey . If you are migrating from the legacy public key encryption approach to use GPG, then move your legacy private key from privateKey to privateKeyOld and then put your new GPG private key in privateKey . Doing so will mean that Renovate will first try to decrypt using the GPG key but fall back to the legacy key and try that next. You can remove the privateKeyOld config option once all the old encrypted values have been migrated, or if you no longer want to support the old key and let the processing of repositories fail. privateKeyPath \u00b6 Path to the Server-side private key. Name Value type string cli --private-key-path env RENOVATE_PRIVATE_KEY_PATH default null Used as an alternative to privateKey , if you want the key to be read from disk instead. privateKeyPathOld \u00b6 Path to the Server-side old private key. Name Value type string cli --private-key-path-old env RENOVATE_PRIVATE_KEY_PATH_OLD default null Used as an alternative to privateKeyOld , if you want the key to be read from disk instead. productLinks \u00b6 Links which are used in PRs, issues and comments. Name Value type object mergeable true default {\"documentation\":\"https://docs.renovatebot.com/\",\"help\":\"https://github.com/renovatebot/renovate/discussions\",\"homepage\":\"https://github.com/renovatebot/renovate\"} additionalProperties [object Object] cli --product-links env RENOVATE_PRODUCT_LINKS Override this object if you want to change the URLs that Renovate links to, e.g. if you have an internal forum for asking for help. redisUrl \u00b6 If set, this Redis URL will be used for caching instead of the file system. Name Value type string cli --redis-url env RENOVATE_REDIS_URL default null If this value is set then Renovate will use Redis for its global cache instead of the local file system. The global cache is used to store lookup results (e.g. dependency versions and release notes) between repositories and runs. Example url: redis://localhost . repositories \u00b6 List of Repositories. Name Value type array env RENOVATE_REPOSITORIES Elements in the repositories array can be an object if you wish to define additional settings: { repositories : [ { repository : 'g/r1' , bumpVersion : true }, 'g/r2' ], } repositoryCache \u00b6 This option decides if Renovate uses a JSON cache to speed up extractions. Name Value type string allowedValues disabled,enabled,reset default \"disabled\" cli --repository-cache env RENOVATE_REPOSITORY_CACHE Set this to \"enabled\" to have Renovate maintain a JSON file cache per-repository to speed up extractions. Set to \"reset\" if you ever need to bypass the cache and have it overwritten. JSON files will be stored inside the cacheDir beside the existing file-based package cache. Warning This is an experimental feature and may be modified or removed in a future non-major release. requireConfig \u00b6 Controls Renovate's behavior regarding repository config files such as renovate.json . Name Value type string default \"required\" allowedValues required,optional,ignored cli --require-config env RENOVATE_REQUIRE_CONFIG By default, Renovate needs a Renovate config file in each repository where it runs before it will propose any dependency updates. You can choose any of these settings: \"required\" (default): a repository config file must be present \"optional\" : if a config file exists, Renovate will use it when it runs \"ignored\" : config files in the repo will be ignored, and have no effect This feature is closely related to the onboarding config option. The combinations of requireConfig and onboarding are: onboarding=true onboarding=false requireConfig=required An onboarding PR will be created if no config file exists. If the onboarding PR is closed and there's no config file, then the repository is skipped. Repository is skipped unless a config file is added manually. requireConfig=optional An onboarding PR will be created if no config file exists. If the onboarding PR is closed and there's no config file, the repository will be processed. Repository is processed regardless of config file presence. requireConfig=ignored No onboarding PR will be created and repo will be processed while ignoring any config file present. Repository is processed, any config file is ignored. secrets \u00b6 Object which holds secret name/value pairs. Name Value type object mergeable true additionalProperties [object Object] cli --secrets env RENOVATE_SECRETS Secrets may be configured by a bot admin in config.js , which will then make them available for templating within repository configs. For example, to configure a GOOGLE_TOKEN to be accessible by all repositories: module . exports = { secrets : { GOOGLE_TOKEN : 'abc123' , }, }; They can also be configured per repository, e.g. module . exports = { repositories : [ { repository : 'abc/def' , secrets : { GOOGLE_TOKEN : 'abc123' , }, }, ], }; It could then be used in a repository config or preset like so: { \"hostRules\" : [ { \"matchHost\" : \"google.com\" , \"token\" : \"{{ secrets.GOOGLE_TOKEN }}\" } ] } Secret names must start with an upper or lower case character and can have only characters, digits, or underscores. skipInstalls \u00b6 Skip installing modules/dependencies if lock file updating is possible without a full install. Name Value type boolean cli --skip-installs env RENOVATE_SKIP_INSTALLS default null By default, Renovate will use the most efficient approach to updating package files and lock files, which in most cases skips the need to perform a full module install by the bot. If this is set to false, then a full install of modules will be done. This is currently applicable to npm and lerna / npm only, and only used in cases where bugs in npm result in incorrect lock files being updated. token \u00b6 Repository Auth Token. Name Value type string cli --token env RENOVATE_TOKEN default null unicodeEmoji \u00b6 Enable or disable Unicode emoji. Name Value type boolean default true cli --unicode-emoji env RENOVATE_UNICODE_EMOJI If enabled emoji shortcodes ( :warning: ) are replaced with their Unicode equivalents ( \u26a0\ufe0f ). username \u00b6 Username for authentication. Name Value type string supportedPlatforms azure,bitbucket,bitbucket-server cli --username env RENOVATE_USERNAME default null You may need to set a username if you: use the Bitbucket platform, or use the GitHub App with CLI (required) If you're using a Personal Access Token (PAT) to authenticate then you should not set a username . writeDiscoveredRepos \u00b6 Writes discovered repositories to a JSON file and then exit. Name Value type string cli --write-discovered-repos default null Optional parameter which allows to write the discovered repositories into a JSON file instead of renovating them. Usage: renovate --write-discovered-repos=/tmp/renovate-repos.json [ \"myOrg/myRepo\" , \"myOrg/anotherRepo\" ]","title":"Self-hosted"},{"location":"self-hosted-configuration/#self-hosted-configuration-options","text":"You can only use these configuration options when you're self-hosting Renovate. Please also see Self-Hosted Experimental Options . Note Config options with type=string are always non-mergeable, so mergeable=false .","title":"Self-Hosted configuration options"},{"location":"self-hosted-configuration/#allowcustomcrateregistries","text":"Set this to true if custom crate registries are allowed. Name Value type boolean default false cli --allow-custom-crate-registries env RENOVATE_ALLOW_CUSTOM_CRATE_REGISTRIES","title":"allowCustomCrateRegistries"},{"location":"self-hosted-configuration/#allowplugins","text":"Set this to true if repositories are allowed to run install plugins. Name Value type boolean default false cli --allow-plugins env RENOVATE_ALLOW_PLUGINS","title":"allowPlugins"},{"location":"self-hosted-configuration/#allowpostupgradecommandtemplating","text":"Set this to true to allow templating for post-upgrade commands. Name Value type boolean default false cli --allow-post-upgrade-command-templating env RENOVATE_ALLOW_POST_UPGRADE_COMMAND_TEMPLATING Set to true to allow templating of dependency level post-upgrade commands. Let's look at an example of configuring packages with existing Angular migrations. Add two properties to config.js : allowPostUpgradeCommandTemplating and allowedPostUpgradeCommands : module . exports = { allowPostUpgradeCommandTemplating : true , allowedPostUpgradeCommands : [ '^npm ci --ignore-scripts$' , '^npx ng update' ], }; In the renovate.json file, define the commands and files to be included in the final commit. The command to install dependencies ( npm ci --ignore-scripts ) is needed because, by default, the installation of dependencies is skipped (see the skipInstalls global option). { \"packageRules\" : [ { \"matchPackageNames\" : [ \"@angular/core\" ], \"postUpgradeTasks\" : { \"commands\" : [ \"npm ci --ignore-scripts\" , \"npx ng update {{{depName}}} --from={{{currentVersion}}} --to={{{newVersion}}} --migrate-only --allow-dirty --force\" ], \"fileFilters\" : [ \"**/**\" ] } } ] } With this configuration, the executable command for @angular/core looks like this: npm ci --ignore-scripts npx ng update @angular/core --from = 10 .0.0 --to = 11 .0.0 --migrate-only --allow-dirty --force","title":"allowPostUpgradeCommandTemplating"},{"location":"self-hosted-configuration/#allowscripts","text":"Set this to true if repositories are allowed to run install scripts. Name Value type boolean default false cli --allow-scripts env RENOVATE_ALLOW_SCRIPTS","title":"allowScripts"},{"location":"self-hosted-configuration/#allowedpostupgradecommands","text":"A list of regular expressions that decide which post-upgrade tasks are allowed. Name Value type array subType string cli --allowed-post-upgrade-commands env RENOVATE_ALLOWED_POST_UPGRADE_COMMANDS A list of regular expressions that decide which commands in postUpgradeTasks are allowed to run. If this list is empty then no tasks will be executed. For example: { \"allowedPostUpgradeCommands\" : [ \"^tslint --fix$\" , \"^tslint --[a-z]+$\" ] }","title":"allowedPostUpgradeCommands"},{"location":"self-hosted-configuration/#autodiscover","text":"Autodiscover all repositories. Name Value type boolean default false cli --autodiscover env RENOVATE_AUTODISCOVER When you enable autodiscover , by default, Renovate runs on every repository that the bot account can access. You can limit which repositories Renovate can access by using the autodiscoverFilter config option.","title":"autodiscover"},{"location":"self-hosted-configuration/#autodiscoverfilter","text":"Filter the list of autodiscovered repositories. Name Value type string cli --autodiscover-filter env RENOVATE_AUTODISCOVER_FILTER You can use this option to filter the list of repositories that the Renovate bot account can access through autodiscover . It takes a minimatch glob-style or regex pattern. Minimatch : { \"autodiscoverFilter\" : \"project/*\" } Regex : All text inside the start and end / will be treated as a regular expression. { \"autodiscoverFilter\" : \"/project/.*/\" } You can negate the regex by putting a ! in front: { \"autodiscoverFilter\" : \"!/project/.*/\" }","title":"autodiscoverFilter"},{"location":"self-hosted-configuration/#basedir","text":"The base directory for Renovate to store local files, including repository files and cache. If left empty, Renovate will create its own temporary directory to use. Name Value type string cli --base-dir env RENOVATE_BASE_DIR default null By default Renovate uses a temporary directory like /tmp/renovate to store its data. You can override this default with the baseDir option. For example: { \"baseDir\" : \"/my-own-different-temporary-folder\" }","title":"baseDir"},{"location":"self-hosted-configuration/#binarysource","text":"Controls how third-party tools like npm or Gradle are called: directly, via Docker sidecar containers, or via dynamic install. Name Value type string allowedValues global,docker,install default \"global\" cli --binary-source env RENOVATE_BINARY_SOURCE Renovate often needs to use third-party binaries in its PRs, like npm to update package-lock.json or go to update go.sum . By default, Renovate uses a child process to run such tools, so they must be: installed before running Renovate available in the path But you can tell Renovate to use \"sidecar\" containers for third-party tools by setting binarySource=docker . For this to work, docker needs to be installed and the Docker socket available to Renovate. Now Renovate uses docker run to create containers like Node.js or Python to run tools in as-needed. Additionally, when Renovate is run inside a container built using containerbase/buildpack , such as the official Renovate images on Docker Hub, then binarySource=install can be used. This mode means that Renovate will dynamically install the version of tools available, if supported. Supported tools for dynamic install are: composer flux jb npm Tools not on this list fall back to binarySource=global .","title":"binarySource"},{"location":"self-hosted-configuration/#cachedir","text":"The directory where Renovate stores its cache. If left empty, Renovate creates a subdirectory within the baseDir . Name Value type string cli --cache-dir env RENOVATE_CACHE_DIR default null By default Renovate stores cache data in a temporary directory like /tmp/renovate/cache . Use the cacheDir option to override this default. The baseDir and cacheDir option may point to different directories. You can use one directory for the repo data, and another for the cache data. For example: { \"baseDir\" : \"/my-own-different-temporary-folder\" , \"cacheDir\" : \"/my-own-different-cache-folder\" }","title":"cacheDir"},{"location":"self-hosted-configuration/#customenvvariables","text":"Custom environment variables for child processes and sidecar Docker containers. Name Value type object cli --custom-env-variables env RENOVATE_CUSTOM_ENV_VARIABLES This configuration will be applied after all other environment variables so you can use it to override defaults.","title":"customEnvVariables"},{"location":"self-hosted-configuration/#detectglobalmanagerconfig","text":"If true , Renovate will try to detect global manager configuration from the file system. Name Value type boolean default false cli --detect-global-manager-config env RENOVATE_DETECT_GLOBAL_MANAGER_CONFIG The purpose of this config option is to allow you (as a bot admin) to configure manager-specific files such as a global .npmrc file, instead of configuring it in Renovate config. This config option is disabled by default because it may prove surprising or undesirable for some users who don't expect Renovate to go into their home directory and import registry or credential information. Currently this config option is supported for the npm manager only - specifically the ~/.npmrc file. If found, it will be imported into config.npmrc with config.npmrcMerge set to true .","title":"detectGlobalManagerConfig"},{"location":"self-hosted-configuration/#detecthostrulesfromenv","text":"If true , Renovate will try to detect host rules from environment variables. Name Value type boolean default false cli --detect-host-rules-from-env env RENOVATE_DETECT_HOST_RULES_FROM_ENV The format of the environment variables must follow: Datasource name (e.g. NPM , PYPI ) Underscore ( _ ) matchHost Underscore ( _ ) Field name ( TOKEN , USERNAME , or PASSWORD ) Hyphens ( - ) in datasource or host name must be replaced with double underscores ( __ ). Periods ( . ) in host names must be replaced with a single underscore ( _ ). Note You can't use these prefixes with the detectHostRulesFromEnv config option: npm_config_ , npm_lifecycle_ , npm_package_ .","title":"detectHostRulesFromEnv"},{"location":"self-hosted-configuration/#npmjs-registry-token-example","text":"NPM_REGISTRY_NPMJS_ORG_TOKEN=abc123 : { \"hostRules\" : [ { \"hostType\" : \"npm\" , \"matchHost\" : \"registry.npmjs.org\" , \"token\" : \"abc123\" } ] }","title":"npmjs registry token example"},{"location":"self-hosted-configuration/#gitlab-tags-usernamepassword-example","text":"GITLAB__TAGS_CODE__HOST_COMPANY_COM_USERNAME=bot GITLAB__TAGS_CODE__HOST_COMPANY_COM_PASSWORD=botpass123 : { \"hostRules\" : [ { \"hostType\" : \"gitlab-tags\" , \"matchHost\" : \"code-host.company.com\" , \"username\" : \"bot\" , \"password\" : \"botpass123\" } ] }","title":"GitLab Tags username/password example"},{"location":"self-hosted-configuration/#datasource-and-credentials-only","text":"You can skip the host part, and use just the datasource and credentials. DOCKER_USERNAME=bot DOCKER_PASSWORD=botpass123 : { \"hostRules\" : [ { \"hostType\" : \"docker\" , \"username\" : \"bot\" , \"password\" : \"botpass123\" } ] }","title":"Datasource and credentials only"},{"location":"self-hosted-configuration/#dockerchildprefix","text":"Change this value to add a prefix to the Renovate Docker sidecar container names and labels. Name Value type string default \"renovate_\" cli --docker-child-prefix env RENOVATE_DOCKER_CHILD_PREFIX Adds a custom prefix to the default Renovate sidecar Docker containers name and label. For example, if you set dockerChildPrefix=myprefix_ then the final container created from the renovate/node is: called myprefix_node instead of renovate_node labeled myprefix_child instead of renovate_child Note Dangling containers are only removed when Renovate runs again with the same prefix.","title":"dockerChildPrefix"},{"location":"self-hosted-configuration/#dockerimageprefix","text":"Change this value to override the default Renovate Docker sidecar image name prefix. Name Value type string default \"docker.io/renovate\" cli --docker-image-prefix env RENOVATE_DOCKER_IMAGE_PREFIX By default Renovate pulls the sidecar Docker containers from docker.io/renovate . You can use the dockerImagePrefix option to override this default. Say you want to pull your images from ghcr.io/renovatebot . You would put this in your configuration file: { \"dockerImagePrefix\" : \"ghcr.io/renovatebot\" } If you pulled a new node image, the final image would be ghcr.io/renovatebot/node instead of docker.io/renovate/node .","title":"dockerImagePrefix"},{"location":"self-hosted-configuration/#dockeruser","text":"Set the UID and GID for Docker-based binaries if you use binarySource=docker . Name Value type string cli --docker-user env RENOVATE_DOCKER_USER default null Override default user and group used by Docker-based binaries. The user-id (UID) and group-id (GID) must match the user that executes Renovate. Read the Docker run reference for more information on user and group syntax. Set this to 1001:1002 to use UID 1001 and GID 1002. For example: { \"dockerUser\" : \"1001:1002\" } If you use binarySource=docker|install read the section below. If you need to change the Docker user please make sure to use the root ( 0 ) group, otherwise you'll get in trouble with missing file and directory permissions. Like this: > export RENOVATE_DOCKER_USER=\"$(id -u):0\" # 500:0 (username:root)","title":"dockerUser"},{"location":"self-hosted-configuration/#dryrun","text":"If enabled, perform a dry run by logging messages instead of creating/updating/deleting branches and PRs. Name Value type string allowedValues extract,lookup,full cli --dry-run env RENOVATE_DRY_RUN Use dryRun to preview the behavior of Renovate in logs, without making any changes to the repository files. You can choose from the following behaviors for the dryRun config option: null : Default behavior - Performs a regular Renovate run including creating/updating/deleting branches and PRs \"extract\" : Performs a very quick package file scan to identify the extracted dependencies \"lookup\" : Performs a package file scan to identify the extracted dependencies and updates available \"full\" : Performs a dry run by logging messages instead of creating/updating/deleting branches and PRs Information provided mainly in debug log level.","title":"dryRun"},{"location":"self-hosted-configuration/#endpoint","text":"Custom endpoint to use. Name Value type string cli --endpoint env RENOVATE_ENDPOINT","title":"endpoint"},{"location":"self-hosted-configuration/#executiontimeout","text":"Default execution timeout in minutes for child processes Renovate creates. Name Value type integer default 15 cli --execution-timeout env RENOVATE_EXECUTION_TIMEOUT Default execution timeout in minutes for child processes Renovate creates. If this option is not set, Renovate will fallback to 15 minutes.","title":"executionTimeout"},{"location":"self-hosted-configuration/#exposeallenv","text":"Set this to true to allow passing of all environment variables to package managers. Name Value type boolean default false cli --expose-all-env env RENOVATE_EXPOSE_ALL_ENV To keep you safe, Renovate only passes a limited set of environment variables to package managers. Confidential data can be leaked if a malicious script enumerates all environment variables. Set exposeAllEnv to true only if you have reviewed, and trust, the repositories which Renovate bot runs against. Setting this to true also allows for variable substitution in .npmrc files.","title":"exposeAllEnv"},{"location":"self-hosted-configuration/#force","text":"Any configuration set in this object will force override existing settings. Name Value type object This object is used as a \"force override\" when you need to make sure certain configuration overrides whatever is configured in the repository. For example, forcing a null (no) schedule to make sure Renovate raises PRs on a run even if the repository itself or its preset defines a schedule that's currently inactive. In practice, it is implemented by converting the force configuration into a packageRule that matches all packages.","title":"force"},{"location":"self-hosted-configuration/#forcecli","text":"Decides if CLI configuration options are moved to the force config section. Name Value type boolean default true cli --force-cli env RENOVATE_FORCE_CLI This is set to true by default, meaning that any settings (such as schedule ) take maximum priority even against custom settings existing inside individual repositories. It will also override any settings in packageRules .","title":"forceCli"},{"location":"self-hosted-configuration/#forkmode","text":"Set to true to fork the source repository and create branches there instead. Name Value type boolean default false cli --fork-mode env RENOVATE_FORK_MODE You probably have no need for this option - it is an experimental setting for the Renovate hosted GitHub App. If this is set to true then Renovate will fork the repository into the personal space of the person owning the Personal Access Token.","title":"forkMode"},{"location":"self-hosted-configuration/#forktoken","text":"Will be used on GitHub when forkMode is set to true to clone the repositories. Name Value type string default \"\" cli --fork-token env RENOVATE_FORK_TOKEN You probably don't need this option - it is an experimental setting for the Renovate hosted GitHub App. This should be set to a Personal Access Token (GitHub only) when forkMode is set to true . Renovate will use this token to fork the repository into the personal space of the person owning the Personal Access Token. Renovate will then create branches on the fork and opens Pull Requests on the parent repository.","title":"forkToken"},{"location":"self-hosted-configuration/#gitnoverify","text":"Which Git commands will be run with the --no-verify option. Name Value type array subType string allowedValues commit,push default [\"commit\",\"push\"] cli --git-no-verify env RENOVATE_GIT_NO_VERIFY Controls when Renovate passes the --no-verify flag to git . The flag can be passed to git commit and/or git push . Read the documentation for git commit --no-verify and git push --no-verify to learn exactly what each flag does. To learn more about Git hooks, read the Pro Git 2 book, section on Git Hooks .","title":"gitNoVerify"},{"location":"self-hosted-configuration/#gitprivatekey","text":"PGP key to use for signing Git commits. Name Value type string env RENOVATE_GIT_PRIVATE_KEY default null This should be an armored private key, so the type you get from running gpg --export-secret-keys --armor 92066A17F0D1707B4E96863955FEF5171C45FAE5 > private.key . Replace the newlines with \\n before adding the resulting single-line value to your bot's config. Note The private key can't be protected with a passphrase if running in a headless environment. Renovate will not be able to handle entering the passphrase. It will be loaded lazily . Before the first commit in a repository, Renovate will: Run gpg import (if you haven't before) Run git config user.signingkey and git config commit.gpgsign true The git commands are run locally in the cloned repo instead of globally. This reduces the chance of unintended consequences with global Git configs on shared systems.","title":"gitPrivateKey"},{"location":"self-hosted-configuration/#gittimeout","text":"Configure the timeout with a number of milliseconds to wait for a Git task. Name Value type integer default 0 cli --git-timeout env RENOVATE_GIT_TIMEOUT To handle the case where the underlying Git processes appear to hang, configure the timeout with the number of milliseconds to wait after last received content on either stdOut or stdErr streams before sending a SIGINT kill message.","title":"gitTimeout"},{"location":"self-hosted-configuration/#giturl","text":"Overrides the default resolution for Git remote, e.g. to switch GitLab from HTTPS to SSH-based. Name Value type string allowedValues default,ssh,endpoint default \"default\" cli --git-url env RENOVATE_GIT_URL Override the default resolution for Git remote, e.g. to switch GitLab from HTTPS to SSH-based. Currently works for GitLab only. Possible values: default : use HTTPS URLs provided by the platform for Git ssh : use SSH URLs provided by the platform for Git endpoint : ignore URLs provided by the platform and use the configured endpoint directly","title":"gitUrl"},{"location":"self-hosted-configuration/#githubtokenwarn","text":"Display warnings about GitHub token not being set. Name Value type boolean default true cli --github-token-warn env RENOVATE_GITHUB_TOKEN_WARN By default, Renovate logs and displays a warning when the GITHUB_COM_TOKEN is not set. By setting githubTokenWarn to false , Renovate suppresses these warnings on Pull Requests, etc. Disabling the warning is helpful for self-hosted environments that can't access the github.com domain, because the warning is useless in these environments.","title":"githubTokenWarn"},{"location":"self-hosted-configuration/#globalextends","text":"Configuration presets to use or extend for a self-hosted config. Name Value type array subType string cli --global-extends env RENOVATE_GLOBAL_EXTENDS Unlike the extends field, which is passed through unresolved to be part of repository config, any presets in globalExtends are resolved immediately as part of global config. Use the globalExtends field if your preset has any global-only configuration options, such as the list of repositories to run against. Use the extends field instead of this if, for example, you need the ability for a repository config (e.g. renovate.json ) to be able to use ignorePresets for any preset defined in global config.","title":"globalExtends"},{"location":"self-hosted-configuration/#logcontext","text":"Add a global or per-repo log context to each log entry. Name Value type string cli --log-context env RENOVATE_LOG_CONTEXT logContext is included with each log entry only if logFormat=\"json\" - it is not included in the pretty log output. If left as default (null), a random short ID will be selected.","title":"logContext"},{"location":"self-hosted-configuration/#logfile","text":"Log file path. Name Value type string cli --log-file env RENOVATE_LOG_FILE default null","title":"logFile"},{"location":"self-hosted-configuration/#logfilelevel","text":"Set the log file log level. Name Value type string default \"debug\" cli --log-file-level env RENOVATE_LOG_FILE_LEVEL","title":"logFileLevel"},{"location":"self-hosted-configuration/#migratepresets","text":"Define presets here which have been removed or renamed and should be migrated automatically. Name Value type object additionalProperties [object Object] cli --migrate-presets env RENOVATE_MIGRATE_PRESETS Use this if you have repositories that extend from a particular preset, which has now been renamed or removed. This is handy if you have a large number of repositories that all extend from a particular preset which you want to rename, without the hassle of manually updating every repository individually. Use an empty string to indicate that the preset should be ignored rather than replaced. Example: modules . exports = { migratePresets : { '@company' : 'local>org/renovate-config' , }, }; In the above example any reference to the @company preset will be replaced with local>org/renovate-config .","title":"migratePresets"},{"location":"self-hosted-configuration/#onboarding","text":"Require a Configuration PR first. Name Value type boolean cli --onboarding env RENOVATE_ONBOARDING default true Only set this to false if all three statements are true: You've configured Renovate entirely on the bot side (e.g. empty renovate.json in repositories) You want to run Renovate on every repository the bot has access to You want to skip all onboarding PRs","title":"onboarding"},{"location":"self-hosted-configuration/#onboardingbranch","text":"Change this value to override the default onboarding branch name. Name Value type string default \"renovate/configure\" env RENOVATE_ONBOARDING_BRANCH Note This setting is independent of branchPrefix . For example, if you configure branchPrefix to be renovate- then you'd still have the onboarding PR created with branch renovate/configure until you configure onboardingBranch=renovate-configure or similar. If you have an existing Renovate installation and you change onboardingBranch then it's possible that you'll get onboarding PRs for repositories that had previously closed the onboarding PR unmerged.","title":"onboardingBranch"},{"location":"self-hosted-configuration/#onboardingcommitmessage","text":"Change this value to override the default onboarding commit message. Name Value type string env RENOVATE_ONBOARDING_COMMIT_MESSAGE If commitMessagePrefix or semanticCommits values are set then they will be prepended to the commit message using the same logic that is used for adding them to non-onboarding commit messages.","title":"onboardingCommitMessage"},{"location":"self-hosted-configuration/#onboardingconfig","text":"Configuration to use for onboarding PRs. Name Value type object default {\"$schema\":\"https://docs.renovatebot.com/renovate-schema.json\"} mergeable true cli --onboarding-config env RENOVATE_ONBOARDING_CONFIG","title":"onboardingConfig"},{"location":"self-hosted-configuration/#onboardingconfigfilename","text":"Change this value to override the default onboarding config file name. Name Value type string default \"renovate.json\" env RENOVATE_ONBOARDING_CONFIG_FILE_NAME If set to one of the valid config file names , the onboarding PR will create a configuration file with the provided name instead of renovate.json . Falls back to renovate.json if the name provided is not valid.","title":"onboardingConfigFileName"},{"location":"self-hosted-configuration/#onboardingnodeps","text":"Onboard the repository even if no dependencies are found. Name Value type boolean default false cli --onboarding-no-deps env RENOVATE_ONBOARDING_NO_DEPS Set this to true if you want Renovate to create an onboarding PR even if no dependencies are found. Otherwise, Renovate skips onboarding a repository if it finds no dependencies in it.","title":"onboardingNoDeps"},{"location":"self-hosted-configuration/#onboardingprtitle","text":"Change this value to override the default onboarding PR title. Name Value type string default \"Configure Renovate\" env RENOVATE_ONBOARDING_PR_TITLE Similarly to onboardingBranch , if you have an existing Renovate installation and you change onboardingPrTitle then it's possible that you'll get onboarding PRs for repositories that had previously closed the onboarding PR unmerged.","title":"onboardingPrTitle"},{"location":"self-hosted-configuration/#optimizefordisabled","text":"Set to true to first check for disabling in config before cloning. Name Value type boolean default false cli --optimize-for-disabled env RENOVATE_OPTIMIZE_FOR_DISABLED","title":"optimizeForDisabled"},{"location":"self-hosted-configuration/#password","text":"Password for authentication. Name Value type string supportedPlatforms azure,bitbucket,bitbucket-server cli --password env RENOVATE_PASSWORD default null","title":"password"},{"location":"self-hosted-configuration/#persistrepodata","text":"If set to true , repository data is kept between runs instead of deleted. Name Value type boolean default false cli --persist-repo-data env RENOVATE_PERSIST_REPO_DATA Set this to true if you want Renovate to persist repo data between runs. The intention is that this allows Renovate to do a faster git fetch between runs rather than git clone . It also may mean that ignored directories like node_modules can be preserved and save time on operations like npm install .","title":"persistRepoData"},{"location":"self-hosted-configuration/#platform","text":"Platform type of repository. Name Value type string allowedValues azure,bitbucket,bitbucket-server,gitea,github,gitlab default \"github\" cli --platform env RENOVATE_PLATFORM","title":"platform"},{"location":"self-hosted-configuration/#prcommitsperrunlimit","text":"Set the maximum number of commits per Renovate run. By default there is no limit. Name Value type integer default 0 cli --pr-commits-per-run-limit env RENOVATE_PR_COMMITS_PER_RUN_LIMIT Parameter to reduce CI load. CI jobs are usually triggered by these events: pull-request creation, pull-request update, automerge events. Set as an integer. Default is no limit.","title":"prCommitsPerRunLimit"},{"location":"self-hosted-configuration/#printconfig","text":"If enabled, Renovate logs the fullly resolved config for each repo, plus the fully resolved presets. Name Value type boolean default false cli --print-config env RENOVATE_PRINT_CONFIG This option is useful for troubleshooting, particularly if using presets. e.g. run renovate foo/bar --print-config > config.log and the fully-resolved config will be included in the log file.","title":"printConfig"},{"location":"self-hosted-configuration/#privatekey","text":"Server-side private key. Name Value type string replaceLineReturns true cli --private-key env RENOVATE_PRIVATE_KEY default null This private key is used to decrypt config files. The corresponding public key can be used to create encrypted values for config files. If you want a simple UI to encrypt values you can put the public key in a HTML page similar to https://app.renovatebot.com/encrypt . To create the key pair with GPG use the following commands: gpg --full-generate-key and follow the prompts to generate a key. Name and email are not important to Renovate, and do not configure a passphrase. Use a 4096bit key. key generation log \u276f gpg --full-generate-key gpg (GnuPG) 2.2.24; Copyright (C) 2020 Free Software Foundation, Inc. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Please select what kind of key you want: (1) RSA and RSA (default) (2) DSA and Elgamal (3) DSA (sign only) (4) RSA (sign only) (14) Existing key from card Your selection? 1 RSA keys may be between 1024 and 4096 bits long. What keysize do you want? (3072) 4096 Requested keysize is 4096 bits Please specify how long the key should be valid. 0 = key does not expire <n> = key expires in n days <n>w = key expires in n weeks <n>m = key expires in n months <n>y = key expires in n years Key is valid for? (0) Key does not expire at all Is this correct? (y/N) y GnuPG needs to construct a user ID to identify your key. Real name: Renovate Bot Email address: renovate@whitesourcesoftware.com Comment: You selected this USER-ID: \"Renovate Bot <renovate@whitesourcesoftware.com>\" Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? O gpg: key 0649CC3899F22A66 marked as ultimately trusted gpg: revocation certificate stored as '/Users/rhys/.gnupg/openpgp-revocs.d/794B820F34B34A8DF32AADB20649CC3899F22A66.rev' public and secret key created and signed. pub rsa4096 2021-09-10 [SC] 794B820F34B34A8DF32AADB20649CEXAMPLEONLY uid Renovate Bot <renovate@whitesourcesoftware.com> sub rsa4096 2021-09-10 [E] Copy the key ID from the output ( 794B820F34B34A8DF32AADB20649CEXAMPLEONLY in the above example) or run gpg --list-secret-keys if you forgot to take a copy Run gpg --armor --export-secret-keys YOUR_NEW_KEY_ID > renovate-private-key.asc to generate an armored (text-based) private key file Run gpg --armor --export YOUR_NEW_KEY_ID > renovate-public-key.asc to generate an armored (text-based) public key file The private key should then be added to your Renovate Bot global config (either using privateKeyPath or exporting it to the RENOVATE_PRIVATE_KEY environment variable). The public key can be used to replace the existing key in https://app.renovatebot.com/encrypt for your own use. Any encrypted secrets using GPG must have a mandatory organization/group scope, and optionally can be scoped for a single repository only. The reason for this is to avoid \"replay\" attacks where someone could learn your encrypted secret and then reuse it in their own Renovate repositories. Instead, with scoped secrets it means that Renovate ensures that the organization and optionally repository values encrypted with the secret match against the running repository. Note Simple public key encryption was previously used to encrypt secrets, but this approach has been deprecated and is no longer documented.","title":"privateKey"},{"location":"self-hosted-configuration/#privatekeyold","text":"Secondary or old private key to try. Name Value type string replaceLineReturns true cli --private-key-old env RENOVATE_PRIVATE_KEY_OLD default null Use this field if you need to perform a \"key rotation\" and support more than one keypair at a time. Decryption with this key will be tried after privateKey . If you are migrating from the legacy public key encryption approach to use GPG, then move your legacy private key from privateKey to privateKeyOld and then put your new GPG private key in privateKey . Doing so will mean that Renovate will first try to decrypt using the GPG key but fall back to the legacy key and try that next. You can remove the privateKeyOld config option once all the old encrypted values have been migrated, or if you no longer want to support the old key and let the processing of repositories fail.","title":"privateKeyOld"},{"location":"self-hosted-configuration/#privatekeypath","text":"Path to the Server-side private key. Name Value type string cli --private-key-path env RENOVATE_PRIVATE_KEY_PATH default null Used as an alternative to privateKey , if you want the key to be read from disk instead.","title":"privateKeyPath"},{"location":"self-hosted-configuration/#privatekeypathold","text":"Path to the Server-side old private key. Name Value type string cli --private-key-path-old env RENOVATE_PRIVATE_KEY_PATH_OLD default null Used as an alternative to privateKeyOld , if you want the key to be read from disk instead.","title":"privateKeyPathOld"},{"location":"self-hosted-configuration/#productlinks","text":"Links which are used in PRs, issues and comments. Name Value type object mergeable true default {\"documentation\":\"https://docs.renovatebot.com/\",\"help\":\"https://github.com/renovatebot/renovate/discussions\",\"homepage\":\"https://github.com/renovatebot/renovate\"} additionalProperties [object Object] cli --product-links env RENOVATE_PRODUCT_LINKS Override this object if you want to change the URLs that Renovate links to, e.g. if you have an internal forum for asking for help.","title":"productLinks"},{"location":"self-hosted-configuration/#redisurl","text":"If set, this Redis URL will be used for caching instead of the file system. Name Value type string cli --redis-url env RENOVATE_REDIS_URL default null If this value is set then Renovate will use Redis for its global cache instead of the local file system. The global cache is used to store lookup results (e.g. dependency versions and release notes) between repositories and runs. Example url: redis://localhost .","title":"redisUrl"},{"location":"self-hosted-configuration/#repositories","text":"List of Repositories. Name Value type array env RENOVATE_REPOSITORIES Elements in the repositories array can be an object if you wish to define additional settings: { repositories : [ { repository : 'g/r1' , bumpVersion : true }, 'g/r2' ], }","title":"repositories"},{"location":"self-hosted-configuration/#repositorycache","text":"This option decides if Renovate uses a JSON cache to speed up extractions. Name Value type string allowedValues disabled,enabled,reset default \"disabled\" cli --repository-cache env RENOVATE_REPOSITORY_CACHE Set this to \"enabled\" to have Renovate maintain a JSON file cache per-repository to speed up extractions. Set to \"reset\" if you ever need to bypass the cache and have it overwritten. JSON files will be stored inside the cacheDir beside the existing file-based package cache. Warning This is an experimental feature and may be modified or removed in a future non-major release.","title":"repositoryCache"},{"location":"self-hosted-configuration/#requireconfig","text":"Controls Renovate's behavior regarding repository config files such as renovate.json . Name Value type string default \"required\" allowedValues required,optional,ignored cli --require-config env RENOVATE_REQUIRE_CONFIG By default, Renovate needs a Renovate config file in each repository where it runs before it will propose any dependency updates. You can choose any of these settings: \"required\" (default): a repository config file must be present \"optional\" : if a config file exists, Renovate will use it when it runs \"ignored\" : config files in the repo will be ignored, and have no effect This feature is closely related to the onboarding config option. The combinations of requireConfig and onboarding are: onboarding=true onboarding=false requireConfig=required An onboarding PR will be created if no config file exists. If the onboarding PR is closed and there's no config file, then the repository is skipped. Repository is skipped unless a config file is added manually. requireConfig=optional An onboarding PR will be created if no config file exists. If the onboarding PR is closed and there's no config file, the repository will be processed. Repository is processed regardless of config file presence. requireConfig=ignored No onboarding PR will be created and repo will be processed while ignoring any config file present. Repository is processed, any config file is ignored.","title":"requireConfig"},{"location":"self-hosted-configuration/#secrets","text":"Object which holds secret name/value pairs. Name Value type object mergeable true additionalProperties [object Object] cli --secrets env RENOVATE_SECRETS Secrets may be configured by a bot admin in config.js , which will then make them available for templating within repository configs. For example, to configure a GOOGLE_TOKEN to be accessible by all repositories: module . exports = { secrets : { GOOGLE_TOKEN : 'abc123' , }, }; They can also be configured per repository, e.g. module . exports = { repositories : [ { repository : 'abc/def' , secrets : { GOOGLE_TOKEN : 'abc123' , }, }, ], }; It could then be used in a repository config or preset like so: { \"hostRules\" : [ { \"matchHost\" : \"google.com\" , \"token\" : \"{{ secrets.GOOGLE_TOKEN }}\" } ] } Secret names must start with an upper or lower case character and can have only characters, digits, or underscores.","title":"secrets"},{"location":"self-hosted-configuration/#skipinstalls","text":"Skip installing modules/dependencies if lock file updating is possible without a full install. Name Value type boolean cli --skip-installs env RENOVATE_SKIP_INSTALLS default null By default, Renovate will use the most efficient approach to updating package files and lock files, which in most cases skips the need to perform a full module install by the bot. If this is set to false, then a full install of modules will be done. This is currently applicable to npm and lerna / npm only, and only used in cases where bugs in npm result in incorrect lock files being updated.","title":"skipInstalls"},{"location":"self-hosted-configuration/#token","text":"Repository Auth Token. Name Value type string cli --token env RENOVATE_TOKEN default null","title":"token"},{"location":"self-hosted-configuration/#unicodeemoji","text":"Enable or disable Unicode emoji. Name Value type boolean default true cli --unicode-emoji env RENOVATE_UNICODE_EMOJI If enabled emoji shortcodes ( :warning: ) are replaced with their Unicode equivalents ( \u26a0\ufe0f ).","title":"unicodeEmoji"},{"location":"self-hosted-configuration/#username","text":"Username for authentication. Name Value type string supportedPlatforms azure,bitbucket,bitbucket-server cli --username env RENOVATE_USERNAME default null You may need to set a username if you: use the Bitbucket platform, or use the GitHub App with CLI (required) If you're using a Personal Access Token (PAT) to authenticate then you should not set a username .","title":"username"},{"location":"self-hosted-configuration/#writediscoveredrepos","text":"Writes discovered repositories to a JSON file and then exit. Name Value type string cli --write-discovered-repos default null Optional parameter which allows to write the discovered repositories into a JSON file instead of renovating them. Usage: renovate --write-discovered-repos=/tmp/renovate-repos.json [ \"myOrg/myRepo\" , \"myOrg/anotherRepo\" ]","title":"writeDiscoveredRepos"},{"location":"self-hosted-experimental/","text":"Self-hosted experimental environment variables \u00b6 The following environment variables are \"experimental\" because: They are not commonly needed They are typically an effort to work around some other service's or platform's problem They can be removed at any time They are variables for Renovate's internal use to validate they work as intended Experimental variables which are commonly used and for which there is no external solution in sight can be converted to an official configuration option by the Renovate bot developers. Use these experimental variables at your own risk. We do not follow Semantic Versioning for any experimental variables. These variables may be removed or have their behavior changed in any version. We will try to keep breakage to a minimum, but make no guarantees that an experimental variable will keep working. RENOVATE_CACHE_NPM_MINUTES \u00b6 If set to any integer, Renovate will use this integer instead of the default npm cache time (15 minutes) for the npm datasource. RENOVATE_EXPERIMENTAL_NO_MAVEN_POM_CHECK \u00b6 If set to any value, Renovate will skip its default artifacts filter check in the Maven datasource. Skipping the check will speed things up, but may result in versions being returned which don't properly exist on the server. RENOVATE_PAGINATE_ALL \u00b6 If set to any value, Renovate will always paginate requests to GitHub fully, instead of stopping after 10 pages. RENOVATE_REUSE_PACKAGE_LOCK \u00b6 If set to \"false\" (string), Renovate will remove any existing package-lock.json before trying to update it. RENOVATE_USER_AGENT \u00b6 If set to any string, Renovate will use this as the user-agent it sends with HTTP requests. RENOVATE_X_HARD_EXIT \u00b6 If set to any value, Renovate will use a \"hard\" process.exit() once all work is done, even if a sub-process is otherwise delaying Node.js from exiting. See https://github.com/renovatebot/renovate/issues/8660 for background on why this was created. RENOVATE_X_PLATFORM_VERSION \u00b6 If set, Renovate will use this string as GitLab server version instead of checking via the GitLab API. This can be useful when you use the GitLab CI_JOB_TOKEN to authenticate Renovate. Read platform details to learn why we need the server version on GitLab.","title":"Self-hosted experimental environment variables"},{"location":"self-hosted-experimental/#self-hosted-experimental-environment-variables","text":"The following environment variables are \"experimental\" because: They are not commonly needed They are typically an effort to work around some other service's or platform's problem They can be removed at any time They are variables for Renovate's internal use to validate they work as intended Experimental variables which are commonly used and for which there is no external solution in sight can be converted to an official configuration option by the Renovate bot developers. Use these experimental variables at your own risk. We do not follow Semantic Versioning for any experimental variables. These variables may be removed or have their behavior changed in any version. We will try to keep breakage to a minimum, but make no guarantees that an experimental variable will keep working.","title":"Self-hosted experimental environment variables"},{"location":"self-hosted-experimental/#renovate_cache_npm_minutes","text":"If set to any integer, Renovate will use this integer instead of the default npm cache time (15 minutes) for the npm datasource.","title":"RENOVATE_CACHE_NPM_MINUTES"},{"location":"self-hosted-experimental/#renovate_experimental_no_maven_pom_check","text":"If set to any value, Renovate will skip its default artifacts filter check in the Maven datasource. Skipping the check will speed things up, but may result in versions being returned which don't properly exist on the server.","title":"RENOVATE_EXPERIMENTAL_NO_MAVEN_POM_CHECK"},{"location":"self-hosted-experimental/#renovate_paginate_all","text":"If set to any value, Renovate will always paginate requests to GitHub fully, instead of stopping after 10 pages.","title":"RENOVATE_PAGINATE_ALL"},{"location":"self-hosted-experimental/#renovate_reuse_package_lock","text":"If set to \"false\" (string), Renovate will remove any existing package-lock.json before trying to update it.","title":"RENOVATE_REUSE_PACKAGE_LOCK"},{"location":"self-hosted-experimental/#renovate_user_agent","text":"If set to any string, Renovate will use this as the user-agent it sends with HTTP requests.","title":"RENOVATE_USER_AGENT"},{"location":"self-hosted-experimental/#renovate_x_hard_exit","text":"If set to any value, Renovate will use a \"hard\" process.exit() once all work is done, even if a sub-process is otherwise delaying Node.js from exiting. See https://github.com/renovatebot/renovate/issues/8660 for background on why this was created.","title":"RENOVATE_X_HARD_EXIT"},{"location":"self-hosted-experimental/#renovate_x_platform_version","text":"If set, Renovate will use this string as GitLab server version instead of checking via the GitLab API. This can be useful when you use the GitLab CI_JOB_TOKEN to authenticate Renovate. Read platform details to learn why we need the server version on GitLab.","title":"RENOVATE_X_PLATFORM_VERSION"},{"location":"semantic-commits/","text":"Semantic Commit messages \u00b6 To detect if your repository uses semantic commits, Renovate looks at the latest 10 commit messages in the base branch. It then uses conventional-commits-detector to determine what convention the commit messages follow. Renovate only detects Angular-style conventional commits, it ignores all other commit conventions. When Renovate finds Angular-style commits, Renovate will create commit messages and PR titles that look like this: chore(deps): update eslint to v7.30.0 fix(deps): update express to v4.17.1 Renovate uses the chore prefix by default. When you extend config:base , Renovate still defaults to chore , but will use the fix prefix for npm production dependencies ( devDependencies still use chore ). Manually enabling or disabling semantic commits \u00b6 You can override the default settings, and disable or enable semantic commits. If you want Renovate to use semantic commits: add \":semanticCommits\" to your extends array. If you want Renovate to stop using semantic commits, add \":semanticCommitsDisabled\" to your extends array. Changing the Semantic Commit type \u00b6 You can change the Semantic Commit type that Renovate uses. Say you want Renovate to use \"chore\" for every PR, you can add \":semanticCommitTypeAll(chore)\" to your extends array. PR titles and commit messages start with \"chore(deps):\" Or say you want to use \"ci\" for every PR, then you would add \":semanticCommitTypeAll(ci)\" to your extends array instead. PR titles and commit messages start with \"ci(deps):\" Changing the Semantic Commit scope \u00b6 If you don't like the default \"deps\" scope, you can use another word for the scope instead. For example, to set the scope to \"package\" instead, add the preset \":semanticCommitScope(package)\" to your extends array. If you want to remove the semantic commit scope (e.g. use prefix chore: instead of chore(deps): ), then add the preset \":semanticCommitScopeDisabled\" to your extends array.","title":"Semantic Commit Messages"},{"location":"semantic-commits/#semantic-commit-messages","text":"To detect if your repository uses semantic commits, Renovate looks at the latest 10 commit messages in the base branch. It then uses conventional-commits-detector to determine what convention the commit messages follow. Renovate only detects Angular-style conventional commits, it ignores all other commit conventions. When Renovate finds Angular-style commits, Renovate will create commit messages and PR titles that look like this: chore(deps): update eslint to v7.30.0 fix(deps): update express to v4.17.1 Renovate uses the chore prefix by default. When you extend config:base , Renovate still defaults to chore , but will use the fix prefix for npm production dependencies ( devDependencies still use chore ).","title":"Semantic Commit messages"},{"location":"semantic-commits/#manually-enabling-or-disabling-semantic-commits","text":"You can override the default settings, and disable or enable semantic commits. If you want Renovate to use semantic commits: add \":semanticCommits\" to your extends array. If you want Renovate to stop using semantic commits, add \":semanticCommitsDisabled\" to your extends array.","title":"Manually enabling or disabling semantic commits"},{"location":"semantic-commits/#changing-the-semantic-commit-type","text":"You can change the Semantic Commit type that Renovate uses. Say you want Renovate to use \"chore\" for every PR, you can add \":semanticCommitTypeAll(chore)\" to your extends array. PR titles and commit messages start with \"chore(deps):\" Or say you want to use \"ci\" for every PR, then you would add \":semanticCommitTypeAll(ci)\" to your extends array instead. PR titles and commit messages start with \"ci(deps):\"","title":"Changing the Semantic Commit type"},{"location":"semantic-commits/#changing-the-semantic-commit-scope","text":"If you don't like the default \"deps\" scope, you can use another word for the scope instead. For example, to set the scope to \"package\" instead, add the preset \":semanticCommitScope(package)\" to your extends array. If you want to remove the semantic commit scope (e.g. use prefix chore: instead of chore(deps): ), then add the preset \":semanticCommitScopeDisabled\" to your extends array.","title":"Changing the Semantic Commit scope"},{"location":"setup-azure-devops/","text":"Azure DevOps setup \u00b6 This document explains how to setup Renovate for use on Azure DevOps. Setting up a new pipeline \u00b6 Create a brand new pipeline within Azure DevOps, and select your source: Then select your repository. Within Configure your pipeline select: Starter pipeline Replace all content in the starter pipeline with: schedules : - cron : '0 3 * * *' displayName : 'Every day at 3am' branches : include : [ main ] always : true trigger : none pool : vmImage : ubuntu-latest steps : - task : npmAuthenticate@0 inputs : workingFile : .npmrc - bash : | git config --global user.email 'bot@renovateapp.com' git config --global user.name 'Renovate Bot' npx --userconfig .npmrc renovate env : TOKEN : $(System.AccessToken) Create a .npmrc file \u00b6 Create a .npmrc file in your repository: registry = https://pkgs.dev.azure.com/YOUR-ORG/_packaging/YOUR-FEED/npm/registry/ always-auth = true For the registry key, replace YOUR-ORG with your Azure DevOps organization and YOUR-FEED with your Azure Artifacts feed. Create a config.js file \u00b6 Create a config.js file in your repository: module . exports = { platform : 'azure' , endpoint : 'https://dev.azure.com/YOUR-ORG/' , token : process . env . TOKEN , hostRules : [ { hostType : 'npm' , matchHost : 'pkgs.dev.azure.com' , username : 'apikey' , password : process . env . TOKEN , }, ], repositories : [ 'YOUR-PROJECT/YOUR-REPO' ], }; For the endpoint key, replace YOUR-ORG with your Azure DevOps organization. For the repositories key, replace YOUR-PROJECT/YOUR-REPO with your Azure DevOps project and repository. Yarn users \u00b6 To do a successful yarn install you need to match the URL of the registry fully. Use the matchHost config option to specify the full path to the registry. module . exports = { platform : 'azure' , endpoint : 'https://myorg.visualstudio.com/' , token : process . env . TOKEN , hostRules : [ { matchHost : 'https://myorg.pkgs.visualstudio.com/_packaging/myorg/npm/registry/' , token : process . env . TOKEN , hostType : 'npm' , }, { matchHost : 'github.com' , token : process . env . GITHUB_COM_TOKEN , }, ], repositories : [ 'YOUR-PROJECT/YOUR-REPO' ], }; Put this in your repository's .npmrc file: registry = https://myorg.pkgs.visualstudio.com/_packaging/myorg/npm/registry/ always-auth = true Add renovate.json file \u00b6 Additionally, you can create a renovate.json file (which holds the Renovate configuration) in the root of the repository you want to update. Read more about the Renovate configuration options Using a single pipeline to update multiple repositories \u00b6 If you want to use a single Renovate pipeline to update multiple repositories you must take the following steps. Add the names of the repositories to config.js . Make sure that the \"Project Collection Build Service (YOUR-PROJECT)\" user has the following permissions on the repositories: Contribute Contribute to pull requests Create branch","title":"Azure DevOps setup"},{"location":"setup-azure-devops/#azure-devops-setup","text":"This document explains how to setup Renovate for use on Azure DevOps.","title":"Azure DevOps setup"},{"location":"setup-azure-devops/#setting-up-a-new-pipeline","text":"Create a brand new pipeline within Azure DevOps, and select your source: Then select your repository. Within Configure your pipeline select: Starter pipeline Replace all content in the starter pipeline with: schedules : - cron : '0 3 * * *' displayName : 'Every day at 3am' branches : include : [ main ] always : true trigger : none pool : vmImage : ubuntu-latest steps : - task : npmAuthenticate@0 inputs : workingFile : .npmrc - bash : | git config --global user.email 'bot@renovateapp.com' git config --global user.name 'Renovate Bot' npx --userconfig .npmrc renovate env : TOKEN : $(System.AccessToken)","title":"Setting up a new pipeline"},{"location":"setup-azure-devops/#create-a-npmrc-file","text":"Create a .npmrc file in your repository: registry = https://pkgs.dev.azure.com/YOUR-ORG/_packaging/YOUR-FEED/npm/registry/ always-auth = true For the registry key, replace YOUR-ORG with your Azure DevOps organization and YOUR-FEED with your Azure Artifacts feed.","title":"Create a .npmrc file"},{"location":"setup-azure-devops/#create-a-configjs-file","text":"Create a config.js file in your repository: module . exports = { platform : 'azure' , endpoint : 'https://dev.azure.com/YOUR-ORG/' , token : process . env . TOKEN , hostRules : [ { hostType : 'npm' , matchHost : 'pkgs.dev.azure.com' , username : 'apikey' , password : process . env . TOKEN , }, ], repositories : [ 'YOUR-PROJECT/YOUR-REPO' ], }; For the endpoint key, replace YOUR-ORG with your Azure DevOps organization. For the repositories key, replace YOUR-PROJECT/YOUR-REPO with your Azure DevOps project and repository.","title":"Create a config.js file"},{"location":"setup-azure-devops/#yarn-users","text":"To do a successful yarn install you need to match the URL of the registry fully. Use the matchHost config option to specify the full path to the registry. module . exports = { platform : 'azure' , endpoint : 'https://myorg.visualstudio.com/' , token : process . env . TOKEN , hostRules : [ { matchHost : 'https://myorg.pkgs.visualstudio.com/_packaging/myorg/npm/registry/' , token : process . env . TOKEN , hostType : 'npm' , }, { matchHost : 'github.com' , token : process . env . GITHUB_COM_TOKEN , }, ], repositories : [ 'YOUR-PROJECT/YOUR-REPO' ], }; Put this in your repository's .npmrc file: registry = https://myorg.pkgs.visualstudio.com/_packaging/myorg/npm/registry/ always-auth = true","title":"Yarn users"},{"location":"setup-azure-devops/#add-renovatejson-file","text":"Additionally, you can create a renovate.json file (which holds the Renovate configuration) in the root of the repository you want to update. Read more about the Renovate configuration options","title":"Add renovate.json file"},{"location":"setup-azure-devops/#using-a-single-pipeline-to-update-multiple-repositories","text":"If you want to use a single Renovate pipeline to update multiple repositories you must take the following steps. Add the names of the repositories to config.js . Make sure that the \"Project Collection Build Service (YOUR-PROJECT)\" user has the following permissions on the repositories: Contribute Contribute to pull requests Create branch","title":"Using a single pipeline to update multiple repositories"},{"location":"templates/","text":"Template fields \u00b6 In order to provide flexible configuration, Renovate supports using \"templates\" for certain fields like branchName . Renovate's templates use handlebars under the hood. You can recognize templates when you see strings like {{depName}} in configuration fields. Below you can find lists of fields/values that you can use in templates. Some are configuration options passed through, while others are generated as part of Renovate's run. Exposed config options \u00b6 The following configuration options are passed through for templating: additionalBranchPrefix , addLabels , branchName , branchPrefix , branchTopic , commitMessage , commitMessageAction , commitMessageExtra , commitMessagePrefix , commitMessageSuffix , commitMessageTopic , gitAuthor , group , groupName , groupSlug , labels , prBodyColumns , prBodyDefinitions , prBodyNotes , prTitle , semanticCommitScope , semanticCommitType , separateMajorMinor , separateMinorPatch . Other available fields \u00b6 The following runtime values are passed through for templating: baseBranch : The baseBranch for this branch/PR body : The body of the release notes currentValue : The extracted current value of the dependency being updated currentVersion : The version that would be currently installed. For example, if currentValue is ^3.0.0 then currentVersion might be 3.1.0. datasource : The datasource used to look up the upgrade depName : The name of the dependency being updated depNameLinked : The dependency name already linked to its home page using markdown depNameSanitized : The depName field sanitized for use in branches after removing spaces and special characters depType : The dependency type (if extracted - manager-dependent) displayFrom : The current value, formatted for display displayPending : Latest pending update, if internalChecksFilter is in use displayTo : The to value, formatted for display hasReleaseNotes : true if the upgrade has release notes isLockfileUpdate : true if the branch is a lock file update isMajor : true if the upgrade is major isPatch : true if the upgrade is a patch upgrade isPin : true if the upgrade is pinning dependencies isPinDigest : true if the upgrade is pinning digests isRollback : true if the upgrade is a rollback PR isReplacement : true if the upgrade is a replacement isRange : true if the new value is a range isSingleVersion : true if the upgrade is to a single version rather than a range logJSON : ChangeLogResult object for the upgrade manager : The (package) manager which detected the dependency newDigest : The new digest value newDigestShort : A shorted version of newDigest, for use when the full digest is too long to be conveniently displayed newMajor : The major version of the new version. e.g. \"3\" if the new version if \"3.1.0\" newMinor : The minor version of the new version. e.g. \"1\" if the new version if \"3.1.0\" newName : The name of the new dependency that replaces the current deprecated dependency newValue : The new value in the upgrade. Can be a range or version e.g. \"^3.0.0\" or \"3.1.0\" newVersion : The new version in the upgrade, e.g. \"3.1.0\" packageFile : The filename that the dependency was found in packageFileDir : The directory with full path where the packageFile was found packageName : The full name that was used to look up the dependency parentDir : The name of the directory that the dependency was found in, without full path platform : VCS platform in use, e.g. \"github\", \"gitlab\", etc. prettyDepType : Massaged depType project : ChangeLogProject object recreateClosed : If true, this PR will be recreated if closed references : A list of references for the upgrade releases : An array of releases for an upgrade releaseNotes : A ChangeLogNotes object for the release repository : The current repository semanticPrefix : The fully generated semantic prefix for commit messages sourceRepo : The repository in the sourceUrl, if present sourceRepoName : The repository name in the sourceUrl, if present sourceRepoOrg : The repository organization in the sourceUrl, if present sourceRepoSlug : The slugified pathname of the sourceUrl, if present sourceUrl : The source URL for the package updateType : One of digest, pin, rollback, patch, minor, major, replacement, pinDigest upgrades : An array of upgrade objects in the branch url : The url of the release notes version : The version number of the changelog versioning : The versioning scheme in use versions : An array of ChangeLogRelease objects in the upgrade Additional Handlebars helpers \u00b6 stringToPrettyJSON \u00b6 If you want to print pretty JSON with Handlebars you can use the built-in function stringToPrettyJSON like this: {{{stringToPrettyJSON myvar}}} In the example above myvar is a variable/field, that has valid JSON. encodeURIComponent \u00b6 If you want to convert a string to a valid URI, use the built-in function encodeURIComponent like this: {{{encodeURIComponent baseDir}}} In the example above baseDir is the string you want to transform into a valid URI. Read the MDN Web Docs, encodeURIComponent() to learn more. replace \u00b6 The replace helper replaces all found strings with the replacement string. If you want to replace some characters in a string, use the built-in function replace like this: {{{replace 'github.com' 'ghc' depName}}} In the example above all matches of github.com will be replaced by ghc in depName . Read the MDN Web Docs, String.prototype.replace() to learn more. lowercase \u00b6 The lowercase helper converts a given string to lower case. {{{ lowercase depName }}} containsString \u00b6 Returns true if a given string is a substring. {{#if (containsString depName 'python')}}Python{{else}}Other{{/if}} and \u00b6 Returns true only if all expressions are true . {{#if (and isMajor hasReleaseNotes)}}Backwards Incompatible release! Check out the Release notes.{{/if}} In the example above, it will only show a text if isMajor=true and hasReleaseNotes=true . or \u00b6 Returns true if at least one expression is true . {{#if (or isPatch isSingleVersion}}Small update, safer to merge and release.{{else}}Check out the changelog for all versions before merging!{{/if}}","title":"Templates"},{"location":"templates/#template-fields","text":"In order to provide flexible configuration, Renovate supports using \"templates\" for certain fields like branchName . Renovate's templates use handlebars under the hood. You can recognize templates when you see strings like {{depName}} in configuration fields. Below you can find lists of fields/values that you can use in templates. Some are configuration options passed through, while others are generated as part of Renovate's run.","title":"Template fields"},{"location":"templates/#exposed-config-options","text":"The following configuration options are passed through for templating: additionalBranchPrefix , addLabels , branchName , branchPrefix , branchTopic , commitMessage , commitMessageAction , commitMessageExtra , commitMessagePrefix , commitMessageSuffix , commitMessageTopic , gitAuthor , group , groupName , groupSlug , labels , prBodyColumns , prBodyDefinitions , prBodyNotes , prTitle , semanticCommitScope , semanticCommitType , separateMajorMinor , separateMinorPatch .","title":"Exposed config options"},{"location":"templates/#other-available-fields","text":"The following runtime values are passed through for templating: baseBranch : The baseBranch for this branch/PR body : The body of the release notes currentValue : The extracted current value of the dependency being updated currentVersion : The version that would be currently installed. For example, if currentValue is ^3.0.0 then currentVersion might be 3.1.0. datasource : The datasource used to look up the upgrade depName : The name of the dependency being updated depNameLinked : The dependency name already linked to its home page using markdown depNameSanitized : The depName field sanitized for use in branches after removing spaces and special characters depType : The dependency type (if extracted - manager-dependent) displayFrom : The current value, formatted for display displayPending : Latest pending update, if internalChecksFilter is in use displayTo : The to value, formatted for display hasReleaseNotes : true if the upgrade has release notes isLockfileUpdate : true if the branch is a lock file update isMajor : true if the upgrade is major isPatch : true if the upgrade is a patch upgrade isPin : true if the upgrade is pinning dependencies isPinDigest : true if the upgrade is pinning digests isRollback : true if the upgrade is a rollback PR isReplacement : true if the upgrade is a replacement isRange : true if the new value is a range isSingleVersion : true if the upgrade is to a single version rather than a range logJSON : ChangeLogResult object for the upgrade manager : The (package) manager which detected the dependency newDigest : The new digest value newDigestShort : A shorted version of newDigest, for use when the full digest is too long to be conveniently displayed newMajor : The major version of the new version. e.g. \"3\" if the new version if \"3.1.0\" newMinor : The minor version of the new version. e.g. \"1\" if the new version if \"3.1.0\" newName : The name of the new dependency that replaces the current deprecated dependency newValue : The new value in the upgrade. Can be a range or version e.g. \"^3.0.0\" or \"3.1.0\" newVersion : The new version in the upgrade, e.g. \"3.1.0\" packageFile : The filename that the dependency was found in packageFileDir : The directory with full path where the packageFile was found packageName : The full name that was used to look up the dependency parentDir : The name of the directory that the dependency was found in, without full path platform : VCS platform in use, e.g. \"github\", \"gitlab\", etc. prettyDepType : Massaged depType project : ChangeLogProject object recreateClosed : If true, this PR will be recreated if closed references : A list of references for the upgrade releases : An array of releases for an upgrade releaseNotes : A ChangeLogNotes object for the release repository : The current repository semanticPrefix : The fully generated semantic prefix for commit messages sourceRepo : The repository in the sourceUrl, if present sourceRepoName : The repository name in the sourceUrl, if present sourceRepoOrg : The repository organization in the sourceUrl, if present sourceRepoSlug : The slugified pathname of the sourceUrl, if present sourceUrl : The source URL for the package updateType : One of digest, pin, rollback, patch, minor, major, replacement, pinDigest upgrades : An array of upgrade objects in the branch url : The url of the release notes version : The version number of the changelog versioning : The versioning scheme in use versions : An array of ChangeLogRelease objects in the upgrade","title":"Other available fields"},{"location":"templates/#additional-handlebars-helpers","text":"","title":"Additional Handlebars helpers"},{"location":"templates/#stringtoprettyjson","text":"If you want to print pretty JSON with Handlebars you can use the built-in function stringToPrettyJSON like this: {{{stringToPrettyJSON myvar}}} In the example above myvar is a variable/field, that has valid JSON.","title":"stringToPrettyJSON"},{"location":"templates/#encodeuricomponent","text":"If you want to convert a string to a valid URI, use the built-in function encodeURIComponent like this: {{{encodeURIComponent baseDir}}} In the example above baseDir is the string you want to transform into a valid URI. Read the MDN Web Docs, encodeURIComponent() to learn more.","title":"encodeURIComponent"},{"location":"templates/#replace","text":"The replace helper replaces all found strings with the replacement string. If you want to replace some characters in a string, use the built-in function replace like this: {{{replace 'github.com' 'ghc' depName}}} In the example above all matches of github.com will be replaced by ghc in depName . Read the MDN Web Docs, String.prototype.replace() to learn more.","title":"replace"},{"location":"templates/#lowercase","text":"The lowercase helper converts a given string to lower case. {{{ lowercase depName }}}","title":"lowercase"},{"location":"templates/#containsstring","text":"Returns true if a given string is a substring. {{#if (containsString depName 'python')}}Python{{else}}Other{{/if}}","title":"containsString"},{"location":"templates/#and","text":"Returns true only if all expressions are true . {{#if (and isMajor hasReleaseNotes)}}Backwards Incompatible release! Check out the Release notes.{{/if}} In the example above, it will only show a text if isMajor=true and hasReleaseNotes=true .","title":"and"},{"location":"templates/#or","text":"Returns true if at least one expression is true . {{#if (or isPatch isSingleVersion}}Small update, safer to merge and release.{{else}}Check out the changelog for all versions before merging!{{/if}}","title":"or"},{"location":"troubleshooting/","text":"Troubleshooting Renovate \u00b6 Learn how to troubleshoot problems with Renovate, where to find the logging output, and how to get help if needed. Getting the logs \u00b6 Renovate's debug-level logs are usually enough to help troubleshoot most problems. Where you can find the logs depends on how you're running Renovate. GitHub Hosted app \u00b6 Each pull request from Renovate has a link to the Mend Renovate Dashboard in the PR body text. The text you're looking for is: This PR has been generated by Mend Renovate. View repository job log here. Click on the blue text \"here\" to go to the Mend Renovate App Dashboard. Sign in with your GitHub or GitLab account. Once you're logged in, you can see the logs for the Renovate jobs on your repository. You should have access to any repository which you have write access to and which has Renovate installed. Renovate only makes logs for the last 3 days available. When you've clicked on a recent job, you'll be able to select a debug level that you care about. For a full overview, make sure you select the DEBUG log level. Self-hosted \u00b6 The easiest way to gather logs from Renovate for any platform is to use the default logging to stdout /console. By default, Renovate will log in a human-readable format at INFO level. For troubleshooting it's recommended to increase logging to DEBUG level by adding LOG_LEVEL=debug to your environment variables before invoking Renovate. If your Renovate logs are being processed by a log service before you access them, you may find it better to have Renovate output logs in JSON format instead so that they can be reliably parsed and filtered. This can be achieved by adding LOG_FORMAT=json to your environment variables before invoking Renovate. Log debug levels \u00b6 There are different severity levels for the log output. From least severe to most severe: DEBUG INFO WARN ERROR FATAL To check for problems, look for WARN or ERROR logs (level 40 or 50 if in JSON format). To troubleshoot further, you usually need to look at DEBUG logs. Resolving problems using logs \u00b6 We recommend you follow this process: Try to narrow in on the problem area e.g. by looking for relevant branches or WARN or ERROR messages Find all relevant DEBUG or INFO messages from before and after the problem occurred Copy/paste the relevant parts of the logs into your discussion post or bug report If you cannot fix the problem yourself after reading the logs, and reading - or searching through - our documentation, search the renovatebot/renovate discussion forum to see if somebody has asked a similar or related question. If none of these steps have helped you, then create a new discussion post to get help from the Renovate maintainers. Please locate the relevant parts of the logs as described earlier before asking for help or posting a bug report. Do not expect the Renovate maintainers to read through the full logs when trying to help you, as that takes a lot of time on our part. If later it turns out that the full logs are necessary, you will be asked for them then.","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting-renovate","text":"Learn how to troubleshoot problems with Renovate, where to find the logging output, and how to get help if needed.","title":"Troubleshooting Renovate"},{"location":"troubleshooting/#getting-the-logs","text":"Renovate's debug-level logs are usually enough to help troubleshoot most problems. Where you can find the logs depends on how you're running Renovate.","title":"Getting the logs"},{"location":"troubleshooting/#github-hosted-app","text":"Each pull request from Renovate has a link to the Mend Renovate Dashboard in the PR body text. The text you're looking for is: This PR has been generated by Mend Renovate. View repository job log here. Click on the blue text \"here\" to go to the Mend Renovate App Dashboard. Sign in with your GitHub or GitLab account. Once you're logged in, you can see the logs for the Renovate jobs on your repository. You should have access to any repository which you have write access to and which has Renovate installed. Renovate only makes logs for the last 3 days available. When you've clicked on a recent job, you'll be able to select a debug level that you care about. For a full overview, make sure you select the DEBUG log level.","title":"GitHub Hosted app"},{"location":"troubleshooting/#self-hosted","text":"The easiest way to gather logs from Renovate for any platform is to use the default logging to stdout /console. By default, Renovate will log in a human-readable format at INFO level. For troubleshooting it's recommended to increase logging to DEBUG level by adding LOG_LEVEL=debug to your environment variables before invoking Renovate. If your Renovate logs are being processed by a log service before you access them, you may find it better to have Renovate output logs in JSON format instead so that they can be reliably parsed and filtered. This can be achieved by adding LOG_FORMAT=json to your environment variables before invoking Renovate.","title":"Self-hosted"},{"location":"troubleshooting/#log-debug-levels","text":"There are different severity levels for the log output. From least severe to most severe: DEBUG INFO WARN ERROR FATAL To check for problems, look for WARN or ERROR logs (level 40 or 50 if in JSON format). To troubleshoot further, you usually need to look at DEBUG logs.","title":"Log debug levels"},{"location":"troubleshooting/#resolving-problems-using-logs","text":"We recommend you follow this process: Try to narrow in on the problem area e.g. by looking for relevant branches or WARN or ERROR messages Find all relevant DEBUG or INFO messages from before and after the problem occurred Copy/paste the relevant parts of the logs into your discussion post or bug report If you cannot fix the problem yourself after reading the logs, and reading - or searching through - our documentation, search the renovatebot/renovate discussion forum to see if somebody has asked a similar or related question. If none of these steps have helped you, then create a new discussion post to get help from the Renovate maintainers. Please locate the relevant parts of the logs as described earlier before asking for help or posting a bug report. Do not expect the Renovate maintainers to read through the full logs when trying to help you, as that takes a lot of time on our part. If later it turns out that the full logs are necessary, you will be asked for them then.","title":"Resolving problems using logs"},{"location":"updating-rebasing/","text":"Updating and rebasing branches \u00b6 There are many situations in which Renovate must update/rebase a branch. Here is a list of the most common cases where Renovate must update/rebase the branch: When a pull request has conflicts due to changes on the base branch When you have enabled \"Require branches to be up to date before merging\" on GitHub When you have manually told Renovate to rebase when behind the base branch with \"rebaseWhen\": \"behind-base-branch\" When a newer version of the dependency is released When you request a manual rebase from the Renovate bot When you use \"automerge\": true and \"rebaseWhen\": \"auto\" on a branch / pr Renovate uses its own version of \"rebasing\", which is not the same as doing a git rebase with Git. Instead, Renovate reapplies all updates into a new commit based off of the head of the base branch. No rebasing if you have made edits \u00b6 First of all, here is the one time when Renovate won't update branches. If you edit a Renovate branch directly (e.g. to make a code fix to allow tests to pass again) then Renovate stops all updates of that branch. It is up to you to either finish the job and merge the PR, or rename it and close it so that Renovate can take back over again. Rebasing conflicted PRs \u00b6 If new commits to the base branch - such as merging another Renovate PR - result in an open Renovate PR having merge conflicts, then Renovate will recreate (\"rebase\") any conflicted PRs. This applies both to commits to dependency files such as package.json as well as lock files such as yarn.lock . You should not ever need to resolve such conflicts manually. You can disable this functionality by configuring \"rebaseWhen\": \"never\" (not recommended). Rebasing out-of-date branches \u00b6 There are multiple cases where Renovate will rebase its branches off the base branch every time they are out of date: If you configure \"rebaseWhen\": \"behind-base-branch\" If you use the default configuration \"rebaseWhen\": \"auto\" and the repository has a requirement that branches must be up-to-date before merging (e.g. \"Require branches to be up to date before merging\" on GitHub, or fast-forward-only settings on Bitbucket Server or GitLab) If you use the default configuration \"rebaseWhen\" : \"auto\" and configure \"automerge\" : true In that case Renovate PRs will be rebased off the repository's base branch whenever they are behind the base branch, even if the PRs are not conflicted. Newer dependency versions \u00b6 If an existing PR is open to upgrade dependency \"foo\" to v1.1.0 and then v1.1.1 is released, then Renovate will regenerate the branch again. This way: Each Renovate branch will always have 1 and only 1 commit The newest version will be based off the latest base branch commit at the time Manual rebasing \u00b6 You can request that Renovate rebase a PR by ticking the rebase/retry checkbox on GitHub or GitLab. Or you can add a \"rebase\" label to the PR. The label name is configurable via the rebaseLabel option. If you apply a rebase label then Renovate will regenerate its commit for the branch, even if the branch has been modified. The rebase label is useful in situations like: If a branch is stale but you don't have rebaseWhen=behind-base-branch enabled If a branch has been edited and you want to discard the edits and have Renovate create it again If a branch was created with an error (e.g. lockfile generation) and you want Renovate to try again","title":"Updating and Rebasing Branches"},{"location":"updating-rebasing/#updating-and-rebasing-branches","text":"There are many situations in which Renovate must update/rebase a branch. Here is a list of the most common cases where Renovate must update/rebase the branch: When a pull request has conflicts due to changes on the base branch When you have enabled \"Require branches to be up to date before merging\" on GitHub When you have manually told Renovate to rebase when behind the base branch with \"rebaseWhen\": \"behind-base-branch\" When a newer version of the dependency is released When you request a manual rebase from the Renovate bot When you use \"automerge\": true and \"rebaseWhen\": \"auto\" on a branch / pr Renovate uses its own version of \"rebasing\", which is not the same as doing a git rebase with Git. Instead, Renovate reapplies all updates into a new commit based off of the head of the base branch.","title":"Updating and rebasing branches"},{"location":"updating-rebasing/#no-rebasing-if-you-have-made-edits","text":"First of all, here is the one time when Renovate won't update branches. If you edit a Renovate branch directly (e.g. to make a code fix to allow tests to pass again) then Renovate stops all updates of that branch. It is up to you to either finish the job and merge the PR, or rename it and close it so that Renovate can take back over again.","title":"No rebasing if you have made edits"},{"location":"updating-rebasing/#rebasing-conflicted-prs","text":"If new commits to the base branch - such as merging another Renovate PR - result in an open Renovate PR having merge conflicts, then Renovate will recreate (\"rebase\") any conflicted PRs. This applies both to commits to dependency files such as package.json as well as lock files such as yarn.lock . You should not ever need to resolve such conflicts manually. You can disable this functionality by configuring \"rebaseWhen\": \"never\" (not recommended).","title":"Rebasing conflicted PRs"},{"location":"updating-rebasing/#rebasing-out-of-date-branches","text":"There are multiple cases where Renovate will rebase its branches off the base branch every time they are out of date: If you configure \"rebaseWhen\": \"behind-base-branch\" If you use the default configuration \"rebaseWhen\": \"auto\" and the repository has a requirement that branches must be up-to-date before merging (e.g. \"Require branches to be up to date before merging\" on GitHub, or fast-forward-only settings on Bitbucket Server or GitLab) If you use the default configuration \"rebaseWhen\" : \"auto\" and configure \"automerge\" : true In that case Renovate PRs will be rebased off the repository's base branch whenever they are behind the base branch, even if the PRs are not conflicted.","title":"Rebasing out-of-date branches"},{"location":"updating-rebasing/#newer-dependency-versions","text":"If an existing PR is open to upgrade dependency \"foo\" to v1.1.0 and then v1.1.1 is released, then Renovate will regenerate the branch again. This way: Each Renovate branch will always have 1 and only 1 commit The newest version will be based off the latest base branch commit at the time","title":"Newer dependency versions"},{"location":"updating-rebasing/#manual-rebasing","text":"You can request that Renovate rebase a PR by ticking the rebase/retry checkbox on GitHub or GitLab. Or you can add a \"rebase\" label to the PR. The label name is configurable via the rebaseLabel option. If you apply a rebase label then Renovate will regenerate its commit for the branch, even if the branch has been modified. The rebase label is useful in situations like: If a branch is stale but you don't have rebaseWhen=behind-base-branch enabled If a branch has been edited and you want to discard the edits and have Renovate create it again If a branch was created with an error (e.g. lockfile generation) and you want Renovate to try again","title":"Manual rebasing"},{"location":"examples/self-hosting/","text":"Self-Hosting Examples \u00b6 Installing Renovate OSS CLI \u00b6 npmjs \u00b6 npm install -g renovate Renovate does not embed npm , pnpm and yarn as its own dependencies. If you want to use these package managers to update your lockfiles, you must ensure that the correct versions are already installed globally. npm install -g yarn pnpm The same goes for any other third-party binary tool like gradle or poetry - you need to make sure it is installed and the correct version before running Renovate. Docker \u00b6 Renovate is available for Docker via an automated build renovate/renovate . It builds latest based on the main branch and all semver tags are published too. For example, all the following are valid tags: docker run --rm renovate/renovate docker run --rm renovate/renovate:32 docker run --rm renovate/renovate:32.64 docker run --rm renovate/renovate:32.64.4 Warning Do not use the example tags listed above, as they will be out-of-date. Go to renovate/renovate tags to grab the latest tagged release from Renovate. If you want to configure Renovate using a config.js file then map it to /usr/src/app/config.js using Docker volumes. For example: docker run --rm -v \"/path/to/your/config.js:/usr/src/app/config.js\" renovate/renovate Kubernetes \u00b6 Renovate's official Docker image is compatible with Kubernetes. The following is an example manifest of running Renovate against a GitHub Enterprise server. First the Kubernetes manifest: apiVersion : batch/v1 kind : CronJob metadata : name : renovate spec : schedule : '@hourly' concurrencyPolicy : Forbid jobTemplate : spec : template : spec : containers : - name : renovate # Update this to the latest available and then enable Renovate on # the manifest image : renovate/renovate:31.14.0 args : - user/repo # Environment Variables env : - name : LOG_LEVEL value : debug envFrom : - secretRef : name : renovate-env restartPolicy : Never And also this accompanying secret.yaml : apiVersion : v1 kind : Secret metadata : name : renovate-env type : Opaque stringData : GITHUB_COM_TOKEN : 'any-personal-user-token-for-github-com-for-fetching-changelogs' # You can set RENOVATE_AUTODISCOVER to true to run Renovate on all repos you have push access to RENOVATE_AUTODISCOVER : 'false' RENOVATE_ENDPOINT : 'https://github.company.com/api/v3' RENOVATE_GIT_AUTHOR : 'Renovate Bot <bot@renovateapp.com>' RENOVATE_PLATFORM : 'github' RENOVATE_TOKEN : 'your-github-enterprise-renovate-user-token' A config.js file can be added to the manifest using a ConfigMap as shown in the following example (using a \"dry run\" in github.com): --- apiVersion : v1 kind : ConfigMap metadata : name : renovate-config data : config.json : |- { \"repositories\": [\"orgname/repo\",\"username/repo\"], \"dryRun\" : \"true\" } --- apiVersion : batch/v1 kind : CronJob metadata : name : renovate-bot spec : schedule : '@hourly' concurrencyPolicy : Forbid jobTemplate : spec : template : spec : containers : - image : renovate/renovate:31.14.0 name : renovate-bot env : # For illustration purposes, please use secrets. - name : RENOVATE_PLATFORM value : 'github' - name : RENOVATE_TOKEN value : 'some-token' - name : RENOVATE_AUTODISCOVER value : 'false' - name : RENOVATE_BASE_DIR value : '/tmp/renovate/' - name : RENOVATE_CONFIG_FILE value : '/opt/renovate/config.json' - name : LOG_LEVEL value : debug volumeMounts : - name : config-volume mountPath : /opt/renovate/ - name : work-volume mountPath : /tmp/renovate/ restartPolicy : Never volumes : - name : config-volume configMap : name : renovate-config - name : work-volume emptyDir : {} CircleCI \u00b6 If you are using CircleCI, you can use the third-party daniel-shuy/renovate orb to run a self-hosted instance of Renovate on CircleCI. By default, the orb looks for the self-hosted configuration file in the project root, but you can specify another path to the configuration file with the config_file_path parameter. Secrets should be configured using environment variables (e.g. RENOVATE_TOKEN , GITHUB_COM_TOKEN ). Configure environment variables in CircleCI Project Settings . To share environment variables across projects, use CircleCI Contexts . The following example runs Renovate hourly, and looks for the self-hosted configuration file at renovate-config.js : version: '2.1' orbs: renovate: daniel-shuy/renovate@2.2.0 workflows: renovate: jobs: - renovate/self-hosted: config_file_path: renovate-config.js nightly: triggers: - schedule: cron: 0 * * * * filters: branches: only: - main Renovate config file validation when using CircleCI \u00b6 How to validate your config as part of your workflow: version: '2.1' orbs: renovate: daniel-shuy/renovate@2.2.0 workflows: lint: jobs: - renovate/validate-config GitLab CI/CD pipeline \u00b6 For GitLab pipelines we recommend you use the renovate-runner project on GitLab . We've prepared some pipeline templates to run Renovate on pipeline schedules in an easy way. You can also find the configuration steps there. For self-hosted GitLab clone/import the renovate-runner project to your instance. File/directory usage \u00b6 By default, Renovate stores all files in the renovate/ subdirectory of the operating system's temporary directory, e.g. /tmp/renovate/ . Repository data is copied or cloned into unique subdirectories under repos/ , e.g. /tmp/renovate/repos/github/owner1/repo-a/ . Renovate's own cache, as well as the caches(s) for npm, Yarn, Composer etc, are stored in /tmp/renovate/cache . To use another directory as the base directory, instead of the default tmp/renovate you can: Set a value for baseDir in config.js Use an environment variable RENOVATE_BASE_DIR Use the CLI to pass a base directory: --base-dir= If you want to override the cache location then set a value for cacheDir instead. Usage \u00b6 The following example uses the Renovate CLI tool, which can be installed by running npm i -g renovate . If running your own Renovate bot then you will need a user account that Renovate will run as. It's recommended to use a dedicated account for the bot, e.g. name it renovate-bot if on your own instance. Create and save a Personal Access Token for this account. Create a Renovate config file, e.g. here is an example: module . exports = { endpoint : 'https://self-hosted.gitlab/api/v4/' , token : '**gitlab_token**' , platform : 'gitlab' , onboardingConfig : { extends : [ 'config:base' ], }, repositories : [ 'username/repo' , 'orgname/repo' ], }; Here change the logFile and repositories to something appropriate. Also replace gitlab-token value with the one created during the previous step. If running against GitHub Enterprise Server, change the above gitlab values to the equivalent GitHub ones. You can save this file as anything you want and then use the RENOVATE_CONFIG_FILE environment variable to tell Renovate where to find it. Most people will run Renovate via cron, e.g. once per hour. Here is an example Bash script that you can point cron to: #!/bin/bash export PATH = \"/home/user/.yarn/bin:/usr/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin: $PATH \" export RENOVATE_CONFIG_FILE = \"/home/user/renovate-config.js\" export RENOVATE_TOKEN = \"**some-token**\" # GitHub, GitLab, Azure DevOps export GITHUB_COM_TOKEN = \"**github-token**\" # Delete this if using github.com # Renovate renovate Note The GitHub.com token as an environment variable is needed to fetch Release Notes that are usually hosted on github.com. You don't need to add it if you are already running the bot against github.com, but you do need to add it if you're using GitHub Enterprise Server, GitLab, Azure DevOps, or Bitbucket. You should save and test out this script manually first, and add it to cron once you've verified it. Kubernetes for GitLab, using Git over SSH \u00b6 This section describes how to use Git binary with SSH for GitLab, to avoid API shortcomings. You need to first create a SSH key, then add the public part to GitLab (see this guide ). Then, you need to create the secret to add the SSH key, and the following config to your container: host gitlab.com HostName gitlab.com StrictHostKeyChecking no IdentityFile ~/.ssh/id_rsa User git To easily create the secret, you can do the following (see docs ). kubectl create secret generic ssh-key-secret --from-file = config = /path/to/config --from-file = id_rsa = /path/to/.ssh/id_rsa --from-file = id_rsa.pub = /path/to/.ssh/id_rsa.pub It creates something like this: apiVersion: v1 data: config: aG9zdCBnaXRsYWIuY29tCiAgSG9zdE5hbWUgZ2l0bGFiLmNvbQogIFN0cmljdEhvc3RLZXlDaGVja2luZyBubwogIElkZW50aXR5RmlsZSB+Ly5zc2gvaWRfcnNhCiAgVXNlciBnaXQ= id_rsa: <base64String> id_rsa.pub: <base64String> kind: Secret metadata: name: ssh-key-secret namespace: <namespace> Then you just need to add Git author, and mount volumes. The final configuration should look something like this: --- apiVersion: v1 kind: Namespace metadata: name: <namespace, for example renovate> --- apiVersion: v1 kind: Secret metadata: name: renovate-env namespace: <namespace> type: Opaque stringData: GITHUB_COM_TOKEN: 'any-personal-user-token-for-github-com-for-fetching-changelogs' RENOVATE_AUTODISCOVER: 'false' RENOVATE_ENDPOINT: 'https://github.company.com/api/v3' RENOVATE_GIT_AUTHOR: 'Renovate Bot <bot@renovateapp.com>' RENOVATE_PLATFORM: 'github' RENOVATE_TOKEN: 'your-github-enterprise-renovate-user-token' --- apiVersion: v1 data: config: aG9zdCBnaXRsYWIuY29tCiAgSG9zdE5hbWUgZ2l0bGFiLmNvbQogIFN0cmljdEhvc3RLZXlDaGVja2luZyBubwogIElkZW50aXR5RmlsZSB+Ly5zc2gvaWRfcnNhCiAgVXNlciBnaXQ= id_rsa: <base64String> id_rsa.pub: <base64String> kind: Secret metadata: name: ssh-key-secret namespace: <namespace> --- apiVersion: batch/v1beta1 kind: CronJob metadata: name: renovate namespace: <namespace> spec: schedule: '@hourly' concurrencyPolicy: Forbid jobTemplate: spec: template: spec: volumes: - name: ssh-key-volume secret: secretName: ssh-key-secret containers: - name: renovate # Update this to the latest available and then enable Renovate on the manifest image: renovate/renovate:31.14.0 volumeMounts: - name: ssh-key-volume readOnly: true mountPath: '/home/ubuntu/.ssh' args: - <repository> # Environment Variables envFrom: - secretRef: name: renovate-env restartPolicy: Never Logging \u00b6 It's recommended to configure LOG_LEVEL=debug and LOG_FORMAT=json in environment if you are ingesting/parsing logs into another system. Debug logging is usually necessary for any debugging, while JSON format will mean that the output is parseable. About the log level numbers \u00b6 When you use LOG_LEVEL=debug and LOG_FORMAT=json , Renovate uses numbers in the level field. The logging level output is controlled by the Bunyan logging library. Level Meaning 10 trace 20 debug 30 info 40 warn 50 error 60 fatal Self-signed TLS/SSL certificates \u00b6 Renovate and invoked helper programs (e.g. Git, npm) use a secure TLS connection (e.g. HTTPS) to connect to remote source code and dependency hosts. If the remote hosts use any self-signed certificates or certificate authorities then Renovate needs to be configured to trust these additional certificates. For the main Renovate Node.js application set the environment variable NODE_EXTRA_CA_CERTS=/usr/local/share/ca-certificates/self-signed-certificate.crt . This ensures that the Renovate application itself trusts the self-signed-certificate.crt and can establish secure connections to systems using that certificate or certificates signed by this certificate authority. The helper programs (e.g. Git, npm) use the system trust store. For them to trust a self-signed certificate you must add it to the systems trust store. On Ubuntu/Debian and many Linux-based systems, this can be done by copying the self-signed certificate (e.g. self-signed-certificate.crt ) to /usr/local/share/ca-certificates/ and running update-ca-certificates to update the system trust store afterwards. If you're using the official Renovate Docker image then we recommend you add the self-signed certificate and build your own modified Docker image. For example, the following Dockerfile is set up to use a self-signed certificate: FROM renovate/renovate # Changes to the certificate authority require root permissions USER root # Copy and install the self signed certificate COPY self-signed-certificate.crt /usr/local/share/ca-certificates/ RUN update-ca-certificates # Change back to the Ubuntu user USER 1000 # Node comes with an own certificate authority store and thus needs to trust the self-signed certificate explicitly ENV NODE_EXTRA_CA_CERTS = /usr/local/share/ca-certificates/self-signed-certificate.crt","title":"Self-Hosting Examples"},{"location":"examples/self-hosting/#self-hosting-examples","text":"","title":"Self-Hosting Examples"},{"location":"examples/self-hosting/#installing-renovate-oss-cli","text":"","title":"Installing Renovate OSS CLI"},{"location":"examples/self-hosting/#npmjs","text":"npm install -g renovate Renovate does not embed npm , pnpm and yarn as its own dependencies. If you want to use these package managers to update your lockfiles, you must ensure that the correct versions are already installed globally. npm install -g yarn pnpm The same goes for any other third-party binary tool like gradle or poetry - you need to make sure it is installed and the correct version before running Renovate.","title":"npmjs"},{"location":"examples/self-hosting/#docker","text":"Renovate is available for Docker via an automated build renovate/renovate . It builds latest based on the main branch and all semver tags are published too. For example, all the following are valid tags: docker run --rm renovate/renovate docker run --rm renovate/renovate:32 docker run --rm renovate/renovate:32.64 docker run --rm renovate/renovate:32.64.4 Warning Do not use the example tags listed above, as they will be out-of-date. Go to renovate/renovate tags to grab the latest tagged release from Renovate. If you want to configure Renovate using a config.js file then map it to /usr/src/app/config.js using Docker volumes. For example: docker run --rm -v \"/path/to/your/config.js:/usr/src/app/config.js\" renovate/renovate","title":"Docker"},{"location":"examples/self-hosting/#kubernetes","text":"Renovate's official Docker image is compatible with Kubernetes. The following is an example manifest of running Renovate against a GitHub Enterprise server. First the Kubernetes manifest: apiVersion : batch/v1 kind : CronJob metadata : name : renovate spec : schedule : '@hourly' concurrencyPolicy : Forbid jobTemplate : spec : template : spec : containers : - name : renovate # Update this to the latest available and then enable Renovate on # the manifest image : renovate/renovate:31.14.0 args : - user/repo # Environment Variables env : - name : LOG_LEVEL value : debug envFrom : - secretRef : name : renovate-env restartPolicy : Never And also this accompanying secret.yaml : apiVersion : v1 kind : Secret metadata : name : renovate-env type : Opaque stringData : GITHUB_COM_TOKEN : 'any-personal-user-token-for-github-com-for-fetching-changelogs' # You can set RENOVATE_AUTODISCOVER to true to run Renovate on all repos you have push access to RENOVATE_AUTODISCOVER : 'false' RENOVATE_ENDPOINT : 'https://github.company.com/api/v3' RENOVATE_GIT_AUTHOR : 'Renovate Bot <bot@renovateapp.com>' RENOVATE_PLATFORM : 'github' RENOVATE_TOKEN : 'your-github-enterprise-renovate-user-token' A config.js file can be added to the manifest using a ConfigMap as shown in the following example (using a \"dry run\" in github.com): --- apiVersion : v1 kind : ConfigMap metadata : name : renovate-config data : config.json : |- { \"repositories\": [\"orgname/repo\",\"username/repo\"], \"dryRun\" : \"true\" } --- apiVersion : batch/v1 kind : CronJob metadata : name : renovate-bot spec : schedule : '@hourly' concurrencyPolicy : Forbid jobTemplate : spec : template : spec : containers : - image : renovate/renovate:31.14.0 name : renovate-bot env : # For illustration purposes, please use secrets. - name : RENOVATE_PLATFORM value : 'github' - name : RENOVATE_TOKEN value : 'some-token' - name : RENOVATE_AUTODISCOVER value : 'false' - name : RENOVATE_BASE_DIR value : '/tmp/renovate/' - name : RENOVATE_CONFIG_FILE value : '/opt/renovate/config.json' - name : LOG_LEVEL value : debug volumeMounts : - name : config-volume mountPath : /opt/renovate/ - name : work-volume mountPath : /tmp/renovate/ restartPolicy : Never volumes : - name : config-volume configMap : name : renovate-config - name : work-volume emptyDir : {}","title":"Kubernetes"},{"location":"examples/self-hosting/#circleci","text":"If you are using CircleCI, you can use the third-party daniel-shuy/renovate orb to run a self-hosted instance of Renovate on CircleCI. By default, the orb looks for the self-hosted configuration file in the project root, but you can specify another path to the configuration file with the config_file_path parameter. Secrets should be configured using environment variables (e.g. RENOVATE_TOKEN , GITHUB_COM_TOKEN ). Configure environment variables in CircleCI Project Settings . To share environment variables across projects, use CircleCI Contexts . The following example runs Renovate hourly, and looks for the self-hosted configuration file at renovate-config.js : version: '2.1' orbs: renovate: daniel-shuy/renovate@2.2.0 workflows: renovate: jobs: - renovate/self-hosted: config_file_path: renovate-config.js nightly: triggers: - schedule: cron: 0 * * * * filters: branches: only: - main","title":"CircleCI"},{"location":"examples/self-hosting/#renovate-config-file-validation-when-using-circleci","text":"How to validate your config as part of your workflow: version: '2.1' orbs: renovate: daniel-shuy/renovate@2.2.0 workflows: lint: jobs: - renovate/validate-config","title":"Renovate config file validation when using CircleCI"},{"location":"examples/self-hosting/#gitlab-cicd-pipeline","text":"For GitLab pipelines we recommend you use the renovate-runner project on GitLab . We've prepared some pipeline templates to run Renovate on pipeline schedules in an easy way. You can also find the configuration steps there. For self-hosted GitLab clone/import the renovate-runner project to your instance.","title":"GitLab CI/CD pipeline"},{"location":"examples/self-hosting/#filedirectory-usage","text":"By default, Renovate stores all files in the renovate/ subdirectory of the operating system's temporary directory, e.g. /tmp/renovate/ . Repository data is copied or cloned into unique subdirectories under repos/ , e.g. /tmp/renovate/repos/github/owner1/repo-a/ . Renovate's own cache, as well as the caches(s) for npm, Yarn, Composer etc, are stored in /tmp/renovate/cache . To use another directory as the base directory, instead of the default tmp/renovate you can: Set a value for baseDir in config.js Use an environment variable RENOVATE_BASE_DIR Use the CLI to pass a base directory: --base-dir= If you want to override the cache location then set a value for cacheDir instead.","title":"File/directory usage"},{"location":"examples/self-hosting/#usage","text":"The following example uses the Renovate CLI tool, which can be installed by running npm i -g renovate . If running your own Renovate bot then you will need a user account that Renovate will run as. It's recommended to use a dedicated account for the bot, e.g. name it renovate-bot if on your own instance. Create and save a Personal Access Token for this account. Create a Renovate config file, e.g. here is an example: module . exports = { endpoint : 'https://self-hosted.gitlab/api/v4/' , token : '**gitlab_token**' , platform : 'gitlab' , onboardingConfig : { extends : [ 'config:base' ], }, repositories : [ 'username/repo' , 'orgname/repo' ], }; Here change the logFile and repositories to something appropriate. Also replace gitlab-token value with the one created during the previous step. If running against GitHub Enterprise Server, change the above gitlab values to the equivalent GitHub ones. You can save this file as anything you want and then use the RENOVATE_CONFIG_FILE environment variable to tell Renovate where to find it. Most people will run Renovate via cron, e.g. once per hour. Here is an example Bash script that you can point cron to: #!/bin/bash export PATH = \"/home/user/.yarn/bin:/usr/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin: $PATH \" export RENOVATE_CONFIG_FILE = \"/home/user/renovate-config.js\" export RENOVATE_TOKEN = \"**some-token**\" # GitHub, GitLab, Azure DevOps export GITHUB_COM_TOKEN = \"**github-token**\" # Delete this if using github.com # Renovate renovate Note The GitHub.com token as an environment variable is needed to fetch Release Notes that are usually hosted on github.com. You don't need to add it if you are already running the bot against github.com, but you do need to add it if you're using GitHub Enterprise Server, GitLab, Azure DevOps, or Bitbucket. You should save and test out this script manually first, and add it to cron once you've verified it.","title":"Usage"},{"location":"examples/self-hosting/#kubernetes-for-gitlab-using-git-over-ssh","text":"This section describes how to use Git binary with SSH for GitLab, to avoid API shortcomings. You need to first create a SSH key, then add the public part to GitLab (see this guide ). Then, you need to create the secret to add the SSH key, and the following config to your container: host gitlab.com HostName gitlab.com StrictHostKeyChecking no IdentityFile ~/.ssh/id_rsa User git To easily create the secret, you can do the following (see docs ). kubectl create secret generic ssh-key-secret --from-file = config = /path/to/config --from-file = id_rsa = /path/to/.ssh/id_rsa --from-file = id_rsa.pub = /path/to/.ssh/id_rsa.pub It creates something like this: apiVersion: v1 data: config: aG9zdCBnaXRsYWIuY29tCiAgSG9zdE5hbWUgZ2l0bGFiLmNvbQogIFN0cmljdEhvc3RLZXlDaGVja2luZyBubwogIElkZW50aXR5RmlsZSB+Ly5zc2gvaWRfcnNhCiAgVXNlciBnaXQ= id_rsa: <base64String> id_rsa.pub: <base64String> kind: Secret metadata: name: ssh-key-secret namespace: <namespace> Then you just need to add Git author, and mount volumes. The final configuration should look something like this: --- apiVersion: v1 kind: Namespace metadata: name: <namespace, for example renovate> --- apiVersion: v1 kind: Secret metadata: name: renovate-env namespace: <namespace> type: Opaque stringData: GITHUB_COM_TOKEN: 'any-personal-user-token-for-github-com-for-fetching-changelogs' RENOVATE_AUTODISCOVER: 'false' RENOVATE_ENDPOINT: 'https://github.company.com/api/v3' RENOVATE_GIT_AUTHOR: 'Renovate Bot <bot@renovateapp.com>' RENOVATE_PLATFORM: 'github' RENOVATE_TOKEN: 'your-github-enterprise-renovate-user-token' --- apiVersion: v1 data: config: aG9zdCBnaXRsYWIuY29tCiAgSG9zdE5hbWUgZ2l0bGFiLmNvbQogIFN0cmljdEhvc3RLZXlDaGVja2luZyBubwogIElkZW50aXR5RmlsZSB+Ly5zc2gvaWRfcnNhCiAgVXNlciBnaXQ= id_rsa: <base64String> id_rsa.pub: <base64String> kind: Secret metadata: name: ssh-key-secret namespace: <namespace> --- apiVersion: batch/v1beta1 kind: CronJob metadata: name: renovate namespace: <namespace> spec: schedule: '@hourly' concurrencyPolicy: Forbid jobTemplate: spec: template: spec: volumes: - name: ssh-key-volume secret: secretName: ssh-key-secret containers: - name: renovate # Update this to the latest available and then enable Renovate on the manifest image: renovate/renovate:31.14.0 volumeMounts: - name: ssh-key-volume readOnly: true mountPath: '/home/ubuntu/.ssh' args: - <repository> # Environment Variables envFrom: - secretRef: name: renovate-env restartPolicy: Never","title":"Kubernetes for GitLab, using Git over SSH"},{"location":"examples/self-hosting/#logging","text":"It's recommended to configure LOG_LEVEL=debug and LOG_FORMAT=json in environment if you are ingesting/parsing logs into another system. Debug logging is usually necessary for any debugging, while JSON format will mean that the output is parseable.","title":"Logging"},{"location":"examples/self-hosting/#about-the-log-level-numbers","text":"When you use LOG_LEVEL=debug and LOG_FORMAT=json , Renovate uses numbers in the level field. The logging level output is controlled by the Bunyan logging library. Level Meaning 10 trace 20 debug 30 info 40 warn 50 error 60 fatal","title":"About the log level numbers"},{"location":"examples/self-hosting/#self-signed-tlsssl-certificates","text":"Renovate and invoked helper programs (e.g. Git, npm) use a secure TLS connection (e.g. HTTPS) to connect to remote source code and dependency hosts. If the remote hosts use any self-signed certificates or certificate authorities then Renovate needs to be configured to trust these additional certificates. For the main Renovate Node.js application set the environment variable NODE_EXTRA_CA_CERTS=/usr/local/share/ca-certificates/self-signed-certificate.crt . This ensures that the Renovate application itself trusts the self-signed-certificate.crt and can establish secure connections to systems using that certificate or certificates signed by this certificate authority. The helper programs (e.g. Git, npm) use the system trust store. For them to trust a self-signed certificate you must add it to the systems trust store. On Ubuntu/Debian and many Linux-based systems, this can be done by copying the self-signed certificate (e.g. self-signed-certificate.crt ) to /usr/local/share/ca-certificates/ and running update-ca-certificates to update the system trust store afterwards. If you're using the official Renovate Docker image then we recommend you add the self-signed certificate and build your own modified Docker image. For example, the following Dockerfile is set up to use a self-signed certificate: FROM renovate/renovate # Changes to the certificate authority require root permissions USER root # Copy and install the self signed certificate COPY self-signed-certificate.crt /usr/local/share/ca-certificates/ RUN update-ca-certificates # Change back to the Ubuntu user USER 1000 # Node comes with an own certificate authority store and thus needs to trust the self-signed certificate explicitly ENV NODE_EXTRA_CA_CERTS = /usr/local/share/ca-certificates/self-signed-certificate.crt","title":"Self-signed TLS/SSL certificates"},{"location":"getting-started/installing-onboarding/","text":"Installing and onboarding Renovate into repositories \u00b6 Repository installation \u00b6 Renovate administrators can configure Renovate to either \"autodiscover\" installed repositories, or configure a fixed list of repository names to operate on. If the administrator has configured a fixed list of repositories then the only way to \"install\" Renovate on an additional repository is for it to be manually added for the next run or restart. Otherwise, the process for adding new repositories to a Renovate installation can vary: Most commonly, you run Renovate as a dedicated \"bot user\" with global config option autodiscover set to true , meaning that it will run on every repository which it's been granted access to If using a GitHub App (including Mend Renovate on github.com ) then you can install the app into a user or organization account and select either \"All repositories\", or \"Select repositories\" and pick them manually Hosted GitHub.com App \u00b6 Installing/enabling Mend's Renovate GitHub App is simple. First, navigate to https://github.com/apps/renovate and click the Install button: The only choice you need to make is whether to run Renovate on all repositories or on selected repositories: Renovate will ignore any repositories that don't have known package files, as well as any forks, so you can enable Renovate for all your repositories with no problems. That said, most people run Renovate on selected repositories. Unfortunately GitHub doesn't offer a \"select all except X, Y, Z\" option, so you must select each repository where you want Renovate to run. Once you're done selecting repositories for Renovate to run on, click the green Install button at the bottom of the page and Renovate will be enabled for those repositories and start the onboarding process. Note If you are using the Mend Renovate App then it has a custom behavior for forked repositories. If you choose \"All repositories\" when installing then forked repositories will be skipped by default, while if you choose \"Select repositories\" then they will be processed by Renovate even if they're a fork. Hosted GitLab.com App \u00b6 Unfortunately Mend's hosted GitLab app needed to be taken offline indefinitely until a viable security model for bots on GitLab.com is available. For more details on GitLab security for bots, please see the GitLab Bot Security doc. Repository onboarding \u00b6 Once you have enabled Renovate on a repository, you will get a \"Configure Renovate\" Pull Request looking something like this: No risk onboarding \u00b6 Conveniently, Renovate will not make any changes to your repository or raise any further Pull Requests until after you merge the onboarding Pull Request. If there is anything about the Pull Request that you don't like or understand, take your time to read the documentation or ask questions on the discussions forum on GitHub and merge the PR only once you're satisfied with the result. You can edit your Renovate configuration within the renovate/configure branch and Renovate will keep updating the description in the PR to match, so you can work on the config until you're satisfied with the results. Check for warnings \u00b6 If you have any Warnings or Errors listed, see if you need or want to make any changes to fix them. Warnings and errors should be fixed on the base branch (e.g. main ) so that Renovate can recreate its Configure Renovate PR on its next cycle. Configuration location \u00b6 The \"Configure Renovate\" PR will include a renovate.json file in the root directory, with suggested default settings. If you don't want a renovate.json file in your repository you can use one of the following files instead: renovate.json5 .github/renovate.json .github/renovate.json5 .gitlab/renovate.json .gitlab/renovate.json5 .renovaterc .renovaterc.json package.json (deprecated) package.json \u00b6 Warning This approach has been deprecated and will be removed in a future release. You can add the same settings to a \"renovate\" section in your package.json file instead. The package.json file must be located at the root of your repository. This is handy if you are already using a package.json file anyway, e.g. when you're working on a JavaScript project. The configuration in your package.json will apply to the whole project (this includes other, nested package.json files). Customised defaults \u00b6 Renovate provides a renovate.json file, with default settings that will work for most cases. Sometimes Renovate detects that an override to these defaults is needed, and will add this override automatically, such as: Automatically enabling Angular-style semantic commits if your repository uses them Determining whether to use dependency range pinning depending on the detected project type (app vs library) Common overrides \u00b6 Please check the docs on this website for an exhaustive Configuration Reference. To help you get started, here are some of the most commonly changed (overridden) configuration settings: rangeStrategy : By default (with zero config) it's \"replace\" but the \"config:base\" preset overrides it to \"auto\" . If you don't want to pin dependency versions and retain ranges, add the \":preserveSemverRanges\" preset to the extends array labels : Labels to assign to Pull Requests assignees : GitHub user(s) to assign the Pull Requests to Renovate will update your PR description each time it finds changes. Merge \u00b6 Once you're done checking and configuring in your Configure Renovate PR, it's time to merge it to enable the real Pull Requests to begin. Repository re-configuration \u00b6 There will be times when you need to change your Renovate config. There are two recommended approaches: Reconfigure via PR Nuke the config and re-onboard Reconfigure via PR \u00b6 If you want to make config edits directly, follow these steps: Create a new Git branch to work on Install or update the renovate package globally ( npm i -g renovate or yarn global add renovate ) to get the renovate-config-validator program Edit your Renovate configuration file Validate your config by running renovate-config-validator If the improved config passes the validation, merge the branch into your mainline branch You can configure a pre-commit hook to validate your configuration automatically. Please check out the renovatebot/pre-commit-hooks repository for more information. Nuke config and re-onboard \u00b6 Perhaps you really liked the interactive onboarding PR and want to use it again. You can follow the steps below to nuke the config and get a new PR. Any existing Renovate PRs will be closed after you've completed these steps. Find your original Configure Renovate PR Rename the original PR to something else, e.g. Configure Renovate - old Remove the current Renovate configuration file (e.g. renovate.json ) from your mainline branch Following these steps will trick Renovate into thinking that your repository was never onboarded, and will trigger a new \"Configure Renovate\" PR. If you're using the hosted Mend Renovate App and you don't get a new onboarding PR within a few hours, then please create a Discussions post to request staff trigger it manually.","title":"Installing & Onboarding"},{"location":"getting-started/installing-onboarding/#installing-and-onboarding-renovate-into-repositories","text":"","title":"Installing and onboarding Renovate into repositories"},{"location":"getting-started/installing-onboarding/#repository-installation","text":"Renovate administrators can configure Renovate to either \"autodiscover\" installed repositories, or configure a fixed list of repository names to operate on. If the administrator has configured a fixed list of repositories then the only way to \"install\" Renovate on an additional repository is for it to be manually added for the next run or restart. Otherwise, the process for adding new repositories to a Renovate installation can vary: Most commonly, you run Renovate as a dedicated \"bot user\" with global config option autodiscover set to true , meaning that it will run on every repository which it's been granted access to If using a GitHub App (including Mend Renovate on github.com ) then you can install the app into a user or organization account and select either \"All repositories\", or \"Select repositories\" and pick them manually","title":"Repository installation"},{"location":"getting-started/installing-onboarding/#hosted-githubcom-app","text":"Installing/enabling Mend's Renovate GitHub App is simple. First, navigate to https://github.com/apps/renovate and click the Install button: The only choice you need to make is whether to run Renovate on all repositories or on selected repositories: Renovate will ignore any repositories that don't have known package files, as well as any forks, so you can enable Renovate for all your repositories with no problems. That said, most people run Renovate on selected repositories. Unfortunately GitHub doesn't offer a \"select all except X, Y, Z\" option, so you must select each repository where you want Renovate to run. Once you're done selecting repositories for Renovate to run on, click the green Install button at the bottom of the page and Renovate will be enabled for those repositories and start the onboarding process. Note If you are using the Mend Renovate App then it has a custom behavior for forked repositories. If you choose \"All repositories\" when installing then forked repositories will be skipped by default, while if you choose \"Select repositories\" then they will be processed by Renovate even if they're a fork.","title":"Hosted GitHub.com App"},{"location":"getting-started/installing-onboarding/#hosted-gitlabcom-app","text":"Unfortunately Mend's hosted GitLab app needed to be taken offline indefinitely until a viable security model for bots on GitLab.com is available. For more details on GitLab security for bots, please see the GitLab Bot Security doc.","title":"Hosted GitLab.com App"},{"location":"getting-started/installing-onboarding/#repository-onboarding","text":"Once you have enabled Renovate on a repository, you will get a \"Configure Renovate\" Pull Request looking something like this:","title":"Repository onboarding"},{"location":"getting-started/installing-onboarding/#no-risk-onboarding","text":"Conveniently, Renovate will not make any changes to your repository or raise any further Pull Requests until after you merge the onboarding Pull Request. If there is anything about the Pull Request that you don't like or understand, take your time to read the documentation or ask questions on the discussions forum on GitHub and merge the PR only once you're satisfied with the result. You can edit your Renovate configuration within the renovate/configure branch and Renovate will keep updating the description in the PR to match, so you can work on the config until you're satisfied with the results.","title":"No risk onboarding"},{"location":"getting-started/installing-onboarding/#check-for-warnings","text":"If you have any Warnings or Errors listed, see if you need or want to make any changes to fix them. Warnings and errors should be fixed on the base branch (e.g. main ) so that Renovate can recreate its Configure Renovate PR on its next cycle.","title":"Check for warnings"},{"location":"getting-started/installing-onboarding/#configuration-location","text":"The \"Configure Renovate\" PR will include a renovate.json file in the root directory, with suggested default settings. If you don't want a renovate.json file in your repository you can use one of the following files instead: renovate.json5 .github/renovate.json .github/renovate.json5 .gitlab/renovate.json .gitlab/renovate.json5 .renovaterc .renovaterc.json package.json (deprecated)","title":"Configuration location"},{"location":"getting-started/installing-onboarding/#packagejson","text":"Warning This approach has been deprecated and will be removed in a future release. You can add the same settings to a \"renovate\" section in your package.json file instead. The package.json file must be located at the root of your repository. This is handy if you are already using a package.json file anyway, e.g. when you're working on a JavaScript project. The configuration in your package.json will apply to the whole project (this includes other, nested package.json files).","title":"package.json"},{"location":"getting-started/installing-onboarding/#customised-defaults","text":"Renovate provides a renovate.json file, with default settings that will work for most cases. Sometimes Renovate detects that an override to these defaults is needed, and will add this override automatically, such as: Automatically enabling Angular-style semantic commits if your repository uses them Determining whether to use dependency range pinning depending on the detected project type (app vs library)","title":"Customised defaults"},{"location":"getting-started/installing-onboarding/#common-overrides","text":"Please check the docs on this website for an exhaustive Configuration Reference. To help you get started, here are some of the most commonly changed (overridden) configuration settings: rangeStrategy : By default (with zero config) it's \"replace\" but the \"config:base\" preset overrides it to \"auto\" . If you don't want to pin dependency versions and retain ranges, add the \":preserveSemverRanges\" preset to the extends array labels : Labels to assign to Pull Requests assignees : GitHub user(s) to assign the Pull Requests to Renovate will update your PR description each time it finds changes.","title":"Common overrides"},{"location":"getting-started/installing-onboarding/#merge","text":"Once you're done checking and configuring in your Configure Renovate PR, it's time to merge it to enable the real Pull Requests to begin.","title":"Merge"},{"location":"getting-started/installing-onboarding/#repository-re-configuration","text":"There will be times when you need to change your Renovate config. There are two recommended approaches: Reconfigure via PR Nuke the config and re-onboard","title":"Repository re-configuration"},{"location":"getting-started/installing-onboarding/#reconfigure-via-pr","text":"If you want to make config edits directly, follow these steps: Create a new Git branch to work on Install or update the renovate package globally ( npm i -g renovate or yarn global add renovate ) to get the renovate-config-validator program Edit your Renovate configuration file Validate your config by running renovate-config-validator If the improved config passes the validation, merge the branch into your mainline branch You can configure a pre-commit hook to validate your configuration automatically. Please check out the renovatebot/pre-commit-hooks repository for more information.","title":"Reconfigure via PR"},{"location":"getting-started/installing-onboarding/#nuke-config-and-re-onboard","text":"Perhaps you really liked the interactive onboarding PR and want to use it again. You can follow the steps below to nuke the config and get a new PR. Any existing Renovate PRs will be closed after you've completed these steps. Find your original Configure Renovate PR Rename the original PR to something else, e.g. Configure Renovate - old Remove the current Renovate configuration file (e.g. renovate.json ) from your mainline branch Following these steps will trick Renovate into thinking that your repository was never onboarded, and will trigger a new \"Configure Renovate\" PR. If you're using the hosted Mend Renovate App and you don't get a new onboarding PR within a few hours, then please create a Discussions post to request staff trigger it manually.","title":"Nuke config and re-onboard"},{"location":"getting-started/private-packages/","text":"Private package support \u00b6 It's a very common requirement to be able to support private module/dependency lookups. This page describes Renovate's approach to authentication. First, a quick note on terminology: The terms module , package and dependency can mostly be used interchangeably below The terms credentials , secrets and authentication are also used interchangeably When does Renovate need credentials? \u00b6 By default, the only credentials Renovate has are those for the \"platform\", i.e. GitHub, GitLab, etc. If the token used has sufficient permissions, this will enable Renovate to lookup dependencies located in alternative repositories on the same host or any hosted on any embedded package registry on the same host. It's also quite common to need to look up packages on other protected hosts, including npmjs, Docker Hub, or private registries like Nexus or Artifactory. Any time you need Renovate to access such registries with credentials then you will need to provision them as part of your config. There are four times in Renovate's behavior when it may need credentials: Resolving private config presets Looking up dependency versions Looking up release notes Passing to package managers when updating lock files or checksums Note If you self-host Renovate, and have a self-hosted registry which doesn't require authentication to access, then such modules/packages are not considered \"private\" to Renovate. Private Config Presets \u00b6 Renovate supports config presets, including those which are private. Although npm presets were the first type supported, they are now deprecated and it is recommend that all users migrate to git-hosted \"local\" presets instead. However if you do still use them, private modules should work if you configure hostRules (recommended) or npmrc including token credentials in your bot global config. It is strongly recommended not to use private modules on a private registry and a warning will be logged if that is found. Credentials stored on disk (e.g. in ~/.npmrc ) are no longer supported. The recommended way of using local presets is to configure then using \"local\" presets, e.g. \"extends\": [\"local>myorg/renovate-config\"] , and ensure that the platform token has access to that repo. It's not recommended that you use a private repository to host your config while then extending it from a public repository. If your preset doesn't have secrets then you should make it public, while if it does have secrets then it's better to split your preset between a public one which all repos extend, and a private one with secrets which only other private repos extend. In summary, the recommended approach to private presets is: Host the presets on the same server/platform as other repositories Make sure you install Renovate into the preset repository so that it has credentials to access it from other private repos Use local>.... syntax to refer to private presets Dependency Version Lookups \u00b6 Whenever Renovate detects that a project uses a particular dependency, it tries to look up that dependency to see if any new versions exist. If such a package is private, then Renovate must be configured with the relevant credentials. Renovate does not use any package managers for this step and performs all HTTP(S) lookups itself, including insertion of authentication headers. Configuring Renovate with credentials requires hostRules . Each host rule consists of a hostType value and/or a way to match against hosts using matchHost . hostType is not particularly important at this step unless you have different credentials for the same host, but it is sometimes useful in later steps so is good to include if you can. It can be either a \"platform\" name (e.g. github , azure , etc) or a \"datasource\" name (e.g. npm , maven , github-tags , etc). If you want to apply credentials only for a nested path within a host then write matchHost as a base URL like https://registry.company.com/nested/path/ . If the same credentials apply to all paths on a host and not on any subdomains of it then configure matchHost with a protocol like https://registry.company.com . Finally, to apply credentials to all hosts within the domain, use a matchHost value with no https:// prefix, e.g. company.com or registry.company.com , both of which would apply to a host like beta.registry.company.com . In addition to the above options to match against a host, you need to add the credentials. Typically they are either token , or username + password . Other credential terms are not supported yet. Here is an example of some host rules: { \"hostRules\" : [ { \"matchHost\" : \"registry.npmjs.org\" , \"token\" : \"abc123\" }, { \"matchHost\" : \"https://registry.company.com/pypi-simple/\" , \"username\" : \"engineering\" , \"password\" : \"abc123\" } ] } Renovate applies theses hostRules to every HTTP(s) request which is sent, so they are largely independent of any platform or datasource logic. With hostRules in place, private package lookups should all work. Looking up Release Notes \u00b6 When Renovate creates Pull Requests, its default behavior is to locate and embed release notes/changelogs of packages. These release notes are fetched from the source repository of packages and not from the registries themselves, so if they are private then they will require different credentials. When it comes to open source, most packages host their source on github.com in public repositories. GitHub greatly rate limits unauthenticated API requests, so you need to configure credentials for github.com or the bot will get rate limited quickly. It can be confusing for people who host their own source code privately to be asked to configure a github.com token but without it Release Notes for most open source packages will be blocked. Currently the preferred way to configure github.com credentials for self-hosted Renovate is: Create a read-only Personal Access Token (PAT) for a github.com account. This can be any GitHub account, it might be better to create an \"empty\" account just for this purpose. Add the PAT to Renovate using the environment variable GITHUB_COM_TOKEN Package Manager Credentials for Artifact Updating \u00b6 In Renovate terminology, \"artifacts\" includes lock files, checksum files, and vendored dependencies. One way of understanding artifacts is: \"everything else that needs to be updated when the dependency version changes\". Not all package managers supported by Renovate require artifact updating, because not all use lock or checksum files. But when such files need updating, Renovate does so by using the package managers themselves instead of trying to \"reverse engineer\" each package manager's file formats and behavior. Importantly, such package managers are run via shell commands and do not understand Renovate's hostRules objects, so Renovate needs to reformat the credentials into formats (such as environment variables or configuration files) which the package manager understands. Because of this need to convert hostRules credentials into a format which package managers understand, sometimes artifact updating can fail due to missing credentials. Sometimes this can be resolved by changing Renovate configuration, but other times it may be due to a feature gap. The following details the most common/popular manager artifacts updating and how credentials are passed: bundler \u00b6 hostRules with hostType=rubygems are converted into environment variables which Bundler supports. composer \u00b6 Any hostRules token for github.com or gitlab.com are found and written out to COMPOSER_AUTH in env for Composer to parse. Any hostRules with hostType=packagist are also included. gomod \u00b6 If a github.com token is found in hostRules , then it is written out to local GIT_CONFIG_ variables prior to running go commands. The environment variables used are: GIT_CONFIG_KEY_0=url.https://${token}@github.com/.insteadOf GIT_CONFIG_VALUE_0=https://github.com/ GIT_CONFIG_COUNT=1 . helm \u00b6 Maybe you're running your own ChartMuseum server to host your private Helm Charts. This is how you connect to a private Helm repository: module . exports = { hostRules : [ { matchHost : 'your.host.io' , hostType : 'helm' username : '<your-username>' , password : process . env . SELF_HOSTED_HELM_CHARTS_PASSWORD , }, ], }; If you need to configure per-repository credentials then you can also configure the above within a repository's Renovate config (e.g. renovate.json ). npm \u00b6 The recommended approaches in order of preference are: Self-hosted hostRules : Configure a hostRules entry in the bot's config.js with the hostType , matchHost and token specified Renovate App with private modules from npmjs.org : Add an encrypted npmToken to your Renovate config Renovate App with a private registry : Add an unencrypted npmrc plus an encrypted npmToken in config These approaches are described in full below. Add hostRule to bots config \u00b6 Define hostRules like this: module . exports = { hostRules : [ { hostType : 'npm' , matchHost : 'registry.npmjs.org' , token : process . env . NPMJS_TOKEN , }, { hostType : 'npm' , matchHost : 'https://pkgs.dev.azure.com/{organization}/{project}/_packaging/{feed}/npm/registry/' , username : 'VssSessionToken' , password : process . env . AZURE_NPM_TOKEN , }, { // https://www.jfrog.com/confluence/display/JFROG/npm+Registry // Will be passed as `//artifactory.my-company.com/artifactory/api/npm/npm:_auth=<TOKEN>` to `.npmrc` hostType : 'npm' , matchHost : 'https://artifactory.my-company.com/artifactory/api/npm/npm/' , token : process . env . ARTIFACTORY_NPM_TOKEN , authType : 'Basic' , }, ], }; Tip Remember to put a trailing slash at the end of your matchHost URL. Add npmrc string to Renovate config \u00b6 You can add an .npmrc authentication line to your Renovate config under the field npmrc . e.g. a renovate.json might look like this: { \"npmrc\" : \"//some.registry.com/:_authToken=abcdefghi-1234-jklmno-aac6-12345567889\" } If configured like this, Renovate will use this to authenticate with npm and will ignore any .npmrc files(s) it finds checked into the repository. If you wish for the values in your config.npmrc to be merged (prepended) with any values found in repos then also set config.npmrcMerge=true . This merge approach is similar to how npm itself behaves if .npmrc is found in both the user home directory as well as a project. Add npmToken to Renovate config \u00b6 If you are using the main npmjs registry then you can configure just the npmToken instead: { \"npmToken\" : \"abcdefghi-1234-jklmno-aac6-12345567889\" } Add an encrypted npm token to Renovate config \u00b6 If you don't want all users of the repository to see the unencrypted token, you can encrypt it with Renovate's public key instead, so that only Renovate can decrypt it. Go to https://app.renovatebot.com/encrypt , paste in your npm token, click \"Encrypt\", then copy the encrypted result. Paste the encrypted result inside an encrypted object like this: { \"encrypted\" : { \"npmToken\" : \"xxT19RIdhAh09lkhdrK39HzKNBn3etoLZAwHdeJ25cX+5y52a9kAC7flXmdw5JrkciN08aQuRNqDaKxp53IVptB5AYOnQPrt8MCT+x0zHgp4A1zv1QOV84I6uugdWpFSjPUkmLGMgULudEZJMlY/dAn/IVwf/IImqwazY8eHyJAA4vyUqKkL9SXzHjvS+OBonQ/9/AHYYKmDJwT8vLSRCKrXxJCdUfH7ZnikZbFqjnURJ9nGUHP44rlYJ7PFl05RZ+X5WuZG/A27S5LuBvguyQGcw8A2AZilHSDta9S/4eG6kb22jX87jXTrT6orUkxh2WHI/xvNUEout0gxwWMDkA==\" } } If you have no .npmrc file then Renovate creates one for you, pointing to the default npmjs registry. If instead you use an alternative registry or need an .npmrc file for some other reason, you should configure it too and substitute the npm token with ${NPM_TOKEN} for it to be replaced. e.g. { \"encrypted\" : { \"npmToken\" : \"xxT19RIdhAh09lkhdrK39HzKNBn3etoLZAwHdeJ25cX+5y52a9kAC7flXmdw5JrkciN08aQuRNqDaKxp53IVptB5AYOnQPrt8MCT+x0zHgp4A1zv1QOV84I6uugdWpFSjPUkmLGMgULudEZJMlY/dAn/IVwf/IImqwazY8eHyJAA4vyUqKkL9SXzHjvS+OBonQ/9/AHYYKmDJwT8vLSRCKrXxJCdUfH7ZnikZbFqjnURJ9nGUHP44rlYJ7PFl05RZ+X5WuZG/A27S5LuBvguyQGcw8A2AZilHSDta9S/4eG6kb22jX87jXTrT6orUkxh2WHI/xvNUEout0gxwWMDkA==\" }, \"npmrc\" : \"registry=https://my.custom.registry/npm\\n//my.custom.registry/npm:_authToken=${NPM_TOKEN}\" } Renovate will then use the following logic: If no npmrc string is present in config then one will be created with the _authToken pointing to the default npmjs registry If an npmrc string is present and has a ${NPM_TOKEN} then that placeholder will be replaced with the decrypted token If an npmrc string is present but doesn't have a ${NPM_TOKEN} then the file will have _authToken=<token> appended to it Encrypted entire .npmrc file into config \u00b6 Copy the entire .npmrc , replace newlines with \\n characters , and then try encrypting it at https://app.renovatebot.com/encrypt . You will then get an encrypted string that you can substitute into your renovate.json instead. The end-result looks like this: { \"encrypted\" : { \"npmrc\" : \"WOTWu+jliBtXYz3CU2eI7dDyMIvSJKS2N5PEHZmLB3XKT3vLaaYTGCU6m92Q9FgdaM/q2wLYun2JrTP4GPaW8eGZ3iiG1cm7lgOR5xPnkCzz0DUmSf6Cc/6geeVeSFdJ0zqlEAhdNMyJ4pUW6iQxC3WJKgM/ADvFtme077Acvc0fhCXv0XvbNSbtUwHF/gD6OJ0r2qlIzUMGJk/eI254xo5SwWVctc1iZS9LW+L0/CKjqhWh4SbyglP3lKE5shg3q7mzWDZepa/nJmAnNmXdoVO2aPPeQCG3BKqCtCfvLUUU/0LvnJ2SbQ1obyzL7vhh2OF/VsATS5cxbHvoX/hxWQ==\" } } Automatically authenticate for npm package stored in private GitHub npm repository \u00b6 { \"hostRules\" : [ { \"matchHost\" : \"https://npm.pkg.github.com/\" , \"hostType\" : \"npm\" , \"encrypted\" : { \"token\" : \"<Encrypted PAT Token>\" } } ], \"npmrc\" : \"@organizationName:registry=https://npm.pkg.github.com/\" } Yarn 2+ \u00b6 Renovate doesn't support reading npmRegistries and npmScopes from .yarnrc.yml , so hostRules (or npmToken ) and npmrc should be configured like above. Renovate updates npmRegistries in .yarnrc.yml with resolved hostRules before running Yarn. For Renovate to overwrite existing npmRegistries entry, the key should match the matchHost minus the protocol ( http: or https: ) plus the trailing slash. For example, the Renovate configuration: { \"hostRules\" : [ { \"matchHost\" : \"https://npm.pkg.github.com/\" , \"hostType\" : \"npm\" , \"encrypted\" : { \"token\" : \"<Encrypted PAT Token>\" } } ] } will update .yarnrc.yml as following: npmRegistries : //npm.pkg.github.com/ : npmAuthToken : <Decrypted PAT Token> //npm.pkg.github.com : # this will not be overwritten and may conflict https://npm.pkg.github.com/ : # this will not be overwritten and may conflict nuget \u00b6 For each known NuGet registry, Renovate searches for hostRules with hostType=nuget and matching host. For those found, a command similar to the following is run: dotnet nuget add source ${registryInfo.feedUrl} --configfile ${nugetConfigFile} --username ${username} --password ${password} --store-password-in-clear-text poetry \u00b6 For every Poetry source, a hostRules search is done and then any found credentials are added to env like POETRY_HTTP_BASIC_X_USERNAME and POETRY_HTTP_BASIC_X_PASSWORD , where X represents the normalized name of the source in pyproject.toml . module . exports = { hostRules : [ { matchHost : 'pypi.example.com' , hostType : 'pypi' , username : process . env . PYPI_USERNAME , password : process . env . PYPI_PASSWORD , }, ], }; If you're self-hosting Renovate via the GitLab Runner and want to access packages from private GitLab registries, you can use the GitLab CI job token for authentication: module . exports = { hostRules : [ { matchHost : 'gitlab.example.com' , hostType : 'pypi' , username : 'gitlab-ci-token' , password : process . env . CI_JOB_TOKEN , }, ], }; Mend Renovate Hosted App Encryption \u00b6 The popular Renovate App on GitHub is hosted by Mend. If you are a user of this app, and have private modules, then the following is applicable. Private presets with public repositories \u00b6 If you have a preset in a private repo but reference (\"extend\") it from a public repository then it won't work. This is because public repositories are provided with a token scoped to only that particular repository, and not for all repositories within the organization. This is a security measure so that if a the token is accidentally leaked publicly, the damage is limited to the public repository it leaked to and not to every repository within the organization. The solution to this is that you should break your presets into public and private ones, and reference only the public ones from public repositories. Encrypting secrets \u00b6 It is strongly recommended that you avoid committing secrets to repositories, including private ones, and this includes secrets needed by Renovate to access private modules. The preferred approach to secrets is that the bot administrator configures them as hostRules which are then applied to all repositories which the bot accesses. If you need to provide credentials to the hosted Renovate App, please do this: Encrypt each secret string using https://app.renovatebot.com/encrypt . Note: this encrypts using the app's public key fully in the browser and does not send the original secret to any server. You can download this file and perform the encryption fully offline if you like. Wrap each secret field in an encrypted object and paste in the encrypted secret value instead. An example is shown below: { \"hostRules\" : [ { \"matchHost\" : \"registry.npmjs.org\" , \"encrypted\" : { \"token\" : \"3f832f2983yf89hsd98ahadsjfasdfjaslf............\" } }, { \"matchHost\" : \"https://custom.registry.company.com/pypi/\" , \"username\" : \"bot1\" , \"encrypted\" : { \"password\" : \"p278djfdsi9832jnfdshufwji2r389fdskj.........\" } } ] } Access to GitHub Actions Secrets \u00b6 The Mend Renovate App does not run using GitHub Actions, but such secrets would be a bad fit for the app anyway for the following reasons: The app would be granted access to all the repository/org secrets, not just the ones you want If Renovate wants access to such secrets, it would need to ask for them from every user, not just the ones who want to use this approach (GitHub does not support the concept of optional permissions for Apps, so people do not have the option to decline) Admin/Bot config vs User/Repository config for Self-hosted users \u00b6 \"Admin/Bot config\" refers to the config which the Renovate Bot administrator provides at bot startup, e.g. using environment variables, CLI parameters, or the config.js configuration file. User/Repository config refers to the in-repository config file which defaults to renovate.json but has a large number of alternative filenames supported. If there is a need to supply custom rules for certain repository, it can still be done using the config.js file and the repositories array. If per-repository config must be done within the repository, it is still recommended against committing secrets directly (including e.g. .npmrc files with tokens) and instead encrypting them with a custom public key first. For instructions on this, see the above section on encrypting secrets for the Mend Renovate App but instead: Save a copy of the https://app.renovatebot.com/encrypt HTML file locally, or host it locally Generate a public/private key pair for the app using the instructions in privateKey Replace the existing public key in the HTML with the public key you generated in the step prior Use the resulting HTML encrypt page to encrypt secrets for your app before adding them to user/repository config Configure the app to run with privateKey set to the private key you generated above Note Encrypted values can't be used in the \"Admin/Bot config\". hostRules configuration using environment variables \u00b6 Self-hosted users can enable the option detectHostRulesFromEnv to configure the most common types of hostRules via environment variables.","title":"Private Packages"},{"location":"getting-started/private-packages/#private-package-support","text":"It's a very common requirement to be able to support private module/dependency lookups. This page describes Renovate's approach to authentication. First, a quick note on terminology: The terms module , package and dependency can mostly be used interchangeably below The terms credentials , secrets and authentication are also used interchangeably","title":"Private package support"},{"location":"getting-started/private-packages/#when-does-renovate-need-credentials","text":"By default, the only credentials Renovate has are those for the \"platform\", i.e. GitHub, GitLab, etc. If the token used has sufficient permissions, this will enable Renovate to lookup dependencies located in alternative repositories on the same host or any hosted on any embedded package registry on the same host. It's also quite common to need to look up packages on other protected hosts, including npmjs, Docker Hub, or private registries like Nexus or Artifactory. Any time you need Renovate to access such registries with credentials then you will need to provision them as part of your config. There are four times in Renovate's behavior when it may need credentials: Resolving private config presets Looking up dependency versions Looking up release notes Passing to package managers when updating lock files or checksums Note If you self-host Renovate, and have a self-hosted registry which doesn't require authentication to access, then such modules/packages are not considered \"private\" to Renovate.","title":"When does Renovate need credentials?"},{"location":"getting-started/private-packages/#private-config-presets","text":"Renovate supports config presets, including those which are private. Although npm presets were the first type supported, they are now deprecated and it is recommend that all users migrate to git-hosted \"local\" presets instead. However if you do still use them, private modules should work if you configure hostRules (recommended) or npmrc including token credentials in your bot global config. It is strongly recommended not to use private modules on a private registry and a warning will be logged if that is found. Credentials stored on disk (e.g. in ~/.npmrc ) are no longer supported. The recommended way of using local presets is to configure then using \"local\" presets, e.g. \"extends\": [\"local>myorg/renovate-config\"] , and ensure that the platform token has access to that repo. It's not recommended that you use a private repository to host your config while then extending it from a public repository. If your preset doesn't have secrets then you should make it public, while if it does have secrets then it's better to split your preset between a public one which all repos extend, and a private one with secrets which only other private repos extend. In summary, the recommended approach to private presets is: Host the presets on the same server/platform as other repositories Make sure you install Renovate into the preset repository so that it has credentials to access it from other private repos Use local>.... syntax to refer to private presets","title":"Private Config Presets"},{"location":"getting-started/private-packages/#dependency-version-lookups","text":"Whenever Renovate detects that a project uses a particular dependency, it tries to look up that dependency to see if any new versions exist. If such a package is private, then Renovate must be configured with the relevant credentials. Renovate does not use any package managers for this step and performs all HTTP(S) lookups itself, including insertion of authentication headers. Configuring Renovate with credentials requires hostRules . Each host rule consists of a hostType value and/or a way to match against hosts using matchHost . hostType is not particularly important at this step unless you have different credentials for the same host, but it is sometimes useful in later steps so is good to include if you can. It can be either a \"platform\" name (e.g. github , azure , etc) or a \"datasource\" name (e.g. npm , maven , github-tags , etc). If you want to apply credentials only for a nested path within a host then write matchHost as a base URL like https://registry.company.com/nested/path/ . If the same credentials apply to all paths on a host and not on any subdomains of it then configure matchHost with a protocol like https://registry.company.com . Finally, to apply credentials to all hosts within the domain, use a matchHost value with no https:// prefix, e.g. company.com or registry.company.com , both of which would apply to a host like beta.registry.company.com . In addition to the above options to match against a host, you need to add the credentials. Typically they are either token , or username + password . Other credential terms are not supported yet. Here is an example of some host rules: { \"hostRules\" : [ { \"matchHost\" : \"registry.npmjs.org\" , \"token\" : \"abc123\" }, { \"matchHost\" : \"https://registry.company.com/pypi-simple/\" , \"username\" : \"engineering\" , \"password\" : \"abc123\" } ] } Renovate applies theses hostRules to every HTTP(s) request which is sent, so they are largely independent of any platform or datasource logic. With hostRules in place, private package lookups should all work.","title":"Dependency Version Lookups"},{"location":"getting-started/private-packages/#looking-up-release-notes","text":"When Renovate creates Pull Requests, its default behavior is to locate and embed release notes/changelogs of packages. These release notes are fetched from the source repository of packages and not from the registries themselves, so if they are private then they will require different credentials. When it comes to open source, most packages host their source on github.com in public repositories. GitHub greatly rate limits unauthenticated API requests, so you need to configure credentials for github.com or the bot will get rate limited quickly. It can be confusing for people who host their own source code privately to be asked to configure a github.com token but without it Release Notes for most open source packages will be blocked. Currently the preferred way to configure github.com credentials for self-hosted Renovate is: Create a read-only Personal Access Token (PAT) for a github.com account. This can be any GitHub account, it might be better to create an \"empty\" account just for this purpose. Add the PAT to Renovate using the environment variable GITHUB_COM_TOKEN","title":"Looking up Release Notes"},{"location":"getting-started/private-packages/#package-manager-credentials-for-artifact-updating","text":"In Renovate terminology, \"artifacts\" includes lock files, checksum files, and vendored dependencies. One way of understanding artifacts is: \"everything else that needs to be updated when the dependency version changes\". Not all package managers supported by Renovate require artifact updating, because not all use lock or checksum files. But when such files need updating, Renovate does so by using the package managers themselves instead of trying to \"reverse engineer\" each package manager's file formats and behavior. Importantly, such package managers are run via shell commands and do not understand Renovate's hostRules objects, so Renovate needs to reformat the credentials into formats (such as environment variables or configuration files) which the package manager understands. Because of this need to convert hostRules credentials into a format which package managers understand, sometimes artifact updating can fail due to missing credentials. Sometimes this can be resolved by changing Renovate configuration, but other times it may be due to a feature gap. The following details the most common/popular manager artifacts updating and how credentials are passed:","title":"Package Manager Credentials for Artifact Updating"},{"location":"getting-started/private-packages/#bundler","text":"hostRules with hostType=rubygems are converted into environment variables which Bundler supports.","title":"bundler"},{"location":"getting-started/private-packages/#composer","text":"Any hostRules token for github.com or gitlab.com are found and written out to COMPOSER_AUTH in env for Composer to parse. Any hostRules with hostType=packagist are also included.","title":"composer"},{"location":"getting-started/private-packages/#gomod","text":"If a github.com token is found in hostRules , then it is written out to local GIT_CONFIG_ variables prior to running go commands. The environment variables used are: GIT_CONFIG_KEY_0=url.https://${token}@github.com/.insteadOf GIT_CONFIG_VALUE_0=https://github.com/ GIT_CONFIG_COUNT=1 .","title":"gomod"},{"location":"getting-started/private-packages/#helm","text":"Maybe you're running your own ChartMuseum server to host your private Helm Charts. This is how you connect to a private Helm repository: module . exports = { hostRules : [ { matchHost : 'your.host.io' , hostType : 'helm' username : '<your-username>' , password : process . env . SELF_HOSTED_HELM_CHARTS_PASSWORD , }, ], }; If you need to configure per-repository credentials then you can also configure the above within a repository's Renovate config (e.g. renovate.json ).","title":"helm"},{"location":"getting-started/private-packages/#npm","text":"The recommended approaches in order of preference are: Self-hosted hostRules : Configure a hostRules entry in the bot's config.js with the hostType , matchHost and token specified Renovate App with private modules from npmjs.org : Add an encrypted npmToken to your Renovate config Renovate App with a private registry : Add an unencrypted npmrc plus an encrypted npmToken in config These approaches are described in full below.","title":"npm"},{"location":"getting-started/private-packages/#add-hostrule-to-bots-config","text":"Define hostRules like this: module . exports = { hostRules : [ { hostType : 'npm' , matchHost : 'registry.npmjs.org' , token : process . env . NPMJS_TOKEN , }, { hostType : 'npm' , matchHost : 'https://pkgs.dev.azure.com/{organization}/{project}/_packaging/{feed}/npm/registry/' , username : 'VssSessionToken' , password : process . env . AZURE_NPM_TOKEN , }, { // https://www.jfrog.com/confluence/display/JFROG/npm+Registry // Will be passed as `//artifactory.my-company.com/artifactory/api/npm/npm:_auth=<TOKEN>` to `.npmrc` hostType : 'npm' , matchHost : 'https://artifactory.my-company.com/artifactory/api/npm/npm/' , token : process . env . ARTIFACTORY_NPM_TOKEN , authType : 'Basic' , }, ], }; Tip Remember to put a trailing slash at the end of your matchHost URL.","title":"Add hostRule to bots config"},{"location":"getting-started/private-packages/#add-npmrc-string-to-renovate-config","text":"You can add an .npmrc authentication line to your Renovate config under the field npmrc . e.g. a renovate.json might look like this: { \"npmrc\" : \"//some.registry.com/:_authToken=abcdefghi-1234-jklmno-aac6-12345567889\" } If configured like this, Renovate will use this to authenticate with npm and will ignore any .npmrc files(s) it finds checked into the repository. If you wish for the values in your config.npmrc to be merged (prepended) with any values found in repos then also set config.npmrcMerge=true . This merge approach is similar to how npm itself behaves if .npmrc is found in both the user home directory as well as a project.","title":"Add npmrc string to Renovate config"},{"location":"getting-started/private-packages/#add-npmtoken-to-renovate-config","text":"If you are using the main npmjs registry then you can configure just the npmToken instead: { \"npmToken\" : \"abcdefghi-1234-jklmno-aac6-12345567889\" }","title":"Add npmToken to Renovate config"},{"location":"getting-started/private-packages/#add-an-encrypted-npm-token-to-renovate-config","text":"If you don't want all users of the repository to see the unencrypted token, you can encrypt it with Renovate's public key instead, so that only Renovate can decrypt it. Go to https://app.renovatebot.com/encrypt , paste in your npm token, click \"Encrypt\", then copy the encrypted result. Paste the encrypted result inside an encrypted object like this: { \"encrypted\" : { \"npmToken\" : \"xxT19RIdhAh09lkhdrK39HzKNBn3etoLZAwHdeJ25cX+5y52a9kAC7flXmdw5JrkciN08aQuRNqDaKxp53IVptB5AYOnQPrt8MCT+x0zHgp4A1zv1QOV84I6uugdWpFSjPUkmLGMgULudEZJMlY/dAn/IVwf/IImqwazY8eHyJAA4vyUqKkL9SXzHjvS+OBonQ/9/AHYYKmDJwT8vLSRCKrXxJCdUfH7ZnikZbFqjnURJ9nGUHP44rlYJ7PFl05RZ+X5WuZG/A27S5LuBvguyQGcw8A2AZilHSDta9S/4eG6kb22jX87jXTrT6orUkxh2WHI/xvNUEout0gxwWMDkA==\" } } If you have no .npmrc file then Renovate creates one for you, pointing to the default npmjs registry. If instead you use an alternative registry or need an .npmrc file for some other reason, you should configure it too and substitute the npm token with ${NPM_TOKEN} for it to be replaced. e.g. { \"encrypted\" : { \"npmToken\" : \"xxT19RIdhAh09lkhdrK39HzKNBn3etoLZAwHdeJ25cX+5y52a9kAC7flXmdw5JrkciN08aQuRNqDaKxp53IVptB5AYOnQPrt8MCT+x0zHgp4A1zv1QOV84I6uugdWpFSjPUkmLGMgULudEZJMlY/dAn/IVwf/IImqwazY8eHyJAA4vyUqKkL9SXzHjvS+OBonQ/9/AHYYKmDJwT8vLSRCKrXxJCdUfH7ZnikZbFqjnURJ9nGUHP44rlYJ7PFl05RZ+X5WuZG/A27S5LuBvguyQGcw8A2AZilHSDta9S/4eG6kb22jX87jXTrT6orUkxh2WHI/xvNUEout0gxwWMDkA==\" }, \"npmrc\" : \"registry=https://my.custom.registry/npm\\n//my.custom.registry/npm:_authToken=${NPM_TOKEN}\" } Renovate will then use the following logic: If no npmrc string is present in config then one will be created with the _authToken pointing to the default npmjs registry If an npmrc string is present and has a ${NPM_TOKEN} then that placeholder will be replaced with the decrypted token If an npmrc string is present but doesn't have a ${NPM_TOKEN} then the file will have _authToken=<token> appended to it","title":"Add an encrypted npm token to Renovate config"},{"location":"getting-started/private-packages/#encrypted-entire-npmrc-file-into-config","text":"Copy the entire .npmrc , replace newlines with \\n characters , and then try encrypting it at https://app.renovatebot.com/encrypt . You will then get an encrypted string that you can substitute into your renovate.json instead. The end-result looks like this: { \"encrypted\" : { \"npmrc\" : \"WOTWu+jliBtXYz3CU2eI7dDyMIvSJKS2N5PEHZmLB3XKT3vLaaYTGCU6m92Q9FgdaM/q2wLYun2JrTP4GPaW8eGZ3iiG1cm7lgOR5xPnkCzz0DUmSf6Cc/6geeVeSFdJ0zqlEAhdNMyJ4pUW6iQxC3WJKgM/ADvFtme077Acvc0fhCXv0XvbNSbtUwHF/gD6OJ0r2qlIzUMGJk/eI254xo5SwWVctc1iZS9LW+L0/CKjqhWh4SbyglP3lKE5shg3q7mzWDZepa/nJmAnNmXdoVO2aPPeQCG3BKqCtCfvLUUU/0LvnJ2SbQ1obyzL7vhh2OF/VsATS5cxbHvoX/hxWQ==\" } }","title":"Encrypted entire .npmrc file into config"},{"location":"getting-started/private-packages/#automatically-authenticate-for-npm-package-stored-in-private-github-npm-repository","text":"{ \"hostRules\" : [ { \"matchHost\" : \"https://npm.pkg.github.com/\" , \"hostType\" : \"npm\" , \"encrypted\" : { \"token\" : \"<Encrypted PAT Token>\" } } ], \"npmrc\" : \"@organizationName:registry=https://npm.pkg.github.com/\" }","title":"Automatically authenticate for npm package stored in private GitHub npm repository"},{"location":"getting-started/private-packages/#yarn-2","text":"Renovate doesn't support reading npmRegistries and npmScopes from .yarnrc.yml , so hostRules (or npmToken ) and npmrc should be configured like above. Renovate updates npmRegistries in .yarnrc.yml with resolved hostRules before running Yarn. For Renovate to overwrite existing npmRegistries entry, the key should match the matchHost minus the protocol ( http: or https: ) plus the trailing slash. For example, the Renovate configuration: { \"hostRules\" : [ { \"matchHost\" : \"https://npm.pkg.github.com/\" , \"hostType\" : \"npm\" , \"encrypted\" : { \"token\" : \"<Encrypted PAT Token>\" } } ] } will update .yarnrc.yml as following: npmRegistries : //npm.pkg.github.com/ : npmAuthToken : <Decrypted PAT Token> //npm.pkg.github.com : # this will not be overwritten and may conflict https://npm.pkg.github.com/ : # this will not be overwritten and may conflict","title":"Yarn 2+"},{"location":"getting-started/private-packages/#nuget","text":"For each known NuGet registry, Renovate searches for hostRules with hostType=nuget and matching host. For those found, a command similar to the following is run: dotnet nuget add source ${registryInfo.feedUrl} --configfile ${nugetConfigFile} --username ${username} --password ${password} --store-password-in-clear-text","title":"nuget"},{"location":"getting-started/private-packages/#poetry","text":"For every Poetry source, a hostRules search is done and then any found credentials are added to env like POETRY_HTTP_BASIC_X_USERNAME and POETRY_HTTP_BASIC_X_PASSWORD , where X represents the normalized name of the source in pyproject.toml . module . exports = { hostRules : [ { matchHost : 'pypi.example.com' , hostType : 'pypi' , username : process . env . PYPI_USERNAME , password : process . env . PYPI_PASSWORD , }, ], }; If you're self-hosting Renovate via the GitLab Runner and want to access packages from private GitLab registries, you can use the GitLab CI job token for authentication: module . exports = { hostRules : [ { matchHost : 'gitlab.example.com' , hostType : 'pypi' , username : 'gitlab-ci-token' , password : process . env . CI_JOB_TOKEN , }, ], };","title":"poetry"},{"location":"getting-started/private-packages/#mend-renovate-hosted-app-encryption","text":"The popular Renovate App on GitHub is hosted by Mend. If you are a user of this app, and have private modules, then the following is applicable.","title":"Mend Renovate Hosted App Encryption"},{"location":"getting-started/private-packages/#private-presets-with-public-repositories","text":"If you have a preset in a private repo but reference (\"extend\") it from a public repository then it won't work. This is because public repositories are provided with a token scoped to only that particular repository, and not for all repositories within the organization. This is a security measure so that if a the token is accidentally leaked publicly, the damage is limited to the public repository it leaked to and not to every repository within the organization. The solution to this is that you should break your presets into public and private ones, and reference only the public ones from public repositories.","title":"Private presets with public repositories"},{"location":"getting-started/private-packages/#encrypting-secrets","text":"It is strongly recommended that you avoid committing secrets to repositories, including private ones, and this includes secrets needed by Renovate to access private modules. The preferred approach to secrets is that the bot administrator configures them as hostRules which are then applied to all repositories which the bot accesses. If you need to provide credentials to the hosted Renovate App, please do this: Encrypt each secret string using https://app.renovatebot.com/encrypt . Note: this encrypts using the app's public key fully in the browser and does not send the original secret to any server. You can download this file and perform the encryption fully offline if you like. Wrap each secret field in an encrypted object and paste in the encrypted secret value instead. An example is shown below: { \"hostRules\" : [ { \"matchHost\" : \"registry.npmjs.org\" , \"encrypted\" : { \"token\" : \"3f832f2983yf89hsd98ahadsjfasdfjaslf............\" } }, { \"matchHost\" : \"https://custom.registry.company.com/pypi/\" , \"username\" : \"bot1\" , \"encrypted\" : { \"password\" : \"p278djfdsi9832jnfdshufwji2r389fdskj.........\" } } ] }","title":"Encrypting secrets"},{"location":"getting-started/private-packages/#access-to-github-actions-secrets","text":"The Mend Renovate App does not run using GitHub Actions, but such secrets would be a bad fit for the app anyway for the following reasons: The app would be granted access to all the repository/org secrets, not just the ones you want If Renovate wants access to such secrets, it would need to ask for them from every user, not just the ones who want to use this approach (GitHub does not support the concept of optional permissions for Apps, so people do not have the option to decline)","title":"Access to GitHub Actions Secrets"},{"location":"getting-started/private-packages/#adminbot-config-vs-userrepository-config-for-self-hosted-users","text":"\"Admin/Bot config\" refers to the config which the Renovate Bot administrator provides at bot startup, e.g. using environment variables, CLI parameters, or the config.js configuration file. User/Repository config refers to the in-repository config file which defaults to renovate.json but has a large number of alternative filenames supported. If there is a need to supply custom rules for certain repository, it can still be done using the config.js file and the repositories array. If per-repository config must be done within the repository, it is still recommended against committing secrets directly (including e.g. .npmrc files with tokens) and instead encrypting them with a custom public key first. For instructions on this, see the above section on encrypting secrets for the Mend Renovate App but instead: Save a copy of the https://app.renovatebot.com/encrypt HTML file locally, or host it locally Generate a public/private key pair for the app using the instructions in privateKey Replace the existing public key in the HTML with the public key you generated in the step prior Use the resulting HTML encrypt page to encrypt secrets for your app before adding them to user/repository config Configure the app to run with privateKey set to the private key you generated above Note Encrypted values can't be used in the \"Admin/Bot config\".","title":"Admin/Bot config vs User/Repository config for Self-hosted users"},{"location":"getting-started/private-packages/#hostrules-configuration-using-environment-variables","text":"Self-hosted users can enable the option detectHostRulesFromEnv to configure the most common types of hostRules via environment variables.","title":"hostRules configuration using environment variables"},{"location":"getting-started/running/","text":"Running Renovate \u00b6 As a Renovate end user, there are two main categories of use: You self-host Renovate, e.g. by running the pre-built Docker image, or Someone else is hosting Renovate, and you install/configure it for the repositories you choose If someone else is hosting Renovate for you, or you are using the Mend Renovate App on GitHub, then you can skip ahead to the installing & onboarding page. Self-Hosting Renovate \u00b6 Self-hosting Renovate means that you are the \"administrator\" of the bot, which entails: You provide infrastructure for it to run on, You provision its global config, You ensure it's running regularly, You ensure Renovate bot itself is updated Available distributions \u00b6 npm package (CLI) \u00b6 Renovate's Open Source CLI is built and distributed as the npm package renovate . You can run this directly in any Node.js environment - even via npx - and it will process all the repositories it is configured with, before exiting. When you install Renovate from npm it naturally does not come bundled with any third-party tools or languages such as Ruby, Python, Composer, Bundler, Poetry, etc. If you need Renovate to support any non-npm lock files like Bundler then you'll need to make sure all required third-party tools are pre-installed in the same environment alongside Renovate before you run it. The renovate npm package is compatible with all of Renovate's supported platforms. Renovate requires Node.js >=14.15.0 and Git >=2.33.0 . Docker image \u00b6 The renovate npm package is also distributed via pre-built Node.js images on Docker Hub ( renovate/renovate ). The slim image contains only Node.js so works if either: You do not require any additional package managers, or You map the Docker socket into the container so that Renovate can dynamically invoke \"sidecar\" images when necessary The \"full\" image (which latest defaults to) has every package manager which Renovate supports already preinstalled. This approach works best for many, but does have the following downsides: It only has one version of each language/manager - usually the latest It's several gigabytes in size The renovate/renovate Docker images are compatible with all of Renovate's supported platforms. GitHub Action \u00b6 Renovate's npm tool is also provided as a pre-prepared GitHub Action on renovatebot/github-action . Details on how to use it can be found in the repository. GitLab Runner \u00b6 The Renovate team provide a \"Renovate Runner\" project to make it easier to run Renovate as a CI pipeline job. This supports both gitlab.com as well as self-hosted GitLab. Details for how it works can be found in the project. Mend Renovate On-Premises \u00b6 Mend Renovate On-Premises (WSOP) started out as a commercial product \"Renovate Pro\", but was renamed and made free to use when Renovate became a part of Mend (formerly WhiteSource) in 2019. It is built similarly to the \"full\" Renovate image described above, but with these differences: It is a stateful app and does not exit once it's processed all repositories It is installed as an App on GitHub, and behaves similarly on GitLab - for example responding to webhooks It includes a priority job queue which prioritizes events like merged PRs over scheduled jobs It is released every 1-2 months in a slower, more stable cadence than Renovate OSS, which releases on every commit It's licensed using an end-user license agreement (EULA) and not the Affero General Public License (AGPL) WSOP supports GitHub (both github.com and GitHub Enterprise Server) as well as GitLab self-hosted. Documentation can be found in its public GitHub repository whitesource/renovate-on-prem . Mend Remediate \u00b6 Mend Remediate is an extension of WSOP available for Mend commercial customers, with full enterprise support. It is integrated with Mend's vulnerability detection capabilities and additionally supports the capability of \"horizontal\" scalability - the ability to configure many Renovate \"worker\" containers which share a common job queue in order to not conflict with each other. Mend Remediate supports GitHub Enterprise Server, GitLab self-hosted, and Bitbucket Server. Forking Renovate app \u00b6 \"Forking Renovate\" is the sister app to the Mend Renovate App on GitHub.com. The difference is that Forking Renovate does not require write permissions to create branches within the repo, and instead submits PRs from its own fork. Because of how it works, it functions on public repositories only and additionally cannot support automerge capabilities. Install Forking Renovate from GitHub App . Benefits \u00b6 Forking Renovate needs only read level access to the code of any repository it runs on. Drawbacks \u00b6 If you use Forking Renovate, you'll miss out on these features of the regular Renovate app: Automerge is not supported The baseBranches config option is not supported The app dashboard ( app.renovatebot.com ) is currently not supported Hosting Renovate \u00b6 Once you have decided on a Renovate distribution, you need to decide where and how to run it. For the GitHub Action and GitLab Runner approaches, they will naturally run on their respective CI infrastructure. For the npm package approach or Docker images, you will need some form of VM or container infrastructure to run Renovate on. In all the above cases you will need to make sure that some form of cron-like capability exists to schedule when Renovate runs. In general we recommend to run Renovate hourly if possible. Mend Renovate On-Premises and Mend Remediate both run as long-lived containers so do not need any additional cron-like concept as it is built-in. Global config \u00b6 Renovate's server-side/admin config is referred to as its \"global\" config, and can be specified using either a config file, environment variables, or CLI parameters. By default Renovate checks if a file named config.js is present. Any other ( *.js , *.json , *.json5 , *.yaml or *.yml ) file is supported, when you reference it with the RENOVATE_CONFIG_FILE environment variable (e.g. RENOVATE_CONFIG_FILE=config.yaml ). Some config is global-only, meaning that either it is only applicable to the bot administrator or it can only be controlled by the administrator and not repository users. Those are documented in Self-hosted Configuration . Your bot's global config can include both global as well as non-global configuration options, while user/repo config can only include non-global options. It is recommended to keep as much of the non-global config as possible in repo config files in order to provide maximum transparency to end users. If you are configuring using environment variables, there are two possibilities: Upper-cased, camel-cased, RENOVATE_ -prefixed single config options like RENOVATE_TOKEN=abc123 or RENOVATE_GIT_AUTHOR=a@b.com Set RENOVATE_CONFIG to a stringified version of the full JSON config, e.g. RENOVATE_CONFIG='{\"token\":\"abc123\",\"gitAuthor\":\"a@b.com\"}' If you combine both of the above then any single config option in the environment variable will override what's in RENOVATE_CONFIG . Note It's also possible to change the default prefix from RENOVATE_ using ENV_PREFIX . e.g. ENV_PREFIX=RNV_ RNV_TOKEN=abc123 renovate . Using config.js \u00b6 If you use a config.js , it will be expected to export a configuration via module.exports . The value can be either a plain JavaScript object like in this example where config.js exports a plain object: module . exports = { token : 'abcdefg' , }; config.js may also export a Promise of such an object, or a function that will return either a plain JavaScript object or a Promise of such an object. This allows one to include the results of asynchronous operations in the exported value. An example of a config.js that exports an async function (which is a function that returns a Promise ) can be seen in a comment for #10011: Allow autodiscover filtering for repo topic and more examples can be seen in file.spec.ts . Authentication \u00b6 Regardless of platform, you need to select a user account for renovate to assume the identity of, and generate a Personal Access Token. We recommend you use @renovate-bot as username if you're on a self-hosted server where you can set all usernames. We also recommend you configure config.gitAuthor with the same identity as your Renovate user, e.g. like \"gitAuthor\": \"Renovate Bot <renovate@whitesourcesoftware.com>\" . Warning We recommend you use a single, dedicated username for your Renovate bot. Never share the Renovate username with your other bots, as this can cause flip-flopping. Docs \u00b6 Read the platform-specific docs to learn how to setup authentication on your platform: Azure DevOps Bitbucket Cloud Bitbucket Server Gitea github.com and GitHub Enterprise Server GitLab GitHub.com token for release notes \u00b6 If you are running on any platform except github.com, it's important to also configure the environment variable GITHUB_COM_TOKEN containing a Personal Access Token for github.com. This account can actually be any account on GitHub, and needs only read-only access. It's used when fetching release notes for repositories in order to increase the hourly API limit. It's also OK to configure the same as a host rule instead, if you prefer that. Note If you're using Renovate in a project where dependencies are loaded from github.com (such as Go modules hosted on GitHub) it is highly recommended to add a token. Otherwise you will exceed the rate limit from the github.com API, which will lead to Renovate closing and reopening PRs because it could not get reliable info on updated dependencies. Self-hosting examples \u00b6 For more examples on running Renovate self-hosted, please read our Self-hosted examples page.","title":"Running Renovate"},{"location":"getting-started/running/#running-renovate","text":"As a Renovate end user, there are two main categories of use: You self-host Renovate, e.g. by running the pre-built Docker image, or Someone else is hosting Renovate, and you install/configure it for the repositories you choose If someone else is hosting Renovate for you, or you are using the Mend Renovate App on GitHub, then you can skip ahead to the installing & onboarding page.","title":"Running Renovate"},{"location":"getting-started/running/#self-hosting-renovate","text":"Self-hosting Renovate means that you are the \"administrator\" of the bot, which entails: You provide infrastructure for it to run on, You provision its global config, You ensure it's running regularly, You ensure Renovate bot itself is updated","title":"Self-Hosting Renovate"},{"location":"getting-started/running/#available-distributions","text":"","title":"Available distributions"},{"location":"getting-started/running/#npm-package-cli","text":"Renovate's Open Source CLI is built and distributed as the npm package renovate . You can run this directly in any Node.js environment - even via npx - and it will process all the repositories it is configured with, before exiting. When you install Renovate from npm it naturally does not come bundled with any third-party tools or languages such as Ruby, Python, Composer, Bundler, Poetry, etc. If you need Renovate to support any non-npm lock files like Bundler then you'll need to make sure all required third-party tools are pre-installed in the same environment alongside Renovate before you run it. The renovate npm package is compatible with all of Renovate's supported platforms. Renovate requires Node.js >=14.15.0 and Git >=2.33.0 .","title":"npm package (CLI)"},{"location":"getting-started/running/#docker-image","text":"The renovate npm package is also distributed via pre-built Node.js images on Docker Hub ( renovate/renovate ). The slim image contains only Node.js so works if either: You do not require any additional package managers, or You map the Docker socket into the container so that Renovate can dynamically invoke \"sidecar\" images when necessary The \"full\" image (which latest defaults to) has every package manager which Renovate supports already preinstalled. This approach works best for many, but does have the following downsides: It only has one version of each language/manager - usually the latest It's several gigabytes in size The renovate/renovate Docker images are compatible with all of Renovate's supported platforms.","title":"Docker image"},{"location":"getting-started/running/#github-action","text":"Renovate's npm tool is also provided as a pre-prepared GitHub Action on renovatebot/github-action . Details on how to use it can be found in the repository.","title":"GitHub Action"},{"location":"getting-started/running/#gitlab-runner","text":"The Renovate team provide a \"Renovate Runner\" project to make it easier to run Renovate as a CI pipeline job. This supports both gitlab.com as well as self-hosted GitLab. Details for how it works can be found in the project.","title":"GitLab Runner"},{"location":"getting-started/running/#mend-renovate-on-premises","text":"Mend Renovate On-Premises (WSOP) started out as a commercial product \"Renovate Pro\", but was renamed and made free to use when Renovate became a part of Mend (formerly WhiteSource) in 2019. It is built similarly to the \"full\" Renovate image described above, but with these differences: It is a stateful app and does not exit once it's processed all repositories It is installed as an App on GitHub, and behaves similarly on GitLab - for example responding to webhooks It includes a priority job queue which prioritizes events like merged PRs over scheduled jobs It is released every 1-2 months in a slower, more stable cadence than Renovate OSS, which releases on every commit It's licensed using an end-user license agreement (EULA) and not the Affero General Public License (AGPL) WSOP supports GitHub (both github.com and GitHub Enterprise Server) as well as GitLab self-hosted. Documentation can be found in its public GitHub repository whitesource/renovate-on-prem .","title":"Mend Renovate On-Premises"},{"location":"getting-started/running/#mend-remediate","text":"Mend Remediate is an extension of WSOP available for Mend commercial customers, with full enterprise support. It is integrated with Mend's vulnerability detection capabilities and additionally supports the capability of \"horizontal\" scalability - the ability to configure many Renovate \"worker\" containers which share a common job queue in order to not conflict with each other. Mend Remediate supports GitHub Enterprise Server, GitLab self-hosted, and Bitbucket Server.","title":"Mend Remediate"},{"location":"getting-started/running/#forking-renovate-app","text":"\"Forking Renovate\" is the sister app to the Mend Renovate App on GitHub.com. The difference is that Forking Renovate does not require write permissions to create branches within the repo, and instead submits PRs from its own fork. Because of how it works, it functions on public repositories only and additionally cannot support automerge capabilities. Install Forking Renovate from GitHub App .","title":"Forking Renovate app"},{"location":"getting-started/running/#benefits","text":"Forking Renovate needs only read level access to the code of any repository it runs on.","title":"Benefits"},{"location":"getting-started/running/#drawbacks","text":"If you use Forking Renovate, you'll miss out on these features of the regular Renovate app: Automerge is not supported The baseBranches config option is not supported The app dashboard ( app.renovatebot.com ) is currently not supported","title":"Drawbacks"},{"location":"getting-started/running/#hosting-renovate","text":"Once you have decided on a Renovate distribution, you need to decide where and how to run it. For the GitHub Action and GitLab Runner approaches, they will naturally run on their respective CI infrastructure. For the npm package approach or Docker images, you will need some form of VM or container infrastructure to run Renovate on. In all the above cases you will need to make sure that some form of cron-like capability exists to schedule when Renovate runs. In general we recommend to run Renovate hourly if possible. Mend Renovate On-Premises and Mend Remediate both run as long-lived containers so do not need any additional cron-like concept as it is built-in.","title":"Hosting Renovate"},{"location":"getting-started/running/#global-config","text":"Renovate's server-side/admin config is referred to as its \"global\" config, and can be specified using either a config file, environment variables, or CLI parameters. By default Renovate checks if a file named config.js is present. Any other ( *.js , *.json , *.json5 , *.yaml or *.yml ) file is supported, when you reference it with the RENOVATE_CONFIG_FILE environment variable (e.g. RENOVATE_CONFIG_FILE=config.yaml ). Some config is global-only, meaning that either it is only applicable to the bot administrator or it can only be controlled by the administrator and not repository users. Those are documented in Self-hosted Configuration . Your bot's global config can include both global as well as non-global configuration options, while user/repo config can only include non-global options. It is recommended to keep as much of the non-global config as possible in repo config files in order to provide maximum transparency to end users. If you are configuring using environment variables, there are two possibilities: Upper-cased, camel-cased, RENOVATE_ -prefixed single config options like RENOVATE_TOKEN=abc123 or RENOVATE_GIT_AUTHOR=a@b.com Set RENOVATE_CONFIG to a stringified version of the full JSON config, e.g. RENOVATE_CONFIG='{\"token\":\"abc123\",\"gitAuthor\":\"a@b.com\"}' If you combine both of the above then any single config option in the environment variable will override what's in RENOVATE_CONFIG . Note It's also possible to change the default prefix from RENOVATE_ using ENV_PREFIX . e.g. ENV_PREFIX=RNV_ RNV_TOKEN=abc123 renovate .","title":"Global config"},{"location":"getting-started/running/#using-configjs","text":"If you use a config.js , it will be expected to export a configuration via module.exports . The value can be either a plain JavaScript object like in this example where config.js exports a plain object: module . exports = { token : 'abcdefg' , }; config.js may also export a Promise of such an object, or a function that will return either a plain JavaScript object or a Promise of such an object. This allows one to include the results of asynchronous operations in the exported value. An example of a config.js that exports an async function (which is a function that returns a Promise ) can be seen in a comment for #10011: Allow autodiscover filtering for repo topic and more examples can be seen in file.spec.ts .","title":"Using config.js"},{"location":"getting-started/running/#authentication","text":"Regardless of platform, you need to select a user account for renovate to assume the identity of, and generate a Personal Access Token. We recommend you use @renovate-bot as username if you're on a self-hosted server where you can set all usernames. We also recommend you configure config.gitAuthor with the same identity as your Renovate user, e.g. like \"gitAuthor\": \"Renovate Bot <renovate@whitesourcesoftware.com>\" . Warning We recommend you use a single, dedicated username for your Renovate bot. Never share the Renovate username with your other bots, as this can cause flip-flopping.","title":"Authentication"},{"location":"getting-started/running/#docs","text":"Read the platform-specific docs to learn how to setup authentication on your platform: Azure DevOps Bitbucket Cloud Bitbucket Server Gitea github.com and GitHub Enterprise Server GitLab","title":"Docs"},{"location":"getting-started/running/#githubcom-token-for-release-notes","text":"If you are running on any platform except github.com, it's important to also configure the environment variable GITHUB_COM_TOKEN containing a Personal Access Token for github.com. This account can actually be any account on GitHub, and needs only read-only access. It's used when fetching release notes for repositories in order to increase the hourly API limit. It's also OK to configure the same as a host rule instead, if you prefer that. Note If you're using Renovate in a project where dependencies are loaded from github.com (such as Go modules hosted on GitHub) it is highly recommended to add a token. Otherwise you will exceed the rate limit from the github.com API, which will lead to Renovate closing and reopening PRs because it could not get reliable info on updated dependencies.","title":"GitHub.com token for release notes"},{"location":"getting-started/running/#self-hosting-examples","text":"For more examples on running Renovate self-hosted, please read our Self-hosted examples page.","title":"Self-hosting examples"},{"location":"getting-started/use-cases/","text":"Use Cases \u00b6 This page describes common use cases for Renovate. Development dependency updates \u00b6 The original use case, and the most popular one, is for developers to automate dependency updating in their software projects. Updating of package files \u00b6 We use the term \"package file\" to describe files which have references to dependencies. Package files are managed by a \"package manager\". Example package files include: package.json , managed by npm or Yarn Gemfile , managed by Bundler go.mod , managed by go modules How Renovate updates a package file \u00b6 Renovate: Scans your repositories to detect package files and their dependencies Checks if any newer versions exist Raises Pull Requests for available updates The Pull Requests patch the package files directly, and include Release Notes for the newer versions (if they are available). By default: You'll get separate Pull Requests for each dependency Major updates are kept separate from non-major updates Package managers with lock files \u00b6 Many package managers support \"lock files\", which \"freeze\" the entire dependency tree including transitive dependencies. npm, Yarn, Bundler, Composer, Poetry, Pipenv, and Cargo all support or use lock files. If you use a lock file then changes to your package file must come with a compatible change to the lock file. Renovate can patch/update package files directly, but a lock file is too complex to \"reverse engineer\". This is why Renovate lets the package manager do the lock file update. A simplified example: The repository has a package.json and package-lock.json with version 1.0.0 of a dependency Renovate sees that version 1.1.0 is available Renovate patches the package.json to change the dependency's version from 1.0.0 to 1.1.0 Renovate runs npm install to let npm update the package-lock.json Renovate commits the package.json and package-lock.json Renovate creates the PR Custom dependency extraction \u00b6 Renovate supports 60+ types of package files. Not all dependencies are detected by default, this can be because: The package manager/file format is not supported, or The file format is not a standard or is proprietary If your dependencies are not detected by default, you can use our \"regex\" manager to set your own custom patterns to extract dependencies. You configure the regex manager by telling it: Which file pattern(s) to match How to find the dependency name and version from within the file Which datasource (e.g. Docker registry, npm registry, etc) to use to look up new versions The end result is that Renovate can keep dependencies in custom file formats up-to-date as long as the dependency datasource is known to Renovate. DevOps tooling \u00b6 Renovate is increasingly used for purposes which are traditionally described as DevOps instead of Developer. DevOps / Infrastructure as Code updates \u00b6 It's common for repositories to have DevOps-related files like CI/CD configs, or \"Infrastructure as Code\" (IaC) files. Examples of IaC files are Docker, Kubernetes or Terraform files. Renovate handles IaC files as \"package managers\" and \"package files\" and can detect and update them. Docker-compatible images \u00b6 Docker-compatible images are a key building block of modern software. These images are commonly found in CI/CD pipeline configs or referenced in IaC files. Renovate finds these IaC files and then searches Docker registries to see if there are newer tags or digests. Tag-based updating \u00b6 An example of tag-based updating are node images from Docker Hub. The node images use these tag formats: 14.17.4 14.17.4-alpine3.11 Renovate understands both formats and raises updates like these: From 14.17.4 to 14.17.5 From 14.17.4-alpine3.11 to 14.17.5-alpine3.11 Docker digests \u00b6 You can check and update versions like 14.17.4 yourself. But looking up image digests like 341976f40d963a425d627a349a9b0034e1eafffbf4c82a173c1465ee403878d9 and updating them yourself doesn't scale. So let Renovate update your Docker digests. You can even configure Renovate to \"pin\" your Docker digests. When you're using tag+digest based images, you'll have immutable builds. Internal package updates \u00b6 Your company typically has dozens of repositories, if not hundreds or thousands. These repositories usually rely on other repositories and may have upstream or downstream internal dependencies. In such cases, it is best practice to: Update downstream links as soon as possible, and Keep internal version use as consistent as possible You can use Renovate to follow this best practice. Renovate finds and updates internal dependencies just like external or Open Source dependencies. Example of internal package update \u00b6 We automatically update our documentation site with Renovate bot. We use Renovate's git submodule support to do this. Our main repository renovatebot/renovate has most of the Markdown documentation files The documentation build repository renovatebot/renovatebot.github.io has a submodule link to our main repository renovatebot/renovate Submodule updates are performed automatically whenever detected After the automatic update is merged, the documentation site is rebuilt and pushed live We also use Renovate's \"automerge\" feature. It allows us to automatically merge the submodule update without needing manual approval, manual merging, or even without getting a PR at all. Automerge is particularly useful for internal dependencies where it's best to use the approach of \"if it passes tests then merge it\". To learn more about \"automerge\" read the key concepts, automerge documentation. Advanced configuration \u00b6 The capabilities listed below are commonly needed for all the above use cases. Batched updates \u00b6 Renovate defaults to separating each dependency update into its own PR. But you may want to batch or \"group\" updates together. For example, group all patch updates into one PR or even all non-major updates together (patches and minor updates). You can configure batched updates by setting a groupName as part of packageRules . Scheduled updates \u00b6 You may want to limit the times when Renovate is allowed to raise updates. This reduces \"noise\" during your working hours, and reduces the chance of CI contention. You can tell Renovate to \"not bother you\" during times when you're using the CI resources, or want to focus on your work. You can set the time ranges during which Renovate creates updates in the schedule field. On-demand updates via Dependency Dashboard \u00b6 You can use Renovate's \"Dependency Dashboard\" on platforms which support dynamic Markdown checkboxes: GitHub GitLab Gitea When you enable the Dependency Dashboard, Renovate creates a \"Dependency Dashboard\" issue. This issue lists all updates which are pending, in progress, or were previously closed ignored. If you want to get an update ahead of schedule, or want to retry a previously closed update, you can click on the update's checkbox in the Dependency Dashboard. Dependency Dashboard Approval \u00b6 If you enable the Dependency Dashboard you can opt-in to a different workflow for some, or even all of your packages. We call this the \"Dependency Dashboard Approval\" workflow. Here's how it works: You tell Renovate which package updates need \"Dashboard Approval\" by setting a custom packageRule Renovate only raises updates for packages that need \"Dashboard Approval\" after you click on the corresponding checkbox on the dashboard Benefits of using Dependency Dashboard Approval \u00b6 Benefits of using Dependency Dashboard Approval: By not raising PRs automatically, it allows you to request updates on-demand when you're ready, and It offers you an alternative to permanently ignoring/disabling certain types of updates, like major updates When you use the Dependency Dashboard Approval workflow you have full visibility and control over your updates. Configuration presets \u00b6 You may run Renovate on many, or even all your repositories. This also means that you might want a similar config for all of your repositories. You can use configuration \"presets\" to avoid duplicating your configuration across your repositories. Configuration presets are JSON configuration files which are committed to repositories and then referenced from others. Renovate includes over 100 built-in presets, like the default recommended config:base preset. The typical workflow for a company is: Create a dedicated repository to store the company's default Renovate settings Set that repository as the default extends value when onboarding new repositories This means that repositories get the centralized config by default, and any changes made to the centralized config repository are propagated to other repositories immediately.","title":"Use Cases"},{"location":"getting-started/use-cases/#use-cases","text":"This page describes common use cases for Renovate.","title":"Use Cases"},{"location":"getting-started/use-cases/#development-dependency-updates","text":"The original use case, and the most popular one, is for developers to automate dependency updating in their software projects.","title":"Development dependency updates"},{"location":"getting-started/use-cases/#updating-of-package-files","text":"We use the term \"package file\" to describe files which have references to dependencies. Package files are managed by a \"package manager\". Example package files include: package.json , managed by npm or Yarn Gemfile , managed by Bundler go.mod , managed by go modules","title":"Updating of package files"},{"location":"getting-started/use-cases/#how-renovate-updates-a-package-file","text":"Renovate: Scans your repositories to detect package files and their dependencies Checks if any newer versions exist Raises Pull Requests for available updates The Pull Requests patch the package files directly, and include Release Notes for the newer versions (if they are available). By default: You'll get separate Pull Requests for each dependency Major updates are kept separate from non-major updates","title":"How Renovate updates a package file"},{"location":"getting-started/use-cases/#package-managers-with-lock-files","text":"Many package managers support \"lock files\", which \"freeze\" the entire dependency tree including transitive dependencies. npm, Yarn, Bundler, Composer, Poetry, Pipenv, and Cargo all support or use lock files. If you use a lock file then changes to your package file must come with a compatible change to the lock file. Renovate can patch/update package files directly, but a lock file is too complex to \"reverse engineer\". This is why Renovate lets the package manager do the lock file update. A simplified example: The repository has a package.json and package-lock.json with version 1.0.0 of a dependency Renovate sees that version 1.1.0 is available Renovate patches the package.json to change the dependency's version from 1.0.0 to 1.1.0 Renovate runs npm install to let npm update the package-lock.json Renovate commits the package.json and package-lock.json Renovate creates the PR","title":"Package managers with lock files"},{"location":"getting-started/use-cases/#custom-dependency-extraction","text":"Renovate supports 60+ types of package files. Not all dependencies are detected by default, this can be because: The package manager/file format is not supported, or The file format is not a standard or is proprietary If your dependencies are not detected by default, you can use our \"regex\" manager to set your own custom patterns to extract dependencies. You configure the regex manager by telling it: Which file pattern(s) to match How to find the dependency name and version from within the file Which datasource (e.g. Docker registry, npm registry, etc) to use to look up new versions The end result is that Renovate can keep dependencies in custom file formats up-to-date as long as the dependency datasource is known to Renovate.","title":"Custom dependency extraction"},{"location":"getting-started/use-cases/#devops-tooling","text":"Renovate is increasingly used for purposes which are traditionally described as DevOps instead of Developer.","title":"DevOps tooling"},{"location":"getting-started/use-cases/#devops-infrastructure-as-code-updates","text":"It's common for repositories to have DevOps-related files like CI/CD configs, or \"Infrastructure as Code\" (IaC) files. Examples of IaC files are Docker, Kubernetes or Terraform files. Renovate handles IaC files as \"package managers\" and \"package files\" and can detect and update them.","title":"DevOps / Infrastructure as Code updates"},{"location":"getting-started/use-cases/#docker-compatible-images","text":"Docker-compatible images are a key building block of modern software. These images are commonly found in CI/CD pipeline configs or referenced in IaC files. Renovate finds these IaC files and then searches Docker registries to see if there are newer tags or digests.","title":"Docker-compatible images"},{"location":"getting-started/use-cases/#tag-based-updating","text":"An example of tag-based updating are node images from Docker Hub. The node images use these tag formats: 14.17.4 14.17.4-alpine3.11 Renovate understands both formats and raises updates like these: From 14.17.4 to 14.17.5 From 14.17.4-alpine3.11 to 14.17.5-alpine3.11","title":"Tag-based updating"},{"location":"getting-started/use-cases/#docker-digests","text":"You can check and update versions like 14.17.4 yourself. But looking up image digests like 341976f40d963a425d627a349a9b0034e1eafffbf4c82a173c1465ee403878d9 and updating them yourself doesn't scale. So let Renovate update your Docker digests. You can even configure Renovate to \"pin\" your Docker digests. When you're using tag+digest based images, you'll have immutable builds.","title":"Docker digests"},{"location":"getting-started/use-cases/#internal-package-updates","text":"Your company typically has dozens of repositories, if not hundreds or thousands. These repositories usually rely on other repositories and may have upstream or downstream internal dependencies. In such cases, it is best practice to: Update downstream links as soon as possible, and Keep internal version use as consistent as possible You can use Renovate to follow this best practice. Renovate finds and updates internal dependencies just like external or Open Source dependencies.","title":"Internal package updates"},{"location":"getting-started/use-cases/#example-of-internal-package-update","text":"We automatically update our documentation site with Renovate bot. We use Renovate's git submodule support to do this. Our main repository renovatebot/renovate has most of the Markdown documentation files The documentation build repository renovatebot/renovatebot.github.io has a submodule link to our main repository renovatebot/renovate Submodule updates are performed automatically whenever detected After the automatic update is merged, the documentation site is rebuilt and pushed live We also use Renovate's \"automerge\" feature. It allows us to automatically merge the submodule update without needing manual approval, manual merging, or even without getting a PR at all. Automerge is particularly useful for internal dependencies where it's best to use the approach of \"if it passes tests then merge it\". To learn more about \"automerge\" read the key concepts, automerge documentation.","title":"Example of internal package update"},{"location":"getting-started/use-cases/#advanced-configuration","text":"The capabilities listed below are commonly needed for all the above use cases.","title":"Advanced configuration"},{"location":"getting-started/use-cases/#batched-updates","text":"Renovate defaults to separating each dependency update into its own PR. But you may want to batch or \"group\" updates together. For example, group all patch updates into one PR or even all non-major updates together (patches and minor updates). You can configure batched updates by setting a groupName as part of packageRules .","title":"Batched updates"},{"location":"getting-started/use-cases/#scheduled-updates","text":"You may want to limit the times when Renovate is allowed to raise updates. This reduces \"noise\" during your working hours, and reduces the chance of CI contention. You can tell Renovate to \"not bother you\" during times when you're using the CI resources, or want to focus on your work. You can set the time ranges during which Renovate creates updates in the schedule field.","title":"Scheduled updates"},{"location":"getting-started/use-cases/#on-demand-updates-via-dependency-dashboard","text":"You can use Renovate's \"Dependency Dashboard\" on platforms which support dynamic Markdown checkboxes: GitHub GitLab Gitea When you enable the Dependency Dashboard, Renovate creates a \"Dependency Dashboard\" issue. This issue lists all updates which are pending, in progress, or were previously closed ignored. If you want to get an update ahead of schedule, or want to retry a previously closed update, you can click on the update's checkbox in the Dependency Dashboard.","title":"On-demand updates via Dependency Dashboard"},{"location":"getting-started/use-cases/#dependency-dashboard-approval","text":"If you enable the Dependency Dashboard you can opt-in to a different workflow for some, or even all of your packages. We call this the \"Dependency Dashboard Approval\" workflow. Here's how it works: You tell Renovate which package updates need \"Dashboard Approval\" by setting a custom packageRule Renovate only raises updates for packages that need \"Dashboard Approval\" after you click on the corresponding checkbox on the dashboard","title":"Dependency Dashboard Approval"},{"location":"getting-started/use-cases/#benefits-of-using-dependency-dashboard-approval","text":"Benefits of using Dependency Dashboard Approval: By not raising PRs automatically, it allows you to request updates on-demand when you're ready, and It offers you an alternative to permanently ignoring/disabling certain types of updates, like major updates When you use the Dependency Dashboard Approval workflow you have full visibility and control over your updates.","title":"Benefits of using Dependency Dashboard Approval"},{"location":"getting-started/use-cases/#configuration-presets","text":"You may run Renovate on many, or even all your repositories. This also means that you might want a similar config for all of your repositories. You can use configuration \"presets\" to avoid duplicating your configuration across your repositories. Configuration presets are JSON configuration files which are committed to repositories and then referenced from others. Renovate includes over 100 built-in presets, like the default recommended config:base preset. The typical workflow for a company is: Create a dedicated repository to store the company's default Renovate settings Set that repository as the default extends value when onboarding new repositories This means that repositories get the centralized config by default, and any changes made to the centralized config repository are propagated to other repositories immediately.","title":"Configuration presets"},{"location":"key-concepts/automerge/","text":"Introduction \u00b6 Automerging is a Renovate feature that you can use to automate upgrading dependencies. When enabled, Renovate tries to merge the proposed update once the tests pass. Keep in mind that Renovate automerges take a bit of time, do not expect Renovate to automerge a PR the second it opens and passes tests. Wait for at least an hour or two before troubleshooting to ensure that Renovate has had the time to run once in a state where tests have passed and the branch is up-to-date with its base branch. If you or others keep committing to the default branch then Renovate cannot find a suitable gap to automerge into! Once a branch is automerged, the \"Git state\" needs to be recalculated for every remaining branch. At times, merging one branch could result in another branch's updates being changed or even removed as unnecessary. Renovate's approach is to ensure that automerging branches are up-to-date with their target branch before automerging. This means merging multiple branches in a row won't work reliably, so we prefer not to do that. What all this means is that Renovate will only automerge at most one branch/PR per target branch per run, before you need to wait for the next run. As a general guide, we recommend that you enable automerge for any type of dependency updates where you would just click \"merge\" anyway. For any updates where you want to review the release notes - or code - before you merge, you can keep automerge disabled. Automerge works particularly well for devDependencies as well as for production dependencies in projects which have great test coverage. For example, if you have Jest or Mocha as a development dependency, and it has an upgrade with passing tests... automerge them! If you have a linter like ESLint or TSLint and its update passes... automerge them! If you have an API with 100% test coverage and Express is updated... automerge it! Configuration examples \u00b6 Automerge lock file maintenance \u00b6 The lowest risk type of update to automerge is probably lockFileMaintenance . When Renovate performs lock file maintenance, it leaves the project dependency definitions unchanged, but refreshes the lock file completely so that the latest versions according to the package file constraints are installed. Here is an example of automerging lock file maintenance: { \"lockFileMaintenance\" : { \"enabled\" : true , \"automerge\" : true } } Automerge lint tool updates \u00b6 Automerging lint tool updates can be a real time-saver. Sometimes an update to a lint tool or plugin definition causes tests to fail, and that is usually deliberate/intentional because the lint authors have added a new rule that you need to adhere to. But in many cases the new version(s) will pass tests, and if so then there's really nothing else to consider before merging, so they may as well be automerged: { \"packageRules\" : [ { \"matchDepTypes\" : [ \"devDependencies\" ], \"matchPackagePatterns\" : [ \"lint\" , \"prettier\" ], \"automerge\" : true } ] } Automerge non-major updates \u00b6 Non-major updates in SemVer ecosystems shouldn't have breaking changes (if they follow the spec), so many users enable automerge for these too: { \"packageRules\" : [ { \"matchUpdateTypes\" : [ \"minor\" , \"patch\" ], \"matchCurrentVersion\" : \"!/^0/\" , \"automerge\" : true } ] } The matchCurrentVersion setting above is a rule to exclude any dependencies which are pre-1.0.0 because those can make breaking changes at any time according to the SemVer spec. Automerging and scheduling \u00b6 Automerging is particularly beneficial if you have configured a schedule, because Renovate on its own may be able to automerge the majority of your updates. And this is especially so if your repository needs rebasing, like when you use lock files. Let's say you have dependencies abc and xyz with upgrades, and you use a yarn.lock file. At the start of the schedule, Renovate will create branches for abc and xyz upgrades, including yarn.lock updates After abc passes tests, Renovate will automerge it into the base branch The xyz branch has a yarn.lock conflict now Renovate will immediately check all other branches and rebase them The change to xyz branch will trigger another round of CI tests After the updated xyz branch passes, Renovate will automerge it too This is a lot better than you waking up to two PRs and then having to deal with conflicts yourself after you merge the first one. Branch vs PR automerging \u00b6 Even if you automerge PRs, you are likely to still get notification noise - one when the PR is created and another when it is merged. For this reason we recommend you consider setting automergeType=branch which will mean: Renovate first creates a branch and no PR If tests pass, Renovate pushes a commit directly to the base branch without PR If tests fail, Renovate raises a PR for you to review Add the renovate/** branch to your testing workflow files, or Renovate will not work properly with the automergeType=branch setting. The result is that passing updates are essentially \"silent\" - the only sign of them are the commits Renovate pushes to your base branch. If you have enabled branch protection which prevents Renovate from automerging directly to the base branch, then this won't work and you should stick with the default PR-based automerging instead. Assignees and Reviewers \u00b6 When automerge is enabled on a PR, Renovate will not add assignees or reviewers at PR creation time, in order to decrease notifications noise a little. If tests subsequently fail , making automerge not possible, then Renovate will add the configured assignees and/or reviewers. Frequent problems and how to resolve them \u00b6 Automerge not enabled correctly in config \u00b6 Sometimes, the reason Renovate is not automerging a PR is because of a configuration mistake. You can confirm that Renovate knows you want it to automerge by checking if the PR body includes the text \"Automerge: Enabled\". If you see \"Automerge: Disabled by config\" it means you need to make a config change for automerge to work. Absence of tests \u00b6 By default, Renovate will not automerge until it sees passing status checks / check runs for the branch. If you have no tests but still want Renovate to automerge, you need to add \"ignoreTests\": true to your configuration. Tip We strongly recommend you have tests in any project where you are regularly updating dependencies. Committer restrictions \u00b6 If you have protected your base branch with a list of allowed committers, and Renovate is not on that list, then naturally automerge can't work. Pull Requests Required \u00b6 If you have configured your project to require Pull Requests before merging, it means that branch automerging is not possible, even if Renovate has rights to commit to the base branch. Required Pull Request reviews \u00b6 If you have mandatory Pull Request reviews then it means Renovate can't automerge its own PR until such a review has happened. If you are running the hosted Mend Renovate App on github.com , you can also install the helper apps renovate-approve and renovate-approve-2 and they will mark all automerging Pull Requests by Renovate as approved. These approval helper apps are only available for GitHub. Codeowners \u00b6 Depending on the platform, having a CODEOWNERS file could block automerging, because it means a code owner must review the PR. Overriding global automerge \u00b6 You might have setup a global configuration in a .github repository, that has a renovate.json file that turns on automerge for certain dependencies. It does not matter where you've put the global config, the important point in this example is that you're extending from a global config that's somewhere else. For this example we'll assume you put your config in a repository on GitHub, called .github . Repositories in the organization all extend from this global configuration, and so they \"inherit\" the automerge settings as well. To turn off automerge for all dependencies of a selected repository, you need to make a config that overrides all packageRules in the repository's renovate.json file, like this: { \"$schema\" : \"https://docs.renovatebot.com/renovate-schema.json\" , \"extends\" : [ \"local>org-name/.github:renovate-config\" ], \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"*\" ], \"automerge\" : false } ] }","title":"Automerge"},{"location":"key-concepts/automerge/#introduction","text":"Automerging is a Renovate feature that you can use to automate upgrading dependencies. When enabled, Renovate tries to merge the proposed update once the tests pass. Keep in mind that Renovate automerges take a bit of time, do not expect Renovate to automerge a PR the second it opens and passes tests. Wait for at least an hour or two before troubleshooting to ensure that Renovate has had the time to run once in a state where tests have passed and the branch is up-to-date with its base branch. If you or others keep committing to the default branch then Renovate cannot find a suitable gap to automerge into! Once a branch is automerged, the \"Git state\" needs to be recalculated for every remaining branch. At times, merging one branch could result in another branch's updates being changed or even removed as unnecessary. Renovate's approach is to ensure that automerging branches are up-to-date with their target branch before automerging. This means merging multiple branches in a row won't work reliably, so we prefer not to do that. What all this means is that Renovate will only automerge at most one branch/PR per target branch per run, before you need to wait for the next run. As a general guide, we recommend that you enable automerge for any type of dependency updates where you would just click \"merge\" anyway. For any updates where you want to review the release notes - or code - before you merge, you can keep automerge disabled. Automerge works particularly well for devDependencies as well as for production dependencies in projects which have great test coverage. For example, if you have Jest or Mocha as a development dependency, and it has an upgrade with passing tests... automerge them! If you have a linter like ESLint or TSLint and its update passes... automerge them! If you have an API with 100% test coverage and Express is updated... automerge it!","title":"Introduction"},{"location":"key-concepts/automerge/#configuration-examples","text":"","title":"Configuration examples"},{"location":"key-concepts/automerge/#automerge-lock-file-maintenance","text":"The lowest risk type of update to automerge is probably lockFileMaintenance . When Renovate performs lock file maintenance, it leaves the project dependency definitions unchanged, but refreshes the lock file completely so that the latest versions according to the package file constraints are installed. Here is an example of automerging lock file maintenance: { \"lockFileMaintenance\" : { \"enabled\" : true , \"automerge\" : true } }","title":"Automerge lock file maintenance"},{"location":"key-concepts/automerge/#automerge-lint-tool-updates","text":"Automerging lint tool updates can be a real time-saver. Sometimes an update to a lint tool or plugin definition causes tests to fail, and that is usually deliberate/intentional because the lint authors have added a new rule that you need to adhere to. But in many cases the new version(s) will pass tests, and if so then there's really nothing else to consider before merging, so they may as well be automerged: { \"packageRules\" : [ { \"matchDepTypes\" : [ \"devDependencies\" ], \"matchPackagePatterns\" : [ \"lint\" , \"prettier\" ], \"automerge\" : true } ] }","title":"Automerge lint tool updates"},{"location":"key-concepts/automerge/#automerge-non-major-updates","text":"Non-major updates in SemVer ecosystems shouldn't have breaking changes (if they follow the spec), so many users enable automerge for these too: { \"packageRules\" : [ { \"matchUpdateTypes\" : [ \"minor\" , \"patch\" ], \"matchCurrentVersion\" : \"!/^0/\" , \"automerge\" : true } ] } The matchCurrentVersion setting above is a rule to exclude any dependencies which are pre-1.0.0 because those can make breaking changes at any time according to the SemVer spec.","title":"Automerge non-major updates"},{"location":"key-concepts/automerge/#automerging-and-scheduling","text":"Automerging is particularly beneficial if you have configured a schedule, because Renovate on its own may be able to automerge the majority of your updates. And this is especially so if your repository needs rebasing, like when you use lock files. Let's say you have dependencies abc and xyz with upgrades, and you use a yarn.lock file. At the start of the schedule, Renovate will create branches for abc and xyz upgrades, including yarn.lock updates After abc passes tests, Renovate will automerge it into the base branch The xyz branch has a yarn.lock conflict now Renovate will immediately check all other branches and rebase them The change to xyz branch will trigger another round of CI tests After the updated xyz branch passes, Renovate will automerge it too This is a lot better than you waking up to two PRs and then having to deal with conflicts yourself after you merge the first one.","title":"Automerging and scheduling"},{"location":"key-concepts/automerge/#branch-vs-pr-automerging","text":"Even if you automerge PRs, you are likely to still get notification noise - one when the PR is created and another when it is merged. For this reason we recommend you consider setting automergeType=branch which will mean: Renovate first creates a branch and no PR If tests pass, Renovate pushes a commit directly to the base branch without PR If tests fail, Renovate raises a PR for you to review Add the renovate/** branch to your testing workflow files, or Renovate will not work properly with the automergeType=branch setting. The result is that passing updates are essentially \"silent\" - the only sign of them are the commits Renovate pushes to your base branch. If you have enabled branch protection which prevents Renovate from automerging directly to the base branch, then this won't work and you should stick with the default PR-based automerging instead.","title":"Branch vs PR automerging"},{"location":"key-concepts/automerge/#assignees-and-reviewers","text":"When automerge is enabled on a PR, Renovate will not add assignees or reviewers at PR creation time, in order to decrease notifications noise a little. If tests subsequently fail , making automerge not possible, then Renovate will add the configured assignees and/or reviewers.","title":"Assignees and Reviewers"},{"location":"key-concepts/automerge/#frequent-problems-and-how-to-resolve-them","text":"","title":"Frequent problems and how to resolve them"},{"location":"key-concepts/automerge/#automerge-not-enabled-correctly-in-config","text":"Sometimes, the reason Renovate is not automerging a PR is because of a configuration mistake. You can confirm that Renovate knows you want it to automerge by checking if the PR body includes the text \"Automerge: Enabled\". If you see \"Automerge: Disabled by config\" it means you need to make a config change for automerge to work.","title":"Automerge not enabled correctly in config"},{"location":"key-concepts/automerge/#absence-of-tests","text":"By default, Renovate will not automerge until it sees passing status checks / check runs for the branch. If you have no tests but still want Renovate to automerge, you need to add \"ignoreTests\": true to your configuration. Tip We strongly recommend you have tests in any project where you are regularly updating dependencies.","title":"Absence of tests"},{"location":"key-concepts/automerge/#committer-restrictions","text":"If you have protected your base branch with a list of allowed committers, and Renovate is not on that list, then naturally automerge can't work.","title":"Committer restrictions"},{"location":"key-concepts/automerge/#pull-requests-required","text":"If you have configured your project to require Pull Requests before merging, it means that branch automerging is not possible, even if Renovate has rights to commit to the base branch.","title":"Pull Requests Required"},{"location":"key-concepts/automerge/#required-pull-request-reviews","text":"If you have mandatory Pull Request reviews then it means Renovate can't automerge its own PR until such a review has happened. If you are running the hosted Mend Renovate App on github.com , you can also install the helper apps renovate-approve and renovate-approve-2 and they will mark all automerging Pull Requests by Renovate as approved. These approval helper apps are only available for GitHub.","title":"Required Pull Request reviews"},{"location":"key-concepts/automerge/#codeowners","text":"Depending on the platform, having a CODEOWNERS file could block automerging, because it means a code owner must review the PR.","title":"Codeowners"},{"location":"key-concepts/automerge/#overriding-global-automerge","text":"You might have setup a global configuration in a .github repository, that has a renovate.json file that turns on automerge for certain dependencies. It does not matter where you've put the global config, the important point in this example is that you're extending from a global config that's somewhere else. For this example we'll assume you put your config in a repository on GitHub, called .github . Repositories in the organization all extend from this global configuration, and so they \"inherit\" the automerge settings as well. To turn off automerge for all dependencies of a selected repository, you need to make a config that overrides all packageRules in the repository's renovate.json file, like this: { \"$schema\" : \"https://docs.renovatebot.com/renovate-schema.json\" , \"extends\" : [ \"local>org-name/.github:renovate-config\" ], \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"*\" ], \"automerge\" : false } ] }","title":"Overriding global automerge"},{"location":"key-concepts/dashboard/","text":"Introduction \u00b6 Renovate has a Dependency Dashboard that shows an overview of the state of your repositories' dependencies. When the Dependency Dashboard is enabled, Renovate will create a new issue in the repository. This issue has a \"dashboard\" where you can get an overview of the status of all updates. Having the Dependency Dashboard also enables the concept of an \"approval\" workflow for new upgrades, either for selected dependencies (recommended) or even for all. Supported platforms \u00b6 The Dependency Dashboard requires that the host platforms supports the concept of issues with dynamic Markdown checkboxes. Read our FAQ, Renovate core features not supported on all platforms to see if your platform can use the Dependency Dashboard feature. How to enable the dashboard \u00b6 To turn on the Dashboard manually, add the :dependencyDashboard preset to your extends array in the Renovate configuration file: { \"extends\" : [ \"config:base\" , \":dependencyDashboard\" ] } Or set dependencyDashboard to true : { \"dependencyDashboard\" : true } How to disable the dashboard \u00b6 To disable the Dependency Dashboard, add the preset :disableDependencyDashboard or set dependencyDashboard to false . { \"extends\" : [ \"config:base\" , \":disableDependencyDashboard\" ] } Use cases \u00b6 This section explains some common use cases where having the Dependency Dashboard can help. Visibility into rejected/deferred updates \u00b6 Renovate's Dependency Dashboard shows an overview of all updates that are still \"to do\". If you close an update PR from Renovate without merging, the Dashboard will list this update in the Closed/Ignored section. If you later change your mind about the update, you can get a new PR by clicking the corresponding checkbox on the dashboard. Dependency Dashboard Approval workflow \u00b6 Sometimes you want Renovate to wait for your approval before creating an update PR. You can customize this \"wait for approval\" behavior however you like best. At a high level the options are: Require approval for all updates Require approval for a type of updates ( major for example) Require approval for specific packages You can mix and match these options as well. Require approval for all updates \u00b6 We do not recommend that you require approval for all updates. When you require prior approval, you need to check the dashboard issue regularly to check for important updates. You'll probably forget to check often enough, and out of sight means out of mind! Maybe you find Renovate too noisy, and want to opt-out of getting automatic updates whenever they're ready. In this case, you can tell Renovate to wait for your approval before making any pull requests. This means that you have full control over when you get updates. But vulnerability remediation PRs will still get created immediately without requiring approval. To require manual approval for all updates , add the :dependencyDashboardApproval presets to the extends array in your Renovate configuration file: { \"extends\" : [ \"config:base\" , \":dependencyDashboardApproval\" ] } Require approval for major updates \u00b6 Major updates often have breaking changes which require manual changes in your code before they can be merged. So maybe you only want to get major updates when you have sufficient time to check them carefully. Dependency Dashboard Approval is far superior to disabling major updates because at least you can fully see what's pending on the dashboard, instead of updates being totally invisible. If you want to require approval for major updates, set dependencyDashboardApproval to true within a major object: { \"major\" : { \"dependencyDashboardApproval\" : true } } Require approval for specific packages \u00b6 Sometimes you only want to update specific packages when you say so. Maybe a package doesn't follow Semantic Versioning, and has breaking changes on every new release, so you want to update on your terms. Or maybe you have a package that updates too rapidly for you to keep up with, and you want to update once in a while manually. If you want to approve specific packages, set dependencyDashboardApproval to true within a packageRules entry where you have defined a specific package or pattern. { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"^@somescope\" ], \"dependencyDashboardApproval\" : true } ] }","title":"Dependency Dashboard"},{"location":"key-concepts/dashboard/#introduction","text":"Renovate has a Dependency Dashboard that shows an overview of the state of your repositories' dependencies. When the Dependency Dashboard is enabled, Renovate will create a new issue in the repository. This issue has a \"dashboard\" where you can get an overview of the status of all updates. Having the Dependency Dashboard also enables the concept of an \"approval\" workflow for new upgrades, either for selected dependencies (recommended) or even for all.","title":"Introduction"},{"location":"key-concepts/dashboard/#supported-platforms","text":"The Dependency Dashboard requires that the host platforms supports the concept of issues with dynamic Markdown checkboxes. Read our FAQ, Renovate core features not supported on all platforms to see if your platform can use the Dependency Dashboard feature.","title":"Supported platforms"},{"location":"key-concepts/dashboard/#how-to-enable-the-dashboard","text":"To turn on the Dashboard manually, add the :dependencyDashboard preset to your extends array in the Renovate configuration file: { \"extends\" : [ \"config:base\" , \":dependencyDashboard\" ] } Or set dependencyDashboard to true : { \"dependencyDashboard\" : true }","title":"How to enable the dashboard"},{"location":"key-concepts/dashboard/#how-to-disable-the-dashboard","text":"To disable the Dependency Dashboard, add the preset :disableDependencyDashboard or set dependencyDashboard to false . { \"extends\" : [ \"config:base\" , \":disableDependencyDashboard\" ] }","title":"How to disable the dashboard"},{"location":"key-concepts/dashboard/#use-cases","text":"This section explains some common use cases where having the Dependency Dashboard can help.","title":"Use cases"},{"location":"key-concepts/dashboard/#visibility-into-rejecteddeferred-updates","text":"Renovate's Dependency Dashboard shows an overview of all updates that are still \"to do\". If you close an update PR from Renovate without merging, the Dashboard will list this update in the Closed/Ignored section. If you later change your mind about the update, you can get a new PR by clicking the corresponding checkbox on the dashboard.","title":"Visibility into rejected/deferred updates"},{"location":"key-concepts/dashboard/#dependency-dashboard-approval-workflow","text":"Sometimes you want Renovate to wait for your approval before creating an update PR. You can customize this \"wait for approval\" behavior however you like best. At a high level the options are: Require approval for all updates Require approval for a type of updates ( major for example) Require approval for specific packages You can mix and match these options as well.","title":"Dependency Dashboard Approval workflow"},{"location":"key-concepts/dashboard/#require-approval-for-all-updates","text":"We do not recommend that you require approval for all updates. When you require prior approval, you need to check the dashboard issue regularly to check for important updates. You'll probably forget to check often enough, and out of sight means out of mind! Maybe you find Renovate too noisy, and want to opt-out of getting automatic updates whenever they're ready. In this case, you can tell Renovate to wait for your approval before making any pull requests. This means that you have full control over when you get updates. But vulnerability remediation PRs will still get created immediately without requiring approval. To require manual approval for all updates , add the :dependencyDashboardApproval presets to the extends array in your Renovate configuration file: { \"extends\" : [ \"config:base\" , \":dependencyDashboardApproval\" ] }","title":"Require approval for all updates"},{"location":"key-concepts/dashboard/#require-approval-for-major-updates","text":"Major updates often have breaking changes which require manual changes in your code before they can be merged. So maybe you only want to get major updates when you have sufficient time to check them carefully. Dependency Dashboard Approval is far superior to disabling major updates because at least you can fully see what's pending on the dashboard, instead of updates being totally invisible. If you want to require approval for major updates, set dependencyDashboardApproval to true within a major object: { \"major\" : { \"dependencyDashboardApproval\" : true } }","title":"Require approval for major updates"},{"location":"key-concepts/dashboard/#require-approval-for-specific-packages","text":"Sometimes you only want to update specific packages when you say so. Maybe a package doesn't follow Semantic Versioning, and has breaking changes on every new release, so you want to update on your terms. Or maybe you have a package that updates too rapidly for you to keep up with, and you want to update once in a while manually. If you want to approve specific packages, set dependencyDashboardApproval to true within a packageRules entry where you have defined a specific package or pattern. { \"packageRules\" : [ { \"matchPackagePatterns\" : [ \"^@somescope\" ], \"dependencyDashboardApproval\" : true } ] }","title":"Require approval for specific packages"},{"location":"key-concepts/presets/","text":"This document describes Renovate configuration presets and why you should use them. To learn how to create your own presets, how to host them, and how to extend from presets read the Shareable Config Presets page. Why you should use presets \u00b6 Use presets to: Set up the bot with good default settings Reduce duplication of your configuration Share your configuration with others Use somebody else's configuration and extend it with your own rules Managing config for many repositories \u00b6 If you manage Renovate for many repositories, then you should create a global preset configuration. Then you extend the global preset in each repository. This way you have all global configuration in a single file, in a single repository. Presets are modular \u00b6 Preset configs are modular, they can be as small as a single package rule or as large as an entire configuration, just like an ESLint config. Built-in presets \u00b6 Renovate comes with a lot of built-in presets that you can use. Browse Renovate's default presets to find any that are useful to you. Once you find a preset you like, put it in an extends array in your config file. Summary \u00b6 In short: Browse Renovate's default presets to find any that are useful to you Publish your own if you wish to reuse them across repositories","title":"Presets"},{"location":"key-concepts/presets/#why-you-should-use-presets","text":"Use presets to: Set up the bot with good default settings Reduce duplication of your configuration Share your configuration with others Use somebody else's configuration and extend it with your own rules","title":"Why you should use presets"},{"location":"key-concepts/presets/#managing-config-for-many-repositories","text":"If you manage Renovate for many repositories, then you should create a global preset configuration. Then you extend the global preset in each repository. This way you have all global configuration in a single file, in a single repository.","title":"Managing config for many repositories"},{"location":"key-concepts/presets/#presets-are-modular","text":"Preset configs are modular, they can be as small as a single package rule or as large as an entire configuration, just like an ESLint config.","title":"Presets are modular"},{"location":"key-concepts/presets/#built-in-presets","text":"Renovate comes with a lot of built-in presets that you can use. Browse Renovate's default presets to find any that are useful to you. Once you find a preset you like, put it in an extends array in your config file.","title":"Built-in presets"},{"location":"key-concepts/presets/#summary","text":"In short: Browse Renovate's default presets to find any that are useful to you Publish your own if you wish to reuse them across repositories","title":"Summary"},{"location":"key-concepts/scheduling/","text":"This document describes Renovate's scheduling. Default behavior \u00b6 By default, Renovate bot runs as often as its administrator has configured it to (e.g. hourly, daily, etc.). The exact frequency at which Renovate can process individual repositories depends on the combination of how often it runs, how many repositories are installed, and whether there's a lot of work to be done in each repository (e.g. if a commonly used dependency has recently gotten a new update, which triggers a lot of PRs to be created). By default, Renovate schedules use the UTC timezone. You can override the default timezone by setting your own timezone config option. Global schedule vs specific schedule \u00b6 When we talk about scheduling Renovate, there are 2 senses in which you can schedule Renovate: A global sense: when the bot is allowed to do work at all. This is determined by the bot admin using tools such as cron A specific sense: when Renovate is allowed to look for updates to a specific dependency While as an end user you may think of scheduling in terms of when you allow it to raise updates, it's important to remember that such updates can only occur if the bot gets the opportunity to run within the schedule window you provide. Because Renovate defaults to \"always on\" and \"open PRs right away\" it can be overwhelming your repository with notifications of new PRs. To reduce overwhelm, we provide scheduling tools. You may want to update certain repositories less often, or you may even want to use different schedules for specific packages. Scheduling use cases \u00b6 Some common reasons to schedule when Renovate runs: Make Renovate run outside office hours, to free up continuous integration resources for developers during the day Get updates for certain packages on a regular interval instead of right away Reduce Renovate bot PR notifications during the day Customizing the schedule \u00b6 You can customize when Renovate runs, by using the timezone and schedule configuration options. At a high level you need to follow these steps: Tell Renovate what timezone you want to use Learn about the scheduling syntax Optional: configure a \"in repository schedule\" Optional: create packageRules with a custom schedule for specific packages Setting your timezone \u00b6 By default, Renovate schedules use the UTC timezone. If you want Renovate to use your local time, use the timezone configuration option. The timezone must be a valid IANA time zone . You can set a specific time zone in your local config file like this: { \"timezone\" : \"America/Los_Angeles\" } Read our docs on the timezone configuration option. Scheduling syntax \u00b6 After you've set your local timezone, you can define \"days of the week\" or \"hours of the day\" in which Renovate is allowed to make changes. Examples of the kind of schedules you can create include: every weekend before 5:00am [after 10pm, before 5:00am] [after 10pm every weekday, before 5am every weekday] on friday and saturday Warning Renovate does not support scheduled minutes or \"at an exact time\" granularity. Granularity must be at least one hour. Renovate uses the @breejs/later library to parse the text, so Renovate is limited to that library's syntax support. Read the parser documentation at breejs.github.io/later/parsers.html#text for more details. The @breejs/later library also handles the concepts of \"days\", time_before\", and \"time_after\". In repository schedule configuration \u00b6 Reminder: the times when the Renovate process runs are controlled by the bot admin using tools such as cron . If you use the GitHub hosted app, the default is that Renovate will always be allowed to run. Be sure to schedule enough time for Renovate to process your repository. Do not set schedules like \"Run Renovate for an hour each Sunday\" as you will run into problems. Say you want Renovate bot to run each day before 2 am: { \"schedule\" : [ \"before 2am\" ] } Or you could tell Renovate to run outside of common office hours like this: { \"schedule\" : [ \"after 10pm every weekday\" , \"before 5am every weekday\" , \"every weekend\" ] } Schedule presets \u00b6 Renovate has preset schedules that you might want to use, go to Schedule Presets to see them. These preset schedules only affect when Renovate bot checks for updates, and do not affect any specific dependencies/packages. Schedule when to update specific dependencies \u00b6 The scheduling feature can be very useful for \"noisy\" packages that are updated frequently, such as aws-sdk . Say you want to restrict aws-sdk to weekly updates, you would create this package rule: { \"packageRules\" : [ { \"matchPackageNames\" : [ \"aws-sdk\" ], \"schedule\" : [ \"after 9pm on sunday\" ] } ] } The \"schedule\" property must always be defined in an array, even if you only set a single schedule. Multiple entries in the array means \"or\". Read the schedule config option documentation to earn more.","title":"Renovate Scheduling"},{"location":"key-concepts/scheduling/#default-behavior","text":"By default, Renovate bot runs as often as its administrator has configured it to (e.g. hourly, daily, etc.). The exact frequency at which Renovate can process individual repositories depends on the combination of how often it runs, how many repositories are installed, and whether there's a lot of work to be done in each repository (e.g. if a commonly used dependency has recently gotten a new update, which triggers a lot of PRs to be created). By default, Renovate schedules use the UTC timezone. You can override the default timezone by setting your own timezone config option.","title":"Default behavior"},{"location":"key-concepts/scheduling/#global-schedule-vs-specific-schedule","text":"When we talk about scheduling Renovate, there are 2 senses in which you can schedule Renovate: A global sense: when the bot is allowed to do work at all. This is determined by the bot admin using tools such as cron A specific sense: when Renovate is allowed to look for updates to a specific dependency While as an end user you may think of scheduling in terms of when you allow it to raise updates, it's important to remember that such updates can only occur if the bot gets the opportunity to run within the schedule window you provide. Because Renovate defaults to \"always on\" and \"open PRs right away\" it can be overwhelming your repository with notifications of new PRs. To reduce overwhelm, we provide scheduling tools. You may want to update certain repositories less often, or you may even want to use different schedules for specific packages.","title":"Global schedule vs specific schedule"},{"location":"key-concepts/scheduling/#scheduling-use-cases","text":"Some common reasons to schedule when Renovate runs: Make Renovate run outside office hours, to free up continuous integration resources for developers during the day Get updates for certain packages on a regular interval instead of right away Reduce Renovate bot PR notifications during the day","title":"Scheduling use cases"},{"location":"key-concepts/scheduling/#customizing-the-schedule","text":"You can customize when Renovate runs, by using the timezone and schedule configuration options. At a high level you need to follow these steps: Tell Renovate what timezone you want to use Learn about the scheduling syntax Optional: configure a \"in repository schedule\" Optional: create packageRules with a custom schedule for specific packages","title":"Customizing the schedule"},{"location":"key-concepts/scheduling/#setting-your-timezone","text":"By default, Renovate schedules use the UTC timezone. If you want Renovate to use your local time, use the timezone configuration option. The timezone must be a valid IANA time zone . You can set a specific time zone in your local config file like this: { \"timezone\" : \"America/Los_Angeles\" } Read our docs on the timezone configuration option.","title":"Setting your timezone"},{"location":"key-concepts/scheduling/#scheduling-syntax","text":"After you've set your local timezone, you can define \"days of the week\" or \"hours of the day\" in which Renovate is allowed to make changes. Examples of the kind of schedules you can create include: every weekend before 5:00am [after 10pm, before 5:00am] [after 10pm every weekday, before 5am every weekday] on friday and saturday Warning Renovate does not support scheduled minutes or \"at an exact time\" granularity. Granularity must be at least one hour. Renovate uses the @breejs/later library to parse the text, so Renovate is limited to that library's syntax support. Read the parser documentation at breejs.github.io/later/parsers.html#text for more details. The @breejs/later library also handles the concepts of \"days\", time_before\", and \"time_after\".","title":"Scheduling syntax"},{"location":"key-concepts/scheduling/#in-repository-schedule-configuration","text":"Reminder: the times when the Renovate process runs are controlled by the bot admin using tools such as cron . If you use the GitHub hosted app, the default is that Renovate will always be allowed to run. Be sure to schedule enough time for Renovate to process your repository. Do not set schedules like \"Run Renovate for an hour each Sunday\" as you will run into problems. Say you want Renovate bot to run each day before 2 am: { \"schedule\" : [ \"before 2am\" ] } Or you could tell Renovate to run outside of common office hours like this: { \"schedule\" : [ \"after 10pm every weekday\" , \"before 5am every weekday\" , \"every weekend\" ] }","title":"In repository schedule configuration"},{"location":"key-concepts/scheduling/#schedule-presets","text":"Renovate has preset schedules that you might want to use, go to Schedule Presets to see them. These preset schedules only affect when Renovate bot checks for updates, and do not affect any specific dependencies/packages.","title":"Schedule presets"},{"location":"key-concepts/scheduling/#schedule-when-to-update-specific-dependencies","text":"The scheduling feature can be very useful for \"noisy\" packages that are updated frequently, such as aws-sdk . Say you want to restrict aws-sdk to weekly updates, you would create this package rule: { \"packageRules\" : [ { \"matchPackageNames\" : [ \"aws-sdk\" ], \"schedule\" : [ \"after 9pm on sunday\" ] } ] } The \"schedule\" property must always be defined in an array, even if you only set a single schedule. Multiple entries in the array means \"or\". Read the schedule config option documentation to earn more.","title":"Schedule when to update specific dependencies"},{"location":"modules/datasource/","text":"Datasources \u00b6 After Renovate's manager scanned the files and extracted the dependencies, it assigns a datasource to each extracted package file or dependency. The datasource tells Renovate how to search for new versions. You don't need to configure or override datasources. But you may use datasources in a packageRules array to configure Renovate's behavior, for example: { \"packageRules\" : [ { \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"lodash\" ], \"automerge\" : true } ] } Supported Datasources \u00b6 Supported values for datasource are: adoptium-java , artifactory , aws-machine-image , bitbucket-tags , cdnjs , clojure , conan , conda , crate , dart , docker , flutter-version , galaxy , galaxy-collection , git-refs , git-tags , github-releases , github-tags , gitlab-packages , gitlab-releases , gitlab-tags , go , golang-version , gradle-version , helm , hex , jenkins-plugins , maven , node , npm , nuget , orb , packagist , pod , pypi , repology , ruby-version , rubygems , sbt-package , sbt-plugin , terraform-module , terraform-provider . Adoptium Java Datasource \u00b6 Identifier : adoptium-java Description : This datasource returns releases from Adoptium API. It uses image_type=<jre|jdk>&project=jdk&release_type=ga&sort_method=DATE&sort_order=DESC&vendor=adoptium as filter parameters. It only uses the first 50 pages with 50 items per page. Use java-jdk or java as packageName to get releases which come with the Java Development Kit. Use java-jre as packageName if you only want releases which come with the Java Runtime Environment. Currently only the LTS releases of Java come with the JRE. Artifactory Datasource \u00b6 Identifier : artifactory Description : Artifactory is the recommended registry for Conan packages. This datasource returns releases from given custom registryUrl (s). The target URL is composed by the registryUrl and the packageName , which defaults to depName when packageName is not defined. The release timestamp is taken from the date in the directory listing, and is assumed to be in UTC time. Aws Machine Image Datasource \u00b6 Identifier : aws-machine-image Description : Warning This datasource is experimental. Its syntax and behavior may change at any time! This datasource returns the latest Amazon Machine Image via the AWS API. Because the datasource uses the AWS-SDK for JavaScript, you can configure it like other AWS Tools. You can use common AWS configuration options, for example (partial list): Setting the region via AWS_REGION (environment variable) or your ~/.aws/config file Provide credentials via AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY (environment variable) or your ~/.aws/credentials file Select the profile to use via AWS_PROFILE environment variable Read the Developer guide for more information on configuration options. The least IAM privileges required for this datasource are: { \"Sid\" : \"AllowEc2ImageLookup\" , \"Effect\" : \"Allow\" , \"Action\" : [ \"ec2:DescribeImages\" ], \"Resource\" : \"*\" } Read the AWS IAM Reference for more information. Because there is no general packageName , you have to use the describe images filter as minified JSON as a packageName . Example: # Getting the latest official EKS image from AWS (account '602401143452' for eu-central-1) for EKS 1.21 (name matches 'amazon-eks-node-1.21-*') would look as a describe images filter like: [ { \"Name\" : \"owner-id\" , \"Values\" : [ \"602401143452\" ] }, { \"Name\" : \"name\" , \"Values\" : [ \"amazon-eks-node-1.21-*\" ] } ] # In order to use it with this datasource, you have to minify it: [{ \"Name\" : \"owner-id\" , \"Values\" :[ \"602401143452\" ]},{ \"Name\" : \"name\" , \"Values\" :[ \"amazon-eks-node-1.21-*\" ]}] At the moment, this datasource has no \"manager\". You have to use the regex manager for this. Usage Example Here's an example of using the regex manager: module . exports = { regexManagers : [ { fileMatch : [ '.*' ], matchStrings : [ '.*amiFilter=(?<packageName>.*?)\\n(.*currentImageName=(?<currentDigest>.*?)\\n)?(.*\\n)?.*?(?<depName>[a-zA-Z0-9-_:]*)[ ]*?[:|=][ ]*?[\"|\\']?(?<currentValue>ami-[a-z0-9]{17})[\"|\\']?.*' , ], datasourceTemplate : 'aws-machine-image' , versioningTemplate : 'aws-machine-image' , }, ], }; Or as JSON: { 'regexManagers' : [ { 'fileMatch' : [ '.*' ], 'matchStrings' : [ \".*amiFilter=(?<packageName>.*?)\\n(.*currentImageName=(?<currentDigest>.*?)\\n)?(.*\\n)?.*?(?<depName>[a-zA-Z0-9-_:]*)[ ]*?[:|=][ ]*?[\\\"|']?(?<currentValue>ami-[a-z0-9]{17})[\\\"|']?.*\" , ], 'datasourceTemplate' : 'aws-machine-image' , 'versioningTemplate' : 'aws-machine-image' , }, ], } This would match every file, and would recognize the following lines: # With AMI name mentioned in the comments # amiFilter=[{\"Name\":\"owner-id\",\"Values\":[\"602401143452\"]},{\"Name\":\"name\",\"Values\":[\"amazon-eks-node-1.21-*\"]}] # currentImageName=unknown my_ami1 : ami-02ce3d9008cab69cb # Only AMI, no name mentioned # amiFilter=[{\"Name\":\"owner-id\",\"Values\":[\"602401143452\"]},{\"Name\":\"name\",\"Values\":[\"amazon-eks-node-1.20-*\"]}] # currentImageName=unknown my_ami2 : ami-0083e9407e275acf2 const myConfigObject = { // With AMI name mentioned in the comments // amiFilter=[{\"Name\":\"owner-id\",\"Values\":[\"602401143452\"]},{\"Name\":\"name\",\"Values\":[\"amazon-eks-node-1.21-*\"]}] // currentImageName=unknown my_ami1 : 'ami-02ce3d9008cab69cb' , }; /** * Only AMI, no AMI name mentioned * amiFilter=[{\"Name\":\"owner-id\",\"Values\":[\"602401143452\"]},{\"Name\":\"name\",\"Values\":[\"amazon-eks-node-1.20-*\"]}] * currentImageName=unknown */ const my_ami2 = 'ami-0083e9407e275acf2' ; resource \"aws_instance\" \"web\" { # Only AMI, no name mentioned # amiFilter=[{\"Name\":\"owner-id\",\"Values\":[\"602401143452\"]},{\"Name\":\"name\",\"Values\":[\"amazon-eks-node-1.20-*\"]}] # currentImageName=unknown ami = \"ami-0083e9407e275acf2\" count = 2 source_dest_check = false connection { user = \"root\" } } Default configuration : { \"commitMessageExtra\" : \"to {{{newVersion}}}\" , \"prBodyColumns\" : [ \"Change\" , \"Image\" ], \"prBodyDefinitions\" : { \"Image\" : \"```{{{newDigest}}}```\" }, \"digest\" : { \"commitMessageExtra\" : \"to {{{newDigest}}}\" , \"prBodyColumns\" : [ \"Image\" ], \"prBodyDefinitions\" : { \"Image\" : \"```{{{newDigest}}}```\" } } } Bitbucket Tags Datasource \u00b6 Identifier : bitbucket-tags Cdnjs Datasource \u00b6 Identifier : cdnjs Clojure Datasource \u00b6 Identifier : clojure Conan Datasource \u00b6 Identifier : conan Conda Datasource \u00b6 Identifier : conda Description : This datasource returns releases from the specified conda registry. The default registry is https://api.anaconda.org/package/ , which queries a specific conda channel for a specific package. Use channel/packageName as your depName when using this datasource. Crate Datasource \u00b6 Identifier : crate Dart Datasource \u00b6 Identifier : dart Docker Datasource \u00b6 Identifier : docker Description : This datasource identifies an image's source repository according to the pre-defined annotation keys of the OCI Image Format Specification . This datasource looks for the metadata of the latest stable image found on the Docker registry and uses the value of the label org.opencontainers.image.source and org.label-schema.vcs-url as the sourceUrl . The Label Schema is superseded by OCI annotations, use the org.opencontainers.image.source label if possible. If you maintain a Docker image and want Renovate to find your changelogs, add a org.opencontainers.image.source field to your Dockerfile. The link must point to your GitHub or GitLab repository. Here's an example from our renovate/renovate Dockerfile: LABEL org.opencontainers.image.source = \"https://github.com/renovatebot/renovate\" Flutter Version Datasource \u00b6 Identifier : flutter-version Galaxy Datasource \u00b6 Identifier : galaxy Galaxy Collection Datasource \u00b6 Identifier : galaxy-collection Git Refs Datasource \u00b6 Identifier : git-refs Git Tags Datasource \u00b6 Identifier : git-tags Github Releases Datasource \u00b6 Identifier : github-releases Github Tags Datasource \u00b6 Identifier : github-tags Gitlab Packages Datasource \u00b6 Identifier : gitlab-packages Description : GitLab Packages API supports looking up package versions from all types of packages registry supported by GitLab and can be used in combination with regex managers to keep dependencies up-to-date which are not specifically supported by Renovate. To specify which specific repository should be queried when looking up a package, the depName should be formed with the project path first, then a : and finally the package name. As an example, gitlab-org/ci-cd/package-stage/feature-testing/new-packages-list:@gitlab-org/nk-js would look for the @gitlab-org/nk-js packages in the generic packages repository of the gitlab-org/ci-cd/package-stage/feature-testing/new-packages-list project. If you are using a self-hosted GitLab instance, please note the following requirements: If you are on the Free edition, this datasource requires at least GitLab 13.3 If you are on the Premium or the Ultimate edition, this datasource requires at least GitLab 11.8, but GitLab 12.9 or more is recommended if you have a lot of packages with different names in the same project Usage Example A real-world example for this specific datasource would be maintaining package versions in a config file. This can be achieved by configuring a generic regex manager in renovate.json for files named versions.ini : { \"regexManagers\" : [ { \"fileMatch\" : [ \"^versions.ini$\" ], \"matchStrings\" : [ \"# renovate: datasource=(?<datasource>.*?) depName=(?<depName>.*?)( versioning=(?<versioning>.*?))?( registryUrl=(?<registryUrl>.*?))?\\\\s.*?_VERSION=(?<currentValue>.*)\\\\s\" ], \"versioningTemplate\" : \"{{#if versioning}}{{{versioning}}}{{else}}semver{{/if}}\" } ] } Now you may use comments in your versions.ini files to automatically update dependencies, which could look like this: # renovate: datasource=gitlab-packages depName=gitlab-org/ci-cd/package-stage/feature-testing/new-packages-list:@gitlab-org/nk-js versioning=semver registryUrl=https://gitlab.com NKJS_VERSION = 3.4.0 By default, gitlab-packages uses the docker versioning scheme. Gitlab Releases Datasource \u00b6 Identifier : gitlab-releases Gitlab Tags Datasource \u00b6 Identifier : gitlab-tags Go Datasource \u00b6 Identifier : go Golang Version Datasource \u00b6 Identifier : golang-version Gradle Version Datasource \u00b6 Identifier : gradle-version Helm Datasource \u00b6 Identifier : helm Default configuration : { \"commitMessageTopic\" : \"Helm release {{depName}}\" , \"group\" : { \"commitMessageTopic\" : \"{{{groupName}}} Helm releases\" } } Hex Datasource \u00b6 Identifier : hex Jenkins Plugins Datasource \u00b6 Identifier : jenkins-plugins Maven Datasource \u00b6 Identifier : maven Node Datasource \u00b6 Identifier : node Description : This datasource returns NodeJS releases from nodejs.org API. Npm Datasource \u00b6 Identifier : npm Nuget Datasource \u00b6 Identifier : nuget Orb Datasource \u00b6 Identifier : orb Packagist Datasource \u00b6 Identifier : packagist Pod Datasource \u00b6 Identifier : pod Pypi Datasource \u00b6 Identifier : pypi Repology Datasource \u00b6 Identifier : repology Description : Repology supports looking up package versions from a wide variety of package repositories and can be used in combination with regex managers to keep dependencies up-to-date which are not specifically supported by Renovate. To specify which specific repository should be queried when looking up a package, the packageName has to have the repository identifier and the package name itself, separated by a slash. As an example, alpine_3_12/gcc would look for a binary or source package called gcc within the alpine_3_12 repository. A list of all supported repositories can be found on the Repology homepage. To determine the correct identifier, click on a repository of your choice and make note of the identifier in the URL: https://repology.org/repository/<identifier> As an example, the Alpine Linux 3.12 repository points to https://repology.org/repository/alpine_3_12 and therefor has the repository identifier alpine_3_12 . Usage Example A real world example for this specific datasource would be maintaining system packages within a Dockerfile, as this allows to specifically pin each dependency without having to manually keep the versions up-to-date. This can be achieved by configuring a generic regex manager in renovate.json for files named Dockerfile : { \"regexManagers\" : [ { \"fileMatch\" : [ \"^Dockerfile$\" ], \"matchStrings\" : [ \"#\\\\s*renovate:\\\\s*datasource=(?<datasource>.*?) depName=(?<depName>.*?)( versioning=(?<versioning>.*?))?\\\\sENV .*?_VERSION=\\\"(?<currentValue>.*)\\\"\\\\s\" ], \"versioningTemplate\" : \"{{#if versioning}}{{{versioning}}}{{else}}semver{{/if}}\" } ] } Now you may use regular comments in your Dockerfile to automatically update dependencies, which could look like this: FROM alpine:3.12.0@sha256:a15790640a6690aa1730c38cf0a440e2aa44aaca9b0e8931a9f2b0d7cc90fd65 # renovate: datasource=repology depName=alpine_3_12/gcc versioning=loose ENV GCC_VERSION = \"9.3.0-r2\" # renovate: datasource=repology depName=alpine_3_12/musl-dev versioning=loose ENV MUSL_DEV_VERSION = \"1.1.24-r8\" RUN apk add --no-cache \\ gcc = \" ${ GCC_VERSION } \" \\ musl-dev = \" ${ MUSL_DEV_VERSION } \" It is often wise to use the loose versioning for distribution packages as the version number usually does not strictly match the semver specification which is used by default. Now whenever the OS package for gcc of Alpine Linux 3.12 is being updated, Renovate will automatically adjust the value of the environment variable to the newest version. Ruby Version Datasource \u00b6 Identifier : ruby-version Rubygems Datasource \u00b6 Identifier : rubygems Sbt Package Datasource \u00b6 Identifier : sbt-package Sbt Plugin Datasource \u00b6 Identifier : sbt-plugin Terraform Module Datasource \u00b6 Identifier : terraform-module Terraform Provider Datasource \u00b6 Identifier : terraform-provider","title":"Datasources"},{"location":"modules/datasource/#datasources","text":"After Renovate's manager scanned the files and extracted the dependencies, it assigns a datasource to each extracted package file or dependency. The datasource tells Renovate how to search for new versions. You don't need to configure or override datasources. But you may use datasources in a packageRules array to configure Renovate's behavior, for example: { \"packageRules\" : [ { \"matchDatasources\" : [ \"npm\" ], \"matchPackageNames\" : [ \"lodash\" ], \"automerge\" : true } ] }","title":"Datasources"},{"location":"modules/datasource/#supported-datasources","text":"Supported values for datasource are: adoptium-java , artifactory , aws-machine-image , bitbucket-tags , cdnjs , clojure , conan , conda , crate , dart , docker , flutter-version , galaxy , galaxy-collection , git-refs , git-tags , github-releases , github-tags , gitlab-packages , gitlab-releases , gitlab-tags , go , golang-version , gradle-version , helm , hex , jenkins-plugins , maven , node , npm , nuget , orb , packagist , pod , pypi , repology , ruby-version , rubygems , sbt-package , sbt-plugin , terraform-module , terraform-provider .","title":"Supported Datasources"},{"location":"modules/datasource/#adoptium-java-datasource","text":"Identifier : adoptium-java Description : This datasource returns releases from Adoptium API. It uses image_type=<jre|jdk>&project=jdk&release_type=ga&sort_method=DATE&sort_order=DESC&vendor=adoptium as filter parameters. It only uses the first 50 pages with 50 items per page. Use java-jdk or java as packageName to get releases which come with the Java Development Kit. Use java-jre as packageName if you only want releases which come with the Java Runtime Environment. Currently only the LTS releases of Java come with the JRE.","title":"Adoptium Java Datasource"},{"location":"modules/datasource/#artifactory-datasource","text":"Identifier : artifactory Description : Artifactory is the recommended registry for Conan packages. This datasource returns releases from given custom registryUrl (s). The target URL is composed by the registryUrl and the packageName , which defaults to depName when packageName is not defined. The release timestamp is taken from the date in the directory listing, and is assumed to be in UTC time.","title":"Artifactory Datasource"},{"location":"modules/datasource/#aws-machine-image-datasource","text":"Identifier : aws-machine-image Description : Warning This datasource is experimental. Its syntax and behavior may change at any time! This datasource returns the latest Amazon Machine Image via the AWS API. Because the datasource uses the AWS-SDK for JavaScript, you can configure it like other AWS Tools. You can use common AWS configuration options, for example (partial list): Setting the region via AWS_REGION (environment variable) or your ~/.aws/config file Provide credentials via AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY (environment variable) or your ~/.aws/credentials file Select the profile to use via AWS_PROFILE environment variable Read the Developer guide for more information on configuration options. The least IAM privileges required for this datasource are: { \"Sid\" : \"AllowEc2ImageLookup\" , \"Effect\" : \"Allow\" , \"Action\" : [ \"ec2:DescribeImages\" ], \"Resource\" : \"*\" } Read the AWS IAM Reference for more information. Because there is no general packageName , you have to use the describe images filter as minified JSON as a packageName . Example: # Getting the latest official EKS image from AWS (account '602401143452' for eu-central-1) for EKS 1.21 (name matches 'amazon-eks-node-1.21-*') would look as a describe images filter like: [ { \"Name\" : \"owner-id\" , \"Values\" : [ \"602401143452\" ] }, { \"Name\" : \"name\" , \"Values\" : [ \"amazon-eks-node-1.21-*\" ] } ] # In order to use it with this datasource, you have to minify it: [{ \"Name\" : \"owner-id\" , \"Values\" :[ \"602401143452\" ]},{ \"Name\" : \"name\" , \"Values\" :[ \"amazon-eks-node-1.21-*\" ]}] At the moment, this datasource has no \"manager\". You have to use the regex manager for this. Usage Example Here's an example of using the regex manager: module . exports = { regexManagers : [ { fileMatch : [ '.*' ], matchStrings : [ '.*amiFilter=(?<packageName>.*?)\\n(.*currentImageName=(?<currentDigest>.*?)\\n)?(.*\\n)?.*?(?<depName>[a-zA-Z0-9-_:]*)[ ]*?[:|=][ ]*?[\"|\\']?(?<currentValue>ami-[a-z0-9]{17})[\"|\\']?.*' , ], datasourceTemplate : 'aws-machine-image' , versioningTemplate : 'aws-machine-image' , }, ], }; Or as JSON: { 'regexManagers' : [ { 'fileMatch' : [ '.*' ], 'matchStrings' : [ \".*amiFilter=(?<packageName>.*?)\\n(.*currentImageName=(?<currentDigest>.*?)\\n)?(.*\\n)?.*?(?<depName>[a-zA-Z0-9-_:]*)[ ]*?[:|=][ ]*?[\\\"|']?(?<currentValue>ami-[a-z0-9]{17})[\\\"|']?.*\" , ], 'datasourceTemplate' : 'aws-machine-image' , 'versioningTemplate' : 'aws-machine-image' , }, ], } This would match every file, and would recognize the following lines: # With AMI name mentioned in the comments # amiFilter=[{\"Name\":\"owner-id\",\"Values\":[\"602401143452\"]},{\"Name\":\"name\",\"Values\":[\"amazon-eks-node-1.21-*\"]}] # currentImageName=unknown my_ami1 : ami-02ce3d9008cab69cb # Only AMI, no name mentioned # amiFilter=[{\"Name\":\"owner-id\",\"Values\":[\"602401143452\"]},{\"Name\":\"name\",\"Values\":[\"amazon-eks-node-1.20-*\"]}] # currentImageName=unknown my_ami2 : ami-0083e9407e275acf2 const myConfigObject = { // With AMI name mentioned in the comments // amiFilter=[{\"Name\":\"owner-id\",\"Values\":[\"602401143452\"]},{\"Name\":\"name\",\"Values\":[\"amazon-eks-node-1.21-*\"]}] // currentImageName=unknown my_ami1 : 'ami-02ce3d9008cab69cb' , }; /** * Only AMI, no AMI name mentioned * amiFilter=[{\"Name\":\"owner-id\",\"Values\":[\"602401143452\"]},{\"Name\":\"name\",\"Values\":[\"amazon-eks-node-1.20-*\"]}] * currentImageName=unknown */ const my_ami2 = 'ami-0083e9407e275acf2' ; resource \"aws_instance\" \"web\" { # Only AMI, no name mentioned # amiFilter=[{\"Name\":\"owner-id\",\"Values\":[\"602401143452\"]},{\"Name\":\"name\",\"Values\":[\"amazon-eks-node-1.20-*\"]}] # currentImageName=unknown ami = \"ami-0083e9407e275acf2\" count = 2 source_dest_check = false connection { user = \"root\" } } Default configuration : { \"commitMessageExtra\" : \"to {{{newVersion}}}\" , \"prBodyColumns\" : [ \"Change\" , \"Image\" ], \"prBodyDefinitions\" : { \"Image\" : \"```{{{newDigest}}}```\" }, \"digest\" : { \"commitMessageExtra\" : \"to {{{newDigest}}}\" , \"prBodyColumns\" : [ \"Image\" ], \"prBodyDefinitions\" : { \"Image\" : \"```{{{newDigest}}}```\" } } }","title":"Aws Machine Image Datasource"},{"location":"modules/datasource/#bitbucket-tags-datasource","text":"Identifier : bitbucket-tags","title":"Bitbucket Tags Datasource"},{"location":"modules/datasource/#cdnjs-datasource","text":"Identifier : cdnjs","title":"Cdnjs Datasource"},{"location":"modules/datasource/#clojure-datasource","text":"Identifier : clojure","title":"Clojure Datasource"},{"location":"modules/datasource/#conan-datasource","text":"Identifier : conan","title":"Conan Datasource"},{"location":"modules/datasource/#conda-datasource","text":"Identifier : conda Description : This datasource returns releases from the specified conda registry. The default registry is https://api.anaconda.org/package/ , which queries a specific conda channel for a specific package. Use channel/packageName as your depName when using this datasource.","title":"Conda Datasource"},{"location":"modules/datasource/#crate-datasource","text":"Identifier : crate","title":"Crate Datasource"},{"location":"modules/datasource/#dart-datasource","text":"Identifier : dart","title":"Dart Datasource"},{"location":"modules/datasource/#docker-datasource","text":"Identifier : docker Description : This datasource identifies an image's source repository according to the pre-defined annotation keys of the OCI Image Format Specification . This datasource looks for the metadata of the latest stable image found on the Docker registry and uses the value of the label org.opencontainers.image.source and org.label-schema.vcs-url as the sourceUrl . The Label Schema is superseded by OCI annotations, use the org.opencontainers.image.source label if possible. If you maintain a Docker image and want Renovate to find your changelogs, add a org.opencontainers.image.source field to your Dockerfile. The link must point to your GitHub or GitLab repository. Here's an example from our renovate/renovate Dockerfile: LABEL org.opencontainers.image.source = \"https://github.com/renovatebot/renovate\"","title":"Docker Datasource"},{"location":"modules/datasource/#flutter-version-datasource","text":"Identifier : flutter-version","title":"Flutter Version Datasource"},{"location":"modules/datasource/#galaxy-datasource","text":"Identifier : galaxy","title":"Galaxy Datasource"},{"location":"modules/datasource/#galaxy-collection-datasource","text":"Identifier : galaxy-collection","title":"Galaxy Collection Datasource"},{"location":"modules/datasource/#git-refs-datasource","text":"Identifier : git-refs","title":"Git Refs Datasource"},{"location":"modules/datasource/#git-tags-datasource","text":"Identifier : git-tags","title":"Git Tags Datasource"},{"location":"modules/datasource/#github-releases-datasource","text":"Identifier : github-releases","title":"Github Releases Datasource"},{"location":"modules/datasource/#github-tags-datasource","text":"Identifier : github-tags","title":"Github Tags Datasource"},{"location":"modules/datasource/#gitlab-packages-datasource","text":"Identifier : gitlab-packages Description : GitLab Packages API supports looking up package versions from all types of packages registry supported by GitLab and can be used in combination with regex managers to keep dependencies up-to-date which are not specifically supported by Renovate. To specify which specific repository should be queried when looking up a package, the depName should be formed with the project path first, then a : and finally the package name. As an example, gitlab-org/ci-cd/package-stage/feature-testing/new-packages-list:@gitlab-org/nk-js would look for the @gitlab-org/nk-js packages in the generic packages repository of the gitlab-org/ci-cd/package-stage/feature-testing/new-packages-list project. If you are using a self-hosted GitLab instance, please note the following requirements: If you are on the Free edition, this datasource requires at least GitLab 13.3 If you are on the Premium or the Ultimate edition, this datasource requires at least GitLab 11.8, but GitLab 12.9 or more is recommended if you have a lot of packages with different names in the same project Usage Example A real-world example for this specific datasource would be maintaining package versions in a config file. This can be achieved by configuring a generic regex manager in renovate.json for files named versions.ini : { \"regexManagers\" : [ { \"fileMatch\" : [ \"^versions.ini$\" ], \"matchStrings\" : [ \"# renovate: datasource=(?<datasource>.*?) depName=(?<depName>.*?)( versioning=(?<versioning>.*?))?( registryUrl=(?<registryUrl>.*?))?\\\\s.*?_VERSION=(?<currentValue>.*)\\\\s\" ], \"versioningTemplate\" : \"{{#if versioning}}{{{versioning}}}{{else}}semver{{/if}}\" } ] } Now you may use comments in your versions.ini files to automatically update dependencies, which could look like this: # renovate: datasource=gitlab-packages depName=gitlab-org/ci-cd/package-stage/feature-testing/new-packages-list:@gitlab-org/nk-js versioning=semver registryUrl=https://gitlab.com NKJS_VERSION = 3.4.0 By default, gitlab-packages uses the docker versioning scheme.","title":"Gitlab Packages Datasource"},{"location":"modules/datasource/#gitlab-releases-datasource","text":"Identifier : gitlab-releases","title":"Gitlab Releases Datasource"},{"location":"modules/datasource/#gitlab-tags-datasource","text":"Identifier : gitlab-tags","title":"Gitlab Tags Datasource"},{"location":"modules/datasource/#go-datasource","text":"Identifier : go","title":"Go Datasource"},{"location":"modules/datasource/#golang-version-datasource","text":"Identifier : golang-version","title":"Golang Version Datasource"},{"location":"modules/datasource/#gradle-version-datasource","text":"Identifier : gradle-version","title":"Gradle Version Datasource"},{"location":"modules/datasource/#helm-datasource","text":"Identifier : helm Default configuration : { \"commitMessageTopic\" : \"Helm release {{depName}}\" , \"group\" : { \"commitMessageTopic\" : \"{{{groupName}}} Helm releases\" } }","title":"Helm Datasource"},{"location":"modules/datasource/#hex-datasource","text":"Identifier : hex","title":"Hex Datasource"},{"location":"modules/datasource/#jenkins-plugins-datasource","text":"Identifier : jenkins-plugins","title":"Jenkins Plugins Datasource"},{"location":"modules/datasource/#maven-datasource","text":"Identifier : maven","title":"Maven Datasource"},{"location":"modules/datasource/#node-datasource","text":"Identifier : node Description : This datasource returns NodeJS releases from nodejs.org API.","title":"Node Datasource"},{"location":"modules/datasource/#npm-datasource","text":"Identifier : npm","title":"Npm Datasource"},{"location":"modules/datasource/#nuget-datasource","text":"Identifier : nuget","title":"Nuget Datasource"},{"location":"modules/datasource/#orb-datasource","text":"Identifier : orb","title":"Orb Datasource"},{"location":"modules/datasource/#packagist-datasource","text":"Identifier : packagist","title":"Packagist Datasource"},{"location":"modules/datasource/#pod-datasource","text":"Identifier : pod","title":"Pod Datasource"},{"location":"modules/datasource/#pypi-datasource","text":"Identifier : pypi","title":"Pypi Datasource"},{"location":"modules/datasource/#repology-datasource","text":"Identifier : repology Description : Repology supports looking up package versions from a wide variety of package repositories and can be used in combination with regex managers to keep dependencies up-to-date which are not specifically supported by Renovate. To specify which specific repository should be queried when looking up a package, the packageName has to have the repository identifier and the package name itself, separated by a slash. As an example, alpine_3_12/gcc would look for a binary or source package called gcc within the alpine_3_12 repository. A list of all supported repositories can be found on the Repology homepage. To determine the correct identifier, click on a repository of your choice and make note of the identifier in the URL: https://repology.org/repository/<identifier> As an example, the Alpine Linux 3.12 repository points to https://repology.org/repository/alpine_3_12 and therefor has the repository identifier alpine_3_12 . Usage Example A real world example for this specific datasource would be maintaining system packages within a Dockerfile, as this allows to specifically pin each dependency without having to manually keep the versions up-to-date. This can be achieved by configuring a generic regex manager in renovate.json for files named Dockerfile : { \"regexManagers\" : [ { \"fileMatch\" : [ \"^Dockerfile$\" ], \"matchStrings\" : [ \"#\\\\s*renovate:\\\\s*datasource=(?<datasource>.*?) depName=(?<depName>.*?)( versioning=(?<versioning>.*?))?\\\\sENV .*?_VERSION=\\\"(?<currentValue>.*)\\\"\\\\s\" ], \"versioningTemplate\" : \"{{#if versioning}}{{{versioning}}}{{else}}semver{{/if}}\" } ] } Now you may use regular comments in your Dockerfile to automatically update dependencies, which could look like this: FROM alpine:3.12.0@sha256:a15790640a6690aa1730c38cf0a440e2aa44aaca9b0e8931a9f2b0d7cc90fd65 # renovate: datasource=repology depName=alpine_3_12/gcc versioning=loose ENV GCC_VERSION = \"9.3.0-r2\" # renovate: datasource=repology depName=alpine_3_12/musl-dev versioning=loose ENV MUSL_DEV_VERSION = \"1.1.24-r8\" RUN apk add --no-cache \\ gcc = \" ${ GCC_VERSION } \" \\ musl-dev = \" ${ MUSL_DEV_VERSION } \" It is often wise to use the loose versioning for distribution packages as the version number usually does not strictly match the semver specification which is used by default. Now whenever the OS package for gcc of Alpine Linux 3.12 is being updated, Renovate will automatically adjust the value of the environment variable to the newest version.","title":"Repology Datasource"},{"location":"modules/datasource/#ruby-version-datasource","text":"Identifier : ruby-version","title":"Ruby Version Datasource"},{"location":"modules/datasource/#rubygems-datasource","text":"Identifier : rubygems","title":"Rubygems Datasource"},{"location":"modules/datasource/#sbt-package-datasource","text":"Identifier : sbt-package","title":"Sbt Package Datasource"},{"location":"modules/datasource/#sbt-plugin-datasource","text":"Identifier : sbt-plugin","title":"Sbt Plugin Datasource"},{"location":"modules/datasource/#terraform-module-datasource","text":"Identifier : terraform-module","title":"Terraform Module Datasource"},{"location":"modules/datasource/#terraform-provider-datasource","text":"Identifier : terraform-provider","title":"Terraform Provider Datasource"},{"location":"modules/manager/","text":"Managers \u00b6 Renovate is based around the concept of \"package managers\", or \"managers\" for short. These range from traditional package managers like npm, Bundler and Composer through to less traditional concepts like CircleCI or Travis config files. The goal of Renovate is to detect and maintain all third-party dependencies in your repositories, through the use of managers. Supported Managers \u00b6 docker : ansible , docker-compose , dockerfile , droneci , gitlabci , kubernetes dotnet : cake , nuget elixir : mix golang : gomod java : gradle , maven js : meteor , npm node : nodenv , nvm , travis php : composer python : pip-compile , pip_requirements , pip_setup , pipenv , poetry , pyenv , setup-cfg ruby : bundler , ruby-version rust : cargo other : ansible-galaxy , argocd , azure-pipelines , batect , batect-wrapper , bazel , bitbucket-pipelines , buildkite , cdnurl , circleci , cloudbuild , cocoapods , conan , deps-edn , flux , fvm , git-submodules , github-actions , gitlabci-include , gradle-wrapper , helm-requirements , helm-values , helmfile , helmsman , helmv3 , homebrew , html , jenkins , jsonnet-bundler , kustomize , leiningen , pre-commit , pub , regex , sbt , swift , terraform , terraform-version , terragrunt , terragrunt-version , velaci Configuring Managers \u00b6 File Matching \u00b6 Most managers have a default fileMatch array. The fileMatch array has regular expression strings that match against the repository file list. Managers with no default fileMatch \u00b6 Some managers have no default fileMatch regular expression, because they have no filename convention that would let Renovate intelligently filter them. In such a case, the manager will be disabled until you create a fileMatch regular expression, e.g. like the following: { \"kubernetes\" : { \"fileMatch\" : [ \"^config/.*\\\\.yaml$\" ] } } Extending a manager's default fileMatch \u00b6 If the default fileMatch regular expression for a manager does not match against one of your relevant files, you can extend the existing regular expression(s) by configuring a manager's fileMatch like in this example: { \"dockerfile\" : { \"fileMatch\" : [ \"does-not-look-like-a-docker-file\" ] } } Ignoring files that match the default fileMatch \u00b6 Renovate will extend the existing fileMatch , meaning you don't need to include the default regular expressions like Dockerfile in your own array. In other words, the regular expression are \"additive\". If a manager matches a file that you don't want it to, ignore it using the ignorePaths configuration option. Also, if you ever find that Renovate is not matching a file name that you're certain it should, check your preset config isn't the cause of it. The config:base preset ignores common test and example directory names, for example. Enabling and disabling managers \u00b6 Enabling experimental managers \u00b6 Most managers are enabled by default. For those that aren't, typically because they are considered experimental, you can opt-in manually. If there was a manager called some-new-manager you would enable it like this: { \"some-new-manager\" : { \"enabled\" : true } } Disabling managers \u00b6 To disable a specific manager like gradle , do this: { \"gradle\" : { \"enabled\" : false } } To disable all managers within a language like python , do this: { \"python\" : { \"enabled\" : false } } Only languages declared by a Renovate manager are supported. Please check the list of supported managers . Limiting enabled managers \u00b6 Say you only want to use Renovate for JavaScript packages, and to update your Dockerfile, and don't want any other updates. You can use the enabledManagers array, to list the managers you want to use ( npm , dockerfile ): { \"enabledManagers\" : [ \"npm\" , \"dockerfile\" ] } Using the enabledManagers array disables all other managers, this includes Bundler, Composer, Docker Compose, etc.","title":"Managers"},{"location":"modules/manager/#managers","text":"Renovate is based around the concept of \"package managers\", or \"managers\" for short. These range from traditional package managers like npm, Bundler and Composer through to less traditional concepts like CircleCI or Travis config files. The goal of Renovate is to detect and maintain all third-party dependencies in your repositories, through the use of managers.","title":"Managers"},{"location":"modules/manager/#supported-managers","text":"docker : ansible , docker-compose , dockerfile , droneci , gitlabci , kubernetes dotnet : cake , nuget elixir : mix golang : gomod java : gradle , maven js : meteor , npm node : nodenv , nvm , travis php : composer python : pip-compile , pip_requirements , pip_setup , pipenv , poetry , pyenv , setup-cfg ruby : bundler , ruby-version rust : cargo other : ansible-galaxy , argocd , azure-pipelines , batect , batect-wrapper , bazel , bitbucket-pipelines , buildkite , cdnurl , circleci , cloudbuild , cocoapods , conan , deps-edn , flux , fvm , git-submodules , github-actions , gitlabci-include , gradle-wrapper , helm-requirements , helm-values , helmfile , helmsman , helmv3 , homebrew , html , jenkins , jsonnet-bundler , kustomize , leiningen , pre-commit , pub , regex , sbt , swift , terraform , terraform-version , terragrunt , terragrunt-version , velaci","title":"Supported Managers"},{"location":"modules/manager/#configuring-managers","text":"","title":"Configuring Managers"},{"location":"modules/manager/#file-matching","text":"Most managers have a default fileMatch array. The fileMatch array has regular expression strings that match against the repository file list.","title":"File Matching"},{"location":"modules/manager/#managers-with-no-default-filematch","text":"Some managers have no default fileMatch regular expression, because they have no filename convention that would let Renovate intelligently filter them. In such a case, the manager will be disabled until you create a fileMatch regular expression, e.g. like the following: { \"kubernetes\" : { \"fileMatch\" : [ \"^config/.*\\\\.yaml$\" ] } }","title":"Managers with no default fileMatch"},{"location":"modules/manager/#extending-a-managers-default-filematch","text":"If the default fileMatch regular expression for a manager does not match against one of your relevant files, you can extend the existing regular expression(s) by configuring a manager's fileMatch like in this example: { \"dockerfile\" : { \"fileMatch\" : [ \"does-not-look-like-a-docker-file\" ] } }","title":"Extending a manager's default fileMatch"},{"location":"modules/manager/#ignoring-files-that-match-the-default-filematch","text":"Renovate will extend the existing fileMatch , meaning you don't need to include the default regular expressions like Dockerfile in your own array. In other words, the regular expression are \"additive\". If a manager matches a file that you don't want it to, ignore it using the ignorePaths configuration option. Also, if you ever find that Renovate is not matching a file name that you're certain it should, check your preset config isn't the cause of it. The config:base preset ignores common test and example directory names, for example.","title":"Ignoring files that match the default fileMatch"},{"location":"modules/manager/#enabling-and-disabling-managers","text":"","title":"Enabling and disabling managers"},{"location":"modules/manager/#enabling-experimental-managers","text":"Most managers are enabled by default. For those that aren't, typically because they are considered experimental, you can opt-in manually. If there was a manager called some-new-manager you would enable it like this: { \"some-new-manager\" : { \"enabled\" : true } }","title":"Enabling experimental managers"},{"location":"modules/manager/#disabling-managers","text":"To disable a specific manager like gradle , do this: { \"gradle\" : { \"enabled\" : false } } To disable all managers within a language like python , do this: { \"python\" : { \"enabled\" : false } } Only languages declared by a Renovate manager are supported. Please check the list of supported managers .","title":"Disabling managers"},{"location":"modules/manager/#limiting-enabled-managers","text":"Say you only want to use Renovate for JavaScript packages, and to update your Dockerfile, and don't want any other updates. You can use the enabledManagers array, to list the managers you want to use ( npm , dockerfile ): { \"enabledManagers\" : [ \"npm\" , \"dockerfile\" ] } Using the enabledManagers array disables all other managers, this includes Bundler, Composer, Docker Compose, etc.","title":"Limiting enabled managers"},{"location":"modules/platform/","text":"Renovate Platforms \u00b6 Renovate aims to be platform-neutral, while also taking advantage of good platform-specific features. Supported platforms \u00b6 Supported values for platform are: azure , bitbucket , bitbucket-server , gitea , github , gitlab .","title":"Platforms"},{"location":"modules/platform/#renovate-platforms","text":"Renovate aims to be platform-neutral, while also taking advantage of good platform-specific features.","title":"Renovate Platforms"},{"location":"modules/platform/#supported-platforms","text":"Supported values for platform are: azure , bitbucket , bitbucket-server , gitea , github , gitlab .","title":"Supported platforms"},{"location":"modules/versioning/","text":"Versioning \u00b6 Once Managers have extracted dependencies, and Datasources have located available versions, then Renovate will use a \"Versioning\" scheme to perform sorting and filtering of results. The \"versioning\" is different for each package manager, because different package managers use different versioning schemes. For example, npm uses 1.0.0-beta.1 and pip uses 1.0.0b1 . Why you might need to manually configure versioning \u00b6 Renovate interprets versions correctly out-of-the-box most of the time. It's impossible to automatically detect all versioning schemes, so sometimes you need to tell the bot what versioning scheme it should use. You can manually configure/override the versioning value for a particular dependency. You generally won't need to override the defaults for ecosystems which enforce a strict version scheme like npm . Configuring or overriding the default versioning can be particularly helpful for ecosystems like Docker/Kubernetes/Helm, where versioning is barely a \"convention\". General concepts behind overriding versioning \u00b6 Although you can reconfigure versioning per-manager or per-datasource, it's unlikely that such a broad change would ever be needed More commonly you would need to configure versioning for individual packages or potentially package patterns The best way to do this is with packageRules , with a combination of matchManagers , matchDatasources , matchPackageNames and matchPackagePatterns Examples of versioning overrides \u00b6 Overriding Docker versioning to use a versioning specific for a package \u00b6 The configuration below overrides Renovate's default docker versioning for the python Docker image and instead uses the pep440 versioning scheme to evaluate versions. { \"packageRules\" : [ { \"matchDatasources\" : [ \"docker\" ], \"matchPackageNames\" : [ \"python\" ], \"versioning\" : \"pep440\" } ] } Using a custom regex versioning scheme \u00b6 { \"packageRules\" : [ { \"matchPackageNames\" : [ \"foo/bar\" ], \"versioning\" : \"regex:^(?<compatibility>.*)-v?(?<major>\\\\d+)\\\\.(?<minor>\\\\d+)\\\\.(?<patch>\\\\d+)?$\" } ] } Supported Versioning \u00b6 Supported values for versioning are: aws-machine-image , cargo , composer , conan , debian , docker , git , gradle , hashicorp , helm , hex , ivy , loose , maven , node , npm , nuget , pep440 , poetry , regex , rez , ruby , semver , semver-coerced , swift , ubuntu . aws-machine-image Versioning \u00b6 Identifier : aws-machine-image Ranges/Constraints: \u274c No range support. Description : Renovate's AWS Machine Image versioning is a kind of hack to support Amazon Machine Images (AMI) updates. At the moment every AMI that matches the regex ^ami-[a-z0-9]{17}$ is considered a valid \"release\". Cargo Versioning \u00b6 Identifier : cargo References : https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , widen , pin , replace Description : Cargo versioning uses Semantic Versioning 2.0 . Cargo supports ranges in a similar manner to npm, but not identical. The important differences are: Use of commas Multiple version requirements can also be separated with a comma, e.g. >= 1.2, < 1.5 . We interpret this to mean AND. No exact versions unless using equals = In Cargo, 1.2.3 doesn't mean \"exactly 1.2.3\", it actually means >=1.2.3 <2.0.0 . So this is like the equivalent of ^1.2.3 in npm. Composer Versioning \u00b6 Identifier : composer References : https://getcomposer.org/doc/articles/versions.md https://packagist.org/packages/composer/semver https://madewithlove.be/tilde-and-caret-constraints/ https://semver.mwl.be Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , widen , pin , replace , update-lockfile Description : Composer uses Semver-like versioning, but some package authors may use versions that are not completely valid, e.g. 1.2 instead of 1.2.0 . Composer supports ranges in a similar manner to npm, but not identical. The main difference is with tilde ranges. Tilde ranges with \"short\" versions are different to npm. e.g. ~4 is equivalent to ^4 in npm ~4.1 is equivalent to ^4.1 in npm ~0.4 is equivalent to >=0.4 <1 in npm conan Versioning \u00b6 Identifier : conan References : https://semver.org/ https://github.com/podhmo/python-node-semver https://github.com/podhmo/python-node-semver/tree/master/examples https://docs.conan.io/en/latest/versioning/version_ranges.html#version-ranges Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: auto , bump , widen , replace Description : Conan versioning supports Semantic Versioning 2.0 but some packages don't follow this specification. Conan implements python-node-semver . Read the Conan docs about version ranges for more information. syntax description 5.45 Equivalent to 5.45 16.00 Equivalent to 16.00 2.8.3 Equivalent to 2.8.3 [>1.1 <2.1] Keep version within range [2.8] Equivalent to =2.8 [~=3.0] Compatible, according to SemVer [>1.1 \\|\\| 0.8] Conditions can be OR'ed [1.2.7 \\|\\| >=1.2.9 <2.0.0] This range would match the versions 1.2.7 , 1.2.9 , and 1.4.6 , but not the versions 1.2.8 or 2.0.0 [>1.1 <2.1, include_prerelease=True] Would e.g. accept 2.0.0-pre.1 as match [~1.2.3, loose=False] Would only accept correct Semantic Versioning strings. E.g. version 1.2.3.4 would not be accepted [~1.2.3, loose=False, include_prerelease=True] Both options can be used for the same version range Debian Versioning \u00b6 Identifier : debian References : https://debian.pages.debian.net/distro-info-data/debian.csv Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: pin Docker Versioning \u00b6 Identifier : docker References : https://docs.docker.com/engine/reference/commandline/tag/ Ranges/Constraints: \u274c No range support. Description : Docker doesn't really have versioning , instead it supports \"tags\" and these are usually used by Docker image authors as a form of versioning. This Docker versioning implementation in Renovate is designed to handle the most common conventions used in tagging images. In particular, it treats the text after the first hyphen as a type of platform/compatibility indicator. For example, many images include images with the \"-alpine\" suffix, e.g. the official node Docker image includes tags like 12.15.0-alpine which is not compatible with 12.15.0 or 12.15.0-stretch . This means users only want/expect upgrades to 12.16.0-alpine and not 12.16.0 or 12.16.0-stretch . Similarly, a user with 12.14 expects to be upgraded to 12.15 and not 12.15.0 . What type of versioning is used? It's pretty \"wild west\" for tagging and not always compliant with SemVer. Docker versioning in Renovate should do a best effort to accept and sort SemVer-like versions. Are ranges supported? No. Although a tag like 12.15 might seem like it means 12.15.x , it is a tag of its own and may or may not point to an of the available 12.15.x tags, including 12.15.0 . Are commit hashes supported? No. An image tag that looks like a Git commit hash should be ignored by Renovate. git Versioning \u00b6 Identifier : git References : https://git-scm.com/ Ranges/Constraints: \u274c No range support. Description : Renovate's Git versioning is a kind of hack to support Git submodule updating. Gradle Versioning \u00b6 Identifier : gradle References : https://docs.gradle.org/current/userguide/single_versions.html#version_ordering Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: pin Hashicorp Versioning \u00b6 Identifier : hashicorp References : https://www.terraform.io/docs/configuration/terraform.html#specifying-a-required-terraform-version Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , widen , pin , replace Description : Hashicorp versioning syntax is used for Terraform. It is based off Semantic Versioning 2.0 but with a subset of npm's range syntax. helm Versioning \u00b6 Identifier : helm References : https://semver.org/ https://helm.sh/docs/chart_best_practices/dependencies/#versions https://github.com/Masterminds/semver#basic-comparisons Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , widen , pin , replace , widen Hex Versioning \u00b6 Identifier : hex References : https://hexdocs.pm/elixir/Version.html Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , widen , pin , replace Description : Hex versioning syntax is used for Elixir and Erlang hex dependencies. It is based on Semantic Versioning 2.0 and supports a subset of npm's range syntax. Ivy Versioning \u00b6 Identifier : ivy References : https://ant.apache.org/ivy/ Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , widen , pin , replace Loose Versioning \u00b6 Identifier : loose Ranges/Constraints: \u274c No range support. Description : Renovate's \"loose\" versioning was created for cases where no strict versioning is in place. It works like SemVer if SemVer-compliant versions are supplied, but otherwise is \"best effort\". Essentially it just does its best to sort versions and ignore versions that are not sortable. Maven Versioning \u00b6 Identifier : maven References : https://maven.apache.org/pom.html#Dependency_Version_Requirement_Specification https://octopus.com/blog/maven-versioning-explained https://maven.apache.org/enforcer/enforcer-rules/versionRanges.html Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , widen , pin , replace Description : Maven versioning is similar to SemVer but also very different in places. It's specified by Maven itself. Ranges are supported using Maven's special syntax. For development purposes, download maven-artifact JAR and run: $ java -jar maven-artifact-*.jar 3 .2.4-alpha-1 3 .2.4-SNAPSHOT 3 .2.4.0 Display parameters as parsed by Maven ( in canonical form ) and comparison result: 1 . 3 .2.4-alpha-1 == 3 .2.4.alpha.1 3 .2.4-alpha-1 < 3 .2.4-SNAPSHOT 2 . 3 .2.4-SNAPSHOT == 3 .2.4.snapshot 3 .2.4-SNAPSHOT < 3 .2.4.0 3 . 3 .2.4.0 == 3 .2.4 Also, take a look at maven-cmp utility. Node.js Versioning \u00b6 Identifier : node Ranges/Constraints: \u274c No range support. Description : Renovate's Node.js versioning is a wrapper around npm's versioning, except that it makes sure to strip \"v\" prefixes from exact versions when replacing. It is planned to extend it one day to support \"stability\" awareness, because Node.js's version stability does not follow the SemVer approach. npm Versioning \u00b6 Identifier : npm References : https://semver.org/ https://www.npmjs.com/package/semver https://docs.npmjs.com/about-semantic-versioning https://semver.npmjs.com/ Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , widen , pin , replace Description : npm versioning is the most well known/widely-used implementation of Semantic Versioning 2.0 . It's important to understand that \"npm\" versioning scheme is not the same as \"semver\" versioning. SemVer's spec does not define ranges at all - so all range/constraint syntax in npm is npm-specific and not part of the spec. NuGet Versioning \u00b6 Identifier : nuget References : https://docs.microsoft.com/en-us/nuget/concepts/package-versioning Ranges/Constraints: \u274c No range support. Description : NuGet versioning matches as closely as possible to the version comparison that NuGet itself uses. NuGet supports SemVer 2.0.0, but permits versions with differing numbers of version parts. Ranges are not yet supported by this versioning, but they are defined in NuGet and could be supported in the future. PEP440 Versioning \u00b6 Identifier : pep440 References : https://www.python.org/dev/peps/pep-0440/ Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , widen , pin , replace Description : PEP 440 is defined as part of the Python project, and its versioning is independent of others such as SemVer. Ranges are supported using the syntax defined as part of the PEP440 spec. Poetry Versioning \u00b6 Identifier : poetry References : https://python-poetry.org/docs/versions/ Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , widen , pin , replace Description : Poetry versioning is a little like a mix of PEP440 and SemVer. Currently Renovate's implementation is based off npm versioning. This works by parsing versions using the same patterns and similar normalization rules as Poetry, passing them to the npm versioning implementation, and then reversing the normalizations. This allows Renovate to meaningfully compare the SemVer-style versions allowed in pyproject.toml to the PEP440 representations used on PyPI. These are equivalent for major.minor.patch releases, but different for pre-, post-, and dev releases. Regular Expression Versioning \u00b6 Identifier : regex Ranges/Constraints: \u274c No range support. Description : Regular Expression Versioning is designed to be a flexible fallback versioning approach if Renovate's other versioning schemes don't do the job. The regex scheme makes use of Regular Express capture groups. The valid capture groups for regex versioning are: major , minor , and patch : at least one of these must be provided. When determining whether a package has updates, these values will be compared in the standard semantic versioning fashion. If any of these fields are omitted, they will be treated as if they were 0 -- in this way, you can describe versioning schemes with up to three incrementing values. build : this capture group can be used after you've already used the major , minor and patch capture groups and need a fourth version part. build updates are handled like patch updates. prerelease : this value, if captured, will mark a given release as a prerelease (e.g. unstable). If this value is captured and you have configured \"ignoreUnstable\": true , the given release will be skipped. compatibility : this value defines the \"build compatibility\" of a given dependency. A proposed Renovate update will never change the specified compatibility value. For example, if you are pinning to 1.2.3-linux (and linux is captured as the compatibility value), Renovate will not update you to 1.2.4-osx . The compatibility concept was originally introduced for Docker versioning but sometimes package authors may use/misuse suffixes to mean compatibility in other versioning schemes. Here is an example of using regex versioning to correct behavior of the guava Maven package, which misuses suffixes as compatibility indicators: { \"packageRules\" : [ { \"matchPackageNames\" : [ \"com.google.guava:guava\" ], \"versioning\" : \"regex:^(?<major>\\\\d+)(\\\\.(?<minor>\\\\d+))?(\\\\.(?<patch>\\\\d+))?(-(?<compatibility>.*))?$\" } ] } Here is another example, this time for handling python Docker images, which use both pre-release indicators as well as version suffixes for compatibility: { \"packageRules\" : [ { \"matchDatasources\" : [ \"docker\" ], \"matchPackageNames\" : [ \"python\" ], \"versioning\" : \"regex:^(?<major>\\\\d+)\\\\.(?<minor>\\\\d+)\\\\.(?<patch>\\\\d+)(?<prerelease>[^.-]+)?(-(?<compatibility>.*))?$\" } ] } Here is another example, this time for handling Bitnami Docker images, which use build indicators as well as version suffixes for compatibility: { \"packageRules\" : [ { \"matchDatasources\" : [ \"docker\" ], \"matchPackagePrefixes\" : [ \"bitnami/\" ], \"versioning\" : \"regex:^(?<major>\\\\d+)\\\\.(?<minor>\\\\d+)\\\\.(?<patch>\\\\d+)(:?-(?<compatibility>.*-r)(?<build>\\\\d+))?$\" } ] } rez Versioning \u00b6 Identifier : rez References : https://github.com/nerdvegas/rez Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , widen , pin , replace Description : rez versioning was developed to support the rez Package Manager . It's based on Semantic Versioning but includes its own concept of ranges. Use of dots A range is expressed with dots 1.2..2 means >=1.2.x <2.0.0 . No exact versions unless using two equals == In rez, 1.2.3 doesn't mean \"exactly 1.2.3\", it actually means >= 1.2.3 <1.2.4 . If you want to use an exact version use two equal characters, like this: ==1.2.3 . Use of pipes rez uses pipes as an OR operator, 2.7..3|4 means >=2.7 <3 OR 4.x.x . This has not been implemented yet. The current iteration of rez versioning does not support pipes yet. Ruby Versioning \u00b6 Identifier : ruby References : https://guides.rubygems.org/patterns/ https://bundler.io/v1.5/gemfile.html https://www.devalot.com/articles/2012/04/gem-versions.html Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , widen , pin , replace Description : The RubyGems team urges gem developers to follow the Semantic Versioning standard for their gem\u2019s versions, but it is not enforced. Range syntax is similar to npm's but not identical. The main difference is the use of \"pessimistic\" greater than or equals: ~> Semantic Versioning \u00b6 Identifier : semver References : https://semver.org/ Ranges/Constraints: \u274c No range support. Description : Renovate's Semantic Versioning is a strict/independent implementation of Semantic Versioning 2.0 . It has been developed to be used in situations where exact-only SemVer support is needed and not npm's extended semver implementation including ranges. Ranges are not supported, in line with the specification. Coerced Semantic Versioning Versioning \u00b6 Identifier : semver-coerced References : https://semver.org/ Ranges/Constraints: \u274c No range support. Description : Renovate's Coerced Semantic Versioning is a forgiving variant of Semantic Versioning 2.0 with coercion enabled for versions. This versioning provides a very forgiving translation of inputs in non-strict-SemVer format into strict SemVer. For example, \"v1\" is coerced into \"1.0.0\", \"2.1\" => \"2.1.0\", \"~3.1\" => \"3.1.0\", \"1.1-foo\" => \"1.1.0\". Look at the Coercion section of this page for more info on input coercion. Since this versioning is very forgiving, it doesn't actually provide the coercion for version ranges. The range functions only accept strict SemVer as input and equivalent to those provided by the Renovate's semver versioning. Swift Versioning \u00b6 Identifier : swift References : https://swift.org/package-manager/ Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , widen , pin , replace Description : Swift versioning was developed to support the Swift Package Manager. It's based on Semantic versioning but includes its own concept of ranges. Ubuntu Versioning \u00b6 Identifier : ubuntu References : https://changelogs.ubuntu.com/meta-release https://debian.pages.debian.net/distro-info-data/ubuntu.csv Ranges/Constraints: \u274c No range support.","title":"Versioning"},{"location":"modules/versioning/#versioning","text":"Once Managers have extracted dependencies, and Datasources have located available versions, then Renovate will use a \"Versioning\" scheme to perform sorting and filtering of results. The \"versioning\" is different for each package manager, because different package managers use different versioning schemes. For example, npm uses 1.0.0-beta.1 and pip uses 1.0.0b1 .","title":"Versioning"},{"location":"modules/versioning/#why-you-might-need-to-manually-configure-versioning","text":"Renovate interprets versions correctly out-of-the-box most of the time. It's impossible to automatically detect all versioning schemes, so sometimes you need to tell the bot what versioning scheme it should use. You can manually configure/override the versioning value for a particular dependency. You generally won't need to override the defaults for ecosystems which enforce a strict version scheme like npm . Configuring or overriding the default versioning can be particularly helpful for ecosystems like Docker/Kubernetes/Helm, where versioning is barely a \"convention\".","title":"Why you might need to manually configure versioning"},{"location":"modules/versioning/#general-concepts-behind-overriding-versioning","text":"Although you can reconfigure versioning per-manager or per-datasource, it's unlikely that such a broad change would ever be needed More commonly you would need to configure versioning for individual packages or potentially package patterns The best way to do this is with packageRules , with a combination of matchManagers , matchDatasources , matchPackageNames and matchPackagePatterns","title":"General concepts behind overriding versioning"},{"location":"modules/versioning/#examples-of-versioning-overrides","text":"","title":"Examples of versioning overrides"},{"location":"modules/versioning/#overriding-docker-versioning-to-use-a-versioning-specific-for-a-package","text":"The configuration below overrides Renovate's default docker versioning for the python Docker image and instead uses the pep440 versioning scheme to evaluate versions. { \"packageRules\" : [ { \"matchDatasources\" : [ \"docker\" ], \"matchPackageNames\" : [ \"python\" ], \"versioning\" : \"pep440\" } ] }","title":"Overriding Docker versioning to use a versioning specific for a package"},{"location":"modules/versioning/#using-a-custom-regex-versioning-scheme","text":"{ \"packageRules\" : [ { \"matchPackageNames\" : [ \"foo/bar\" ], \"versioning\" : \"regex:^(?<compatibility>.*)-v?(?<major>\\\\d+)\\\\.(?<minor>\\\\d+)\\\\.(?<patch>\\\\d+)?$\" } ] }","title":"Using a custom regex versioning scheme"},{"location":"modules/versioning/#supported-versioning","text":"Supported values for versioning are: aws-machine-image , cargo , composer , conan , debian , docker , git , gradle , hashicorp , helm , hex , ivy , loose , maven , node , npm , nuget , pep440 , poetry , regex , rez , ruby , semver , semver-coerced , swift , ubuntu .","title":"Supported Versioning"},{"location":"modules/versioning/#aws-machine-image-versioning","text":"Identifier : aws-machine-image Ranges/Constraints: \u274c No range support. Description : Renovate's AWS Machine Image versioning is a kind of hack to support Amazon Machine Images (AMI) updates. At the moment every AMI that matches the regex ^ami-[a-z0-9]{17}$ is considered a valid \"release\".","title":"aws-machine-image Versioning"},{"location":"modules/versioning/#cargo-versioning","text":"Identifier : cargo References : https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , widen , pin , replace Description : Cargo versioning uses Semantic Versioning 2.0 . Cargo supports ranges in a similar manner to npm, but not identical. The important differences are: Use of commas Multiple version requirements can also be separated with a comma, e.g. >= 1.2, < 1.5 . We interpret this to mean AND. No exact versions unless using equals = In Cargo, 1.2.3 doesn't mean \"exactly 1.2.3\", it actually means >=1.2.3 <2.0.0 . So this is like the equivalent of ^1.2.3 in npm.","title":"Cargo Versioning"},{"location":"modules/versioning/#composer-versioning","text":"Identifier : composer References : https://getcomposer.org/doc/articles/versions.md https://packagist.org/packages/composer/semver https://madewithlove.be/tilde-and-caret-constraints/ https://semver.mwl.be Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , widen , pin , replace , update-lockfile Description : Composer uses Semver-like versioning, but some package authors may use versions that are not completely valid, e.g. 1.2 instead of 1.2.0 . Composer supports ranges in a similar manner to npm, but not identical. The main difference is with tilde ranges. Tilde ranges with \"short\" versions are different to npm. e.g. ~4 is equivalent to ^4 in npm ~4.1 is equivalent to ^4.1 in npm ~0.4 is equivalent to >=0.4 <1 in npm","title":"Composer Versioning"},{"location":"modules/versioning/#conan-versioning","text":"Identifier : conan References : https://semver.org/ https://github.com/podhmo/python-node-semver https://github.com/podhmo/python-node-semver/tree/master/examples https://docs.conan.io/en/latest/versioning/version_ranges.html#version-ranges Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: auto , bump , widen , replace Description : Conan versioning supports Semantic Versioning 2.0 but some packages don't follow this specification. Conan implements python-node-semver . Read the Conan docs about version ranges for more information. syntax description 5.45 Equivalent to 5.45 16.00 Equivalent to 16.00 2.8.3 Equivalent to 2.8.3 [>1.1 <2.1] Keep version within range [2.8] Equivalent to =2.8 [~=3.0] Compatible, according to SemVer [>1.1 \\|\\| 0.8] Conditions can be OR'ed [1.2.7 \\|\\| >=1.2.9 <2.0.0] This range would match the versions 1.2.7 , 1.2.9 , and 1.4.6 , but not the versions 1.2.8 or 2.0.0 [>1.1 <2.1, include_prerelease=True] Would e.g. accept 2.0.0-pre.1 as match [~1.2.3, loose=False] Would only accept correct Semantic Versioning strings. E.g. version 1.2.3.4 would not be accepted [~1.2.3, loose=False, include_prerelease=True] Both options can be used for the same version range","title":"conan Versioning"},{"location":"modules/versioning/#debian-versioning","text":"Identifier : debian References : https://debian.pages.debian.net/distro-info-data/debian.csv Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: pin","title":"Debian Versioning"},{"location":"modules/versioning/#docker-versioning","text":"Identifier : docker References : https://docs.docker.com/engine/reference/commandline/tag/ Ranges/Constraints: \u274c No range support. Description : Docker doesn't really have versioning , instead it supports \"tags\" and these are usually used by Docker image authors as a form of versioning. This Docker versioning implementation in Renovate is designed to handle the most common conventions used in tagging images. In particular, it treats the text after the first hyphen as a type of platform/compatibility indicator. For example, many images include images with the \"-alpine\" suffix, e.g. the official node Docker image includes tags like 12.15.0-alpine which is not compatible with 12.15.0 or 12.15.0-stretch . This means users only want/expect upgrades to 12.16.0-alpine and not 12.16.0 or 12.16.0-stretch . Similarly, a user with 12.14 expects to be upgraded to 12.15 and not 12.15.0 . What type of versioning is used? It's pretty \"wild west\" for tagging and not always compliant with SemVer. Docker versioning in Renovate should do a best effort to accept and sort SemVer-like versions. Are ranges supported? No. Although a tag like 12.15 might seem like it means 12.15.x , it is a tag of its own and may or may not point to an of the available 12.15.x tags, including 12.15.0 . Are commit hashes supported? No. An image tag that looks like a Git commit hash should be ignored by Renovate.","title":"Docker Versioning"},{"location":"modules/versioning/#git-versioning","text":"Identifier : git References : https://git-scm.com/ Ranges/Constraints: \u274c No range support. Description : Renovate's Git versioning is a kind of hack to support Git submodule updating.","title":"git Versioning"},{"location":"modules/versioning/#gradle-versioning","text":"Identifier : gradle References : https://docs.gradle.org/current/userguide/single_versions.html#version_ordering Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: pin","title":"Gradle Versioning"},{"location":"modules/versioning/#hashicorp-versioning","text":"Identifier : hashicorp References : https://www.terraform.io/docs/configuration/terraform.html#specifying-a-required-terraform-version Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , widen , pin , replace Description : Hashicorp versioning syntax is used for Terraform. It is based off Semantic Versioning 2.0 but with a subset of npm's range syntax.","title":"Hashicorp Versioning"},{"location":"modules/versioning/#helm-versioning","text":"Identifier : helm References : https://semver.org/ https://helm.sh/docs/chart_best_practices/dependencies/#versions https://github.com/Masterminds/semver#basic-comparisons Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , widen , pin , replace , widen","title":"helm Versioning"},{"location":"modules/versioning/#hex-versioning","text":"Identifier : hex References : https://hexdocs.pm/elixir/Version.html Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , widen , pin , replace Description : Hex versioning syntax is used for Elixir and Erlang hex dependencies. It is based on Semantic Versioning 2.0 and supports a subset of npm's range syntax.","title":"Hex Versioning"},{"location":"modules/versioning/#ivy-versioning","text":"Identifier : ivy References : https://ant.apache.org/ivy/ Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , widen , pin , replace","title":"Ivy Versioning"},{"location":"modules/versioning/#loose-versioning","text":"Identifier : loose Ranges/Constraints: \u274c No range support. Description : Renovate's \"loose\" versioning was created for cases where no strict versioning is in place. It works like SemVer if SemVer-compliant versions are supplied, but otherwise is \"best effort\". Essentially it just does its best to sort versions and ignore versions that are not sortable.","title":"Loose Versioning"},{"location":"modules/versioning/#maven-versioning","text":"Identifier : maven References : https://maven.apache.org/pom.html#Dependency_Version_Requirement_Specification https://octopus.com/blog/maven-versioning-explained https://maven.apache.org/enforcer/enforcer-rules/versionRanges.html Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , widen , pin , replace Description : Maven versioning is similar to SemVer but also very different in places. It's specified by Maven itself. Ranges are supported using Maven's special syntax. For development purposes, download maven-artifact JAR and run: $ java -jar maven-artifact-*.jar 3 .2.4-alpha-1 3 .2.4-SNAPSHOT 3 .2.4.0 Display parameters as parsed by Maven ( in canonical form ) and comparison result: 1 . 3 .2.4-alpha-1 == 3 .2.4.alpha.1 3 .2.4-alpha-1 < 3 .2.4-SNAPSHOT 2 . 3 .2.4-SNAPSHOT == 3 .2.4.snapshot 3 .2.4-SNAPSHOT < 3 .2.4.0 3 . 3 .2.4.0 == 3 .2.4 Also, take a look at maven-cmp utility.","title":"Maven Versioning"},{"location":"modules/versioning/#nodejs-versioning","text":"Identifier : node Ranges/Constraints: \u274c No range support. Description : Renovate's Node.js versioning is a wrapper around npm's versioning, except that it makes sure to strip \"v\" prefixes from exact versions when replacing. It is planned to extend it one day to support \"stability\" awareness, because Node.js's version stability does not follow the SemVer approach.","title":"Node.js Versioning"},{"location":"modules/versioning/#npm-versioning","text":"Identifier : npm References : https://semver.org/ https://www.npmjs.com/package/semver https://docs.npmjs.com/about-semantic-versioning https://semver.npmjs.com/ Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , widen , pin , replace Description : npm versioning is the most well known/widely-used implementation of Semantic Versioning 2.0 . It's important to understand that \"npm\" versioning scheme is not the same as \"semver\" versioning. SemVer's spec does not define ranges at all - so all range/constraint syntax in npm is npm-specific and not part of the spec.","title":"npm Versioning"},{"location":"modules/versioning/#nuget-versioning","text":"Identifier : nuget References : https://docs.microsoft.com/en-us/nuget/concepts/package-versioning Ranges/Constraints: \u274c No range support. Description : NuGet versioning matches as closely as possible to the version comparison that NuGet itself uses. NuGet supports SemVer 2.0.0, but permits versions with differing numbers of version parts. Ranges are not yet supported by this versioning, but they are defined in NuGet and could be supported in the future.","title":"NuGet Versioning"},{"location":"modules/versioning/#pep440-versioning","text":"Identifier : pep440 References : https://www.python.org/dev/peps/pep-0440/ Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , widen , pin , replace Description : PEP 440 is defined as part of the Python project, and its versioning is independent of others such as SemVer. Ranges are supported using the syntax defined as part of the PEP440 spec.","title":"PEP440 Versioning"},{"location":"modules/versioning/#poetry-versioning","text":"Identifier : poetry References : https://python-poetry.org/docs/versions/ Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , widen , pin , replace Description : Poetry versioning is a little like a mix of PEP440 and SemVer. Currently Renovate's implementation is based off npm versioning. This works by parsing versions using the same patterns and similar normalization rules as Poetry, passing them to the npm versioning implementation, and then reversing the normalizations. This allows Renovate to meaningfully compare the SemVer-style versions allowed in pyproject.toml to the PEP440 representations used on PyPI. These are equivalent for major.minor.patch releases, but different for pre-, post-, and dev releases.","title":"Poetry Versioning"},{"location":"modules/versioning/#regular-expression-versioning","text":"Identifier : regex Ranges/Constraints: \u274c No range support. Description : Regular Expression Versioning is designed to be a flexible fallback versioning approach if Renovate's other versioning schemes don't do the job. The regex scheme makes use of Regular Express capture groups. The valid capture groups for regex versioning are: major , minor , and patch : at least one of these must be provided. When determining whether a package has updates, these values will be compared in the standard semantic versioning fashion. If any of these fields are omitted, they will be treated as if they were 0 -- in this way, you can describe versioning schemes with up to three incrementing values. build : this capture group can be used after you've already used the major , minor and patch capture groups and need a fourth version part. build updates are handled like patch updates. prerelease : this value, if captured, will mark a given release as a prerelease (e.g. unstable). If this value is captured and you have configured \"ignoreUnstable\": true , the given release will be skipped. compatibility : this value defines the \"build compatibility\" of a given dependency. A proposed Renovate update will never change the specified compatibility value. For example, if you are pinning to 1.2.3-linux (and linux is captured as the compatibility value), Renovate will not update you to 1.2.4-osx . The compatibility concept was originally introduced for Docker versioning but sometimes package authors may use/misuse suffixes to mean compatibility in other versioning schemes. Here is an example of using regex versioning to correct behavior of the guava Maven package, which misuses suffixes as compatibility indicators: { \"packageRules\" : [ { \"matchPackageNames\" : [ \"com.google.guava:guava\" ], \"versioning\" : \"regex:^(?<major>\\\\d+)(\\\\.(?<minor>\\\\d+))?(\\\\.(?<patch>\\\\d+))?(-(?<compatibility>.*))?$\" } ] } Here is another example, this time for handling python Docker images, which use both pre-release indicators as well as version suffixes for compatibility: { \"packageRules\" : [ { \"matchDatasources\" : [ \"docker\" ], \"matchPackageNames\" : [ \"python\" ], \"versioning\" : \"regex:^(?<major>\\\\d+)\\\\.(?<minor>\\\\d+)\\\\.(?<patch>\\\\d+)(?<prerelease>[^.-]+)?(-(?<compatibility>.*))?$\" } ] } Here is another example, this time for handling Bitnami Docker images, which use build indicators as well as version suffixes for compatibility: { \"packageRules\" : [ { \"matchDatasources\" : [ \"docker\" ], \"matchPackagePrefixes\" : [ \"bitnami/\" ], \"versioning\" : \"regex:^(?<major>\\\\d+)\\\\.(?<minor>\\\\d+)\\\\.(?<patch>\\\\d+)(:?-(?<compatibility>.*-r)(?<build>\\\\d+))?$\" } ] }","title":"Regular Expression Versioning"},{"location":"modules/versioning/#rez-versioning","text":"Identifier : rez References : https://github.com/nerdvegas/rez Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , widen , pin , replace Description : rez versioning was developed to support the rez Package Manager . It's based on Semantic Versioning but includes its own concept of ranges. Use of dots A range is expressed with dots 1.2..2 means >=1.2.x <2.0.0 . No exact versions unless using two equals == In rez, 1.2.3 doesn't mean \"exactly 1.2.3\", it actually means >= 1.2.3 <1.2.4 . If you want to use an exact version use two equal characters, like this: ==1.2.3 . Use of pipes rez uses pipes as an OR operator, 2.7..3|4 means >=2.7 <3 OR 4.x.x . This has not been implemented yet. The current iteration of rez versioning does not support pipes yet.","title":"rez Versioning"},{"location":"modules/versioning/#ruby-versioning","text":"Identifier : ruby References : https://guides.rubygems.org/patterns/ https://bundler.io/v1.5/gemfile.html https://www.devalot.com/articles/2012/04/gem-versions.html Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , widen , pin , replace Description : The RubyGems team urges gem developers to follow the Semantic Versioning standard for their gem\u2019s versions, but it is not enforced. Range syntax is similar to npm's but not identical. The main difference is the use of \"pessimistic\" greater than or equals: ~>","title":"Ruby Versioning"},{"location":"modules/versioning/#semantic-versioning","text":"Identifier : semver References : https://semver.org/ Ranges/Constraints: \u274c No range support. Description : Renovate's Semantic Versioning is a strict/independent implementation of Semantic Versioning 2.0 . It has been developed to be used in situations where exact-only SemVer support is needed and not npm's extended semver implementation including ranges. Ranges are not supported, in line with the specification.","title":"Semantic Versioning"},{"location":"modules/versioning/#coerced-semantic-versioning-versioning","text":"Identifier : semver-coerced References : https://semver.org/ Ranges/Constraints: \u274c No range support. Description : Renovate's Coerced Semantic Versioning is a forgiving variant of Semantic Versioning 2.0 with coercion enabled for versions. This versioning provides a very forgiving translation of inputs in non-strict-SemVer format into strict SemVer. For example, \"v1\" is coerced into \"1.0.0\", \"2.1\" => \"2.1.0\", \"~3.1\" => \"3.1.0\", \"1.1-foo\" => \"1.1.0\". Look at the Coercion section of this page for more info on input coercion. Since this versioning is very forgiving, it doesn't actually provide the coercion for version ranges. The range functions only accept strict SemVer as input and equivalent to those provided by the Renovate's semver versioning.","title":"Coerced Semantic Versioning Versioning"},{"location":"modules/versioning/#swift-versioning","text":"Identifier : swift References : https://swift.org/package-manager/ Ranges/Constraints: \u2705 Ranges are supported. Valid rangeStrategy values are: bump , widen , pin , replace Description : Swift versioning was developed to support the Swift Package Manager. It's based on Semantic versioning but includes its own concept of ranges.","title":"Swift Versioning"},{"location":"modules/versioning/#ubuntu-versioning","text":"Identifier : ubuntu References : https://changelogs.ubuntu.com/meta-release https://debian.pages.debian.net/distro-info-data/ubuntu.csv Ranges/Constraints: \u274c No range support.","title":"Ubuntu Versioning"},{"location":"modules/manager/ansible/","text":"Renovate supports updating Ansible dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)tasks/[^/]+\\.ya?ml$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: docker . Additional Information \u00b6 Supports Docker-type dependency extraction from Ansible configuration files. If you need to change the versioning format, read the versioning documentation to learn more.","title":"Automated Dependency Updates for Ansible"},{"location":"modules/manager/ansible/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)tasks/[^/]+\\.ya?ml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/ansible/#supported-datasources","text":"This manager supports extracting the following datasources: docker .","title":"Supported datasources"},{"location":"modules/manager/ansible/#additional-information","text":"Supports Docker-type dependency extraction from Ansible configuration files. If you need to change the versioning format, read the versioning documentation to learn more.","title":"Additional Information"},{"location":"modules/manager/ansible-galaxy/","text":"Renovate supports updating Ansible Galaxy dependencies. File Matching \u00b6 By default, Renovate will check any files matching any of the following regular expressions: (^|/)requirements\\.ya?ml$ (^|/)galaxy\\.ya?ml$ For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: galaxy-collection , git-tags , github-tags . Additional Information \u00b6 Extracts Ansible Galaxy dependencies from configuration files used by the ansible-galaxy CLI tool. This manager uses two depType s to allow a fine-grained control of which dependencies are upgraded: collection role","title":"Automated Dependency Updates for Ansible Galaxy"},{"location":"modules/manager/ansible-galaxy/#file-matching","text":"By default, Renovate will check any files matching any of the following regular expressions: (^|/)requirements\\.ya?ml$ (^|/)galaxy\\.ya?ml$ For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/ansible-galaxy/#supported-datasources","text":"This manager supports extracting the following datasources: galaxy-collection , git-tags , github-tags .","title":"Supported datasources"},{"location":"modules/manager/ansible-galaxy/#additional-information","text":"Extracts Ansible Galaxy dependencies from configuration files used by the ansible-galaxy CLI tool. This manager uses two depType s to allow a fine-grained control of which dependencies are upgraded: collection role","title":"Additional Information"},{"location":"modules/manager/argocd/","text":"Renovate supports updating Argocd dependencies. File Matching \u00b6 Because file names for argocd cannot be easily determined automatically, Renovate will not attempt to match any argocd files by default. For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: git-tags , helm . Additional Information \u00b6 The argocd manager has no fileMatch default patterns, so it won't match any files until you configure it with a pattern. This is because there is no commonly accepted file/directory naming convention for argocd YAML files and we don't want to check every single *.yaml file in repositories just in case any of them have ArgoCD definitions. If most .yaml files in your repository are argocd ones, then you could add this to your config: { \"argocd\" : { \"fileMatch\" : [ \"\\\\.yaml$\" ] } } If instead you have them all inside a argocd/ directory, you would add this: { \"argocd\" : { \"fileMatch\" : [ \"argocd/.+\\\\.yaml$\" ] } } Or if it's just a single file then something like this: { \"argocd\" : { \"fileMatch\" : [ \"^config/applications\\\\.yaml$\" ] } } If you need to change the versioning format, read the versioning documentation to learn more.","title":"Automated Dependency Updates for Argocd"},{"location":"modules/manager/argocd/#file-matching","text":"Because file names for argocd cannot be easily determined automatically, Renovate will not attempt to match any argocd files by default. For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/argocd/#supported-datasources","text":"This manager supports extracting the following datasources: git-tags , helm .","title":"Supported datasources"},{"location":"modules/manager/argocd/#additional-information","text":"The argocd manager has no fileMatch default patterns, so it won't match any files until you configure it with a pattern. This is because there is no commonly accepted file/directory naming convention for argocd YAML files and we don't want to check every single *.yaml file in repositories just in case any of them have ArgoCD definitions. If most .yaml files in your repository are argocd ones, then you could add this to your config: { \"argocd\" : { \"fileMatch\" : [ \"\\\\.yaml$\" ] } } If instead you have them all inside a argocd/ directory, you would add this: { \"argocd\" : { \"fileMatch\" : [ \"argocd/.+\\\\.yaml$\" ] } } Or if it's just a single file then something like this: { \"argocd\" : { \"fileMatch\" : [ \"^config/applications\\\\.yaml$\" ] } } If you need to change the versioning format, read the versioning documentation to learn more.","title":"Additional Information"},{"location":"modules/manager/azure-pipelines/","text":"Renovate supports updating Azure Pipelines dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: azure.*pipelines?.*\\.ya?ml$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: git-tags . Additional Information \u00b6 The azure-pipelines manager extracts container and repository resources from the resources: block. For example: resources : repositories : - type : github name : renovate/renovate ref : refs/heads/main - type : github name : user/repo ref : refs/tags/v0.5.1 containers : - container : linux image : ubuntu:16.04 - container : python image : python:3.7@sha256:3870d35b962a943df72d948580fc66ceaaee1c4fbd205930f32e0f0760eb1077 More about the resources block can be found on the Azure pipelines documentation . Files that are processed by the manager includes: .azure-pipelines/**/*.yaml .azure-pipelines.yaml .azure-pipelines.yml azure-pipelines/**/*.yaml azure-pipelines.yaml azure-pipelines.yml azure-pipeline/**/*.yaml azure-pipeline.yaml azure-pipeline.yml","title":"Automated Dependency Updates for Azure Pipelines"},{"location":"modules/manager/azure-pipelines/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: azure.*pipelines?.*\\.ya?ml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/azure-pipelines/#supported-datasources","text":"This manager supports extracting the following datasources: git-tags .","title":"Supported datasources"},{"location":"modules/manager/azure-pipelines/#additional-information","text":"The azure-pipelines manager extracts container and repository resources from the resources: block. For example: resources : repositories : - type : github name : renovate/renovate ref : refs/heads/main - type : github name : user/repo ref : refs/tags/v0.5.1 containers : - container : linux image : ubuntu:16.04 - container : python image : python:3.7@sha256:3870d35b962a943df72d948580fc66ceaaee1c4fbd205930f32e0f0760eb1077 More about the resources block can be found on the Azure pipelines documentation . Files that are processed by the manager includes: .azure-pipelines/**/*.yaml .azure-pipelines.yaml .azure-pipelines.yml azure-pipelines/**/*.yaml azure-pipelines.yaml azure-pipelines.yml azure-pipeline/**/*.yaml azure-pipeline.yaml azure-pipeline.yml","title":"Additional Information"},{"location":"modules/manager/batect/","text":"Renovate supports updating Batect dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)batect(-bundle)?\\.yml$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: git-tags . Additional Information \u00b6 Extracts all Docker images and Batect bundles from Batect configuration files. For updates to Batect itself, see batect-wrapper . Files searched \u00b6 By default, the manager searches for files called batect.yml or batect-bundle.yml . If you keep your Batect configuration in other files, you'll need to tell Renovate where to find them. Files included in your main configuration file with include don't need to be listed. You do this by creating a \"batect\" object in your renovate.json file. This object should have a fileMatch array with regular expressions that match the configuration file names. For example: { \"batect\" : { \"fileMatch\" : [ \"(^|/)batect(-bundle)?\\\\.yml$\" , \"(^|/)my-other-batect-file\\\\.yml$\" , \"^a-directory/[^/]*\\\\.yml$\" ] } } Bundle versioning \u00b6 This manager assumes that any bundles referenced use tags for versioning, and that these tags use SemVer . The implementation of SemVer is strict - versions must follow the X.Y.Z or vX.Y.Z format. Versions that don't match this format (eg. X.Y ) will be ignored.","title":"Automated Dependency Updates for Batect"},{"location":"modules/manager/batect/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)batect(-bundle)?\\.yml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/batect/#supported-datasources","text":"This manager supports extracting the following datasources: git-tags .","title":"Supported datasources"},{"location":"modules/manager/batect/#additional-information","text":"Extracts all Docker images and Batect bundles from Batect configuration files. For updates to Batect itself, see batect-wrapper .","title":"Additional Information"},{"location":"modules/manager/batect/#files-searched","text":"By default, the manager searches for files called batect.yml or batect-bundle.yml . If you keep your Batect configuration in other files, you'll need to tell Renovate where to find them. Files included in your main configuration file with include don't need to be listed. You do this by creating a \"batect\" object in your renovate.json file. This object should have a fileMatch array with regular expressions that match the configuration file names. For example: { \"batect\" : { \"fileMatch\" : [ \"(^|/)batect(-bundle)?\\\\.yml$\" , \"(^|/)my-other-batect-file\\\\.yml$\" , \"^a-directory/[^/]*\\\\.yml$\" ] } }","title":"Files searched"},{"location":"modules/manager/batect/#bundle-versioning","text":"This manager assumes that any bundles referenced use tags for versioning, and that these tags use SemVer . The implementation of SemVer is strict - versions must follow the X.Y.Z or vX.Y.Z format. Versions that don't match this format (eg. X.Y ) will be ignored.","title":"Bundle versioning"},{"location":"modules/manager/batect-wrapper/","text":"Renovate supports updating Batect Wrapper dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)batect$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: github-releases . Additional Information \u00b6 Configuration for Batect wrapper updates. The default configuration will automatically update both batect and batect.cmd , similar to running ./batect --upgrade . See also: Batect image reference updates","title":"Automated Dependency Updates for Batect Wrapper"},{"location":"modules/manager/batect-wrapper/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)batect$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/batect-wrapper/#supported-datasources","text":"This manager supports extracting the following datasources: github-releases .","title":"Supported datasources"},{"location":"modules/manager/batect-wrapper/#additional-information","text":"Configuration for Batect wrapper updates. The default configuration will automatically update both batect and batect.cmd , similar to running ./batect --upgrade . See also: Batect image reference updates","title":"Additional Information"},{"location":"modules/manager/bazel/","text":"Renovate supports updating Bazel dependencies. File Matching \u00b6 By default, Renovate will check any files matching any of the following regular expressions: (^|/)WORKSPACE(|\\.bazel)$ \\.bzl$ For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: docker , github-releases , github-tags , go . Additional Information \u00b6 Bazel is quite unlike most other \"package managers\" that Renovate supports, which usually focus on a particular ecosystem like JavaScript, Ruby or Docker. Instead, Bazel is a build tool so supports a multitude of languages/datasources. Renovate does not support all possible Bazel references, although would like to, and feature requests are welcome. If you need to change the versioning format, read the versioning documentation to learn more.","title":"Automated Dependency Updates for Bazel"},{"location":"modules/manager/bazel/#file-matching","text":"By default, Renovate will check any files matching any of the following regular expressions: (^|/)WORKSPACE(|\\.bazel)$ \\.bzl$ For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/bazel/#supported-datasources","text":"This manager supports extracting the following datasources: docker , github-releases , github-tags , go .","title":"Supported datasources"},{"location":"modules/manager/bazel/#additional-information","text":"Bazel is quite unlike most other \"package managers\" that Renovate supports, which usually focus on a particular ecosystem like JavaScript, Ruby or Docker. Instead, Bazel is a build tool so supports a multitude of languages/datasources. Renovate does not support all possible Bazel references, although would like to, and feature requests are welcome. If you need to change the versioning format, read the versioning documentation to learn more.","title":"Additional Information"},{"location":"modules/manager/bitbucket-pipelines/","text":"Renovate supports updating Bitbucket Pipelines dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)\\.?bitbucket-pipelines\\.ya?ml$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: docker . Additional Information \u00b6 Extracts dependencies from Bitbucket Pipelines config files. If you need to change the versioning format, read the versioning documentation to learn more.","title":"Automated Dependency Updates for Bitbucket Pipelines"},{"location":"modules/manager/bitbucket-pipelines/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)\\.?bitbucket-pipelines\\.ya?ml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/bitbucket-pipelines/#supported-datasources","text":"This manager supports extracting the following datasources: docker .","title":"Supported datasources"},{"location":"modules/manager/bitbucket-pipelines/#additional-information","text":"Extracts dependencies from Bitbucket Pipelines config files. If you need to change the versioning format, read the versioning documentation to learn more.","title":"Additional Information"},{"location":"modules/manager/buildkite/","text":"Renovate supports updating Buildkite dependencies. File Matching \u00b6 By default, Renovate will check any files matching any of the following regular expressions: buildkite\\.ya?ml \\.buildkite/.+\\.ya?ml$ For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: github-tags . Additional Information \u00b6 Used for updating Docker dependencies in Buildkite configuration files. If you need to change the versioning format, read the versioning documentation to learn more.","title":"Automated Dependency Updates for Buildkite"},{"location":"modules/manager/buildkite/#file-matching","text":"By default, Renovate will check any files matching any of the following regular expressions: buildkite\\.ya?ml \\.buildkite/.+\\.ya?ml$ For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/buildkite/#supported-datasources","text":"This manager supports extracting the following datasources: github-tags .","title":"Supported datasources"},{"location":"modules/manager/buildkite/#additional-information","text":"Used for updating Docker dependencies in Buildkite configuration files. If you need to change the versioning format, read the versioning documentation to learn more.","title":"Additional Information"},{"location":"modules/manager/bundler/","text":"Renovate supports updating Bundler dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)Gemfile$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: rubygems , ruby-version . Additional Information \u00b6 The bundler manager is used to extract dependencies from Gemfile and Gemfile.lock files. Authenticating private registry \u00b6 If you need Bundler to authenticate with a private registry - and it's not the same host as your GitHub/GitLab/etc - then you should do so with hostRules and be sure to set the hostType value to be \"bundler\". e.g. { \"hostRules\" : [ { \"matchHost\" : \"private-registry.company.com\" , \"hostType\" : \"rubygems\" , \"token\" : \"abc123\" } ] } Important notes regarding the above: hostType is a required field, and you must provide a value. If you use Renovate v26 or higher, set hostType=rubygems . If you use Renovate v25 or lower, set hostType=bundler . If the registry is used for multiple package types then you may need multiple hostRules . Instead of token , you may also supply username and password instead. If you don't want to commit raw secrets to your repository, either: If self hosting, add the hostRules to your bot's configuration file rather than the repository's configuration file, or If using the hosted Mend Renovate app, make use of the encrypted capability","title":"Automated Dependency Updates for Bundler"},{"location":"modules/manager/bundler/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)Gemfile$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/bundler/#supported-datasources","text":"This manager supports extracting the following datasources: rubygems , ruby-version .","title":"Supported datasources"},{"location":"modules/manager/bundler/#additional-information","text":"The bundler manager is used to extract dependencies from Gemfile and Gemfile.lock files.","title":"Additional Information"},{"location":"modules/manager/bundler/#authenticating-private-registry","text":"If you need Bundler to authenticate with a private registry - and it's not the same host as your GitHub/GitLab/etc - then you should do so with hostRules and be sure to set the hostType value to be \"bundler\". e.g. { \"hostRules\" : [ { \"matchHost\" : \"private-registry.company.com\" , \"hostType\" : \"rubygems\" , \"token\" : \"abc123\" } ] } Important notes regarding the above: hostType is a required field, and you must provide a value. If you use Renovate v26 or higher, set hostType=rubygems . If you use Renovate v25 or lower, set hostType=bundler . If the registry is used for multiple package types then you may need multiple hostRules . Instead of token , you may also supply username and password instead. If you don't want to commit raw secrets to your repository, either: If self hosting, add the hostRules to your bot's configuration file rather than the repository's configuration file, or If using the hosted Mend Renovate app, make use of the encrypted capability","title":"Authenticating private registry"},{"location":"modules/manager/cake/","text":"Renovate supports updating Cake dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: \\.cake$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: nuget . Additional Information \u00b6 Extracts dependencies from *.cake files.","title":"Automated Dependency Updates for Cake"},{"location":"modules/manager/cake/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: \\.cake$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/cake/#supported-datasources","text":"This manager supports extracting the following datasources: nuget .","title":"Supported datasources"},{"location":"modules/manager/cake/#additional-information","text":"Extracts dependencies from *.cake files.","title":"Additional Information"},{"location":"modules/manager/cargo/","text":"Renovate supports updating Cargo dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)Cargo.toml$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: crate . Additional Information \u00b6 Extracts dependencies from Cargo.toml files, and also updates Cargo.lock files too if found.","title":"Automated Dependency Updates for Cargo"},{"location":"modules/manager/cargo/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)Cargo.toml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/cargo/#supported-datasources","text":"This manager supports extracting the following datasources: crate .","title":"Supported datasources"},{"location":"modules/manager/cargo/#additional-information","text":"Extracts dependencies from Cargo.toml files, and also updates Cargo.lock files too if found.","title":"Additional Information"},{"location":"modules/manager/cdnurl/","text":"Renovate supports updating Cdnurl dependencies. File Matching \u00b6 Because file names for cdnurl cannot be easily determined automatically, Renovate will not attempt to match any cdnurl files by default. For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: cdnjs . Additional Information \u00b6 Important : This manager isn't aware of subresource integrity (SRI) hashes. It will search/replace any matching url it finds, without consideration for things such as script integrity hashes. Use the html manager instead if you need SRI updating. To enable this manager, add the matching files to cdnurl.fileMatch . For example: { \"cdnurl\" : { \"fileMatch\" : [ \"\\\\.html?$\" ] } }","title":"Automated Dependency Updates for Cdnurl"},{"location":"modules/manager/cdnurl/#file-matching","text":"Because file names for cdnurl cannot be easily determined automatically, Renovate will not attempt to match any cdnurl files by default. For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/cdnurl/#supported-datasources","text":"This manager supports extracting the following datasources: cdnjs .","title":"Supported datasources"},{"location":"modules/manager/cdnurl/#additional-information","text":"Important : This manager isn't aware of subresource integrity (SRI) hashes. It will search/replace any matching url it finds, without consideration for things such as script integrity hashes. Use the html manager instead if you need SRI updating. To enable this manager, add the matching files to cdnurl.fileMatch . For example: { \"cdnurl\" : { \"fileMatch\" : [ \"\\\\.html?$\" ] } }","title":"Additional Information"},{"location":"modules/manager/circleci/","text":"Renovate supports updating Circleci dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/).circleci/config.yml$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: docker , orb . Additional Information \u00b6 The circleci manager extracts both docker as well as orb datasources from CircleCI config files. If you need to change the versioning format, read the versioning documentation to learn more.","title":"Automated Dependency Updates for Circleci"},{"location":"modules/manager/circleci/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/).circleci/config.yml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/circleci/#supported-datasources","text":"This manager supports extracting the following datasources: docker , orb .","title":"Supported datasources"},{"location":"modules/manager/circleci/#additional-information","text":"The circleci manager extracts both docker as well as orb datasources from CircleCI config files. If you need to change the versioning format, read the versioning documentation to learn more.","title":"Additional Information"},{"location":"modules/manager/cloudbuild/","text":"Renovate supports updating Cloudbuild dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)cloudbuild.ya?ml . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: docker . Additional Information \u00b6 The cloudbuild manager extracts docker datasources from Cloud Build config files . If you need to change the versioning format, read the versioning documentation to learn more.","title":"Automated Dependency Updates for Cloudbuild"},{"location":"modules/manager/cloudbuild/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)cloudbuild.ya?ml . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/cloudbuild/#supported-datasources","text":"This manager supports extracting the following datasources: docker .","title":"Supported datasources"},{"location":"modules/manager/cloudbuild/#additional-information","text":"The cloudbuild manager extracts docker datasources from Cloud Build config files . If you need to change the versioning format, read the versioning documentation to learn more.","title":"Additional Information"},{"location":"modules/manager/cocoapods/","text":"Renovate supports updating Cocoapods dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)Podfile$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: git-tags , github-tags , gitlab-tags , pod . Additional Information \u00b6 The cocoapods manager supports extracting both \"pod\" type references as well as dependencies on GitHub repositories that use versioned tags. Whenever a Podfile is updated, Renovate will also update any accompanying Podfile.lock file. This is done using the cocoapods gem which runs within the Ruby runtime.","title":"Automated Dependency Updates for Cocoapods"},{"location":"modules/manager/cocoapods/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)Podfile$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/cocoapods/#supported-datasources","text":"This manager supports extracting the following datasources: git-tags , github-tags , gitlab-tags , pod .","title":"Supported datasources"},{"location":"modules/manager/cocoapods/#additional-information","text":"The cocoapods manager supports extracting both \"pod\" type references as well as dependencies on GitHub repositories that use versioned tags. Whenever a Podfile is updated, Renovate will also update any accompanying Podfile.lock file. This is done using the cocoapods gem which runs within the Ruby runtime.","title":"Additional Information"},{"location":"modules/manager/composer/","text":"Renovate supports updating Composer dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)([\\w-]*)composer.json$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: git-tags , packagist . Additional Information \u00b6 Extracts dependencies from composer.json files, and keeps the associated composer.lock file updated too. If you use VCS repositories then Renovate needs a hint via the name property, which must match the relevant package. For example, the package acme/foo would need an entry in repositories similar to the following: { \"name\" : \"acme/foo\" , \"type\" : \"vcs\" , \"url\" : \"http://vcs-of-acme.org/acme/foo.git\" }","title":"Automated Dependency Updates for Composer"},{"location":"modules/manager/composer/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)([\\w-]*)composer.json$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/composer/#supported-datasources","text":"This manager supports extracting the following datasources: git-tags , packagist .","title":"Supported datasources"},{"location":"modules/manager/composer/#additional-information","text":"Extracts dependencies from composer.json files, and keeps the associated composer.lock file updated too. If you use VCS repositories then Renovate needs a hint via the name property, which must match the relevant package. For example, the package acme/foo would need an entry in repositories similar to the following: { \"name\" : \"acme/foo\" , \"type\" : \"vcs\" , \"url\" : \"http://vcs-of-acme.org/acme/foo.git\" }","title":"Additional Information"},{"location":"modules/manager/conan/","text":"Renovate supports updating Conan dependencies. Enabling \u00b6 Conan functionality is currently in beta testing so you must opt in to test it out. To enable it, add a configuration like this to either your bot config or your renovate.json : { \"conan\": { \"enabled\": true } } If you find any bugs, please raise a bug report . If you find that it works well, then feedback on that would be welcome too. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)conanfile\\.(txt|py)$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: conan . Additional Information \u00b6 Warning The Conan package manager is disabled by default due to slowness in the Conan API. We recommend you only enable it for low volume experimental purposes until issue #14170 is resolved. Renovate can upgrade dependencies in conanfile.txt or conanfile.py files. How it works: Renovate searches in each repository for any conanfile.txt or conanfile.py file Renovate extracts existing dependencies from: the [requires] and [build_requires] sections in the conanfile.txt format the requirements() and build_requirements() functions in the conanfile.py format and the python_requires , requires and build_requires variables in the conanfile.py format Renovate resolves the dependency's version using the Conan v2 API If Renovate finds an update, Renovate will update conanfile.txt or conanfile.py Enabling Conan updating Renovate updates Conan packages by default.","title":"Automated Dependency Updates for Conan"},{"location":"modules/manager/conan/#enabling","text":"Conan functionality is currently in beta testing so you must opt in to test it out. To enable it, add a configuration like this to either your bot config or your renovate.json : { \"conan\": { \"enabled\": true } } If you find any bugs, please raise a bug report . If you find that it works well, then feedback on that would be welcome too.","title":"Enabling"},{"location":"modules/manager/conan/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)conanfile\\.(txt|py)$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/conan/#supported-datasources","text":"This manager supports extracting the following datasources: conan .","title":"Supported datasources"},{"location":"modules/manager/conan/#additional-information","text":"Warning The Conan package manager is disabled by default due to slowness in the Conan API. We recommend you only enable it for low volume experimental purposes until issue #14170 is resolved. Renovate can upgrade dependencies in conanfile.txt or conanfile.py files. How it works: Renovate searches in each repository for any conanfile.txt or conanfile.py file Renovate extracts existing dependencies from: the [requires] and [build_requires] sections in the conanfile.txt format the requirements() and build_requirements() functions in the conanfile.py format and the python_requires , requires and build_requires variables in the conanfile.py format Renovate resolves the dependency's version using the Conan v2 API If Renovate finds an update, Renovate will update conanfile.txt or conanfile.py Enabling Conan updating Renovate updates Conan packages by default.","title":"Additional Information"},{"location":"modules/manager/deps-edn/","text":"Renovate supports updating Deps Edn dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)deps\\.edn$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: clojure . Additional Information \u00b6 Extracts Maven dependencies from deps.edn files.","title":"Automated Dependency Updates for Deps Edn"},{"location":"modules/manager/deps-edn/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)deps\\.edn$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/deps-edn/#supported-datasources","text":"This manager supports extracting the following datasources: clojure .","title":"Supported datasources"},{"location":"modules/manager/deps-edn/#additional-information","text":"Extracts Maven dependencies from deps.edn files.","title":"Additional Information"},{"location":"modules/manager/docker-compose/","text":"Renovate supports updating Docker Compose dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)(?:docker-)?compose[^/]*\\.ya?ml$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: docker . Additional Information \u00b6 Extracts all Docker images from with Docker Compose YAML files. If you need to change the versioning format, read the versioning documentation to learn more.","title":"Automated Dependency Updates for Docker Compose"},{"location":"modules/manager/docker-compose/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)(?:docker-)?compose[^/]*\\.ya?ml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/docker-compose/#supported-datasources","text":"This manager supports extracting the following datasources: docker .","title":"Supported datasources"},{"location":"modules/manager/docker-compose/#additional-information","text":"Extracts all Docker images from with Docker Compose YAML files. If you need to change the versioning format, read the versioning documentation to learn more.","title":"Additional Information"},{"location":"modules/manager/dockerfile/","text":"Renovate supports updating Dockerfile dependencies. File Matching \u00b6 By default, Renovate will check any files matching any of the following regular expressions: (^|/|\\.)Dockerfile$ (^|/)Dockerfile[^/]*$ For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: docker . Additional Information \u00b6 Extracts all Docker images in a Dockerfile . If you need to change the versioning format, read the versioning documentation to learn more.","title":"Automated Dependency Updates for Dockerfile"},{"location":"modules/manager/dockerfile/#file-matching","text":"By default, Renovate will check any files matching any of the following regular expressions: (^|/|\\.)Dockerfile$ (^|/)Dockerfile[^/]*$ For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/dockerfile/#supported-datasources","text":"This manager supports extracting the following datasources: docker .","title":"Supported datasources"},{"location":"modules/manager/dockerfile/#additional-information","text":"Extracts all Docker images in a Dockerfile . If you need to change the versioning format, read the versioning documentation to learn more.","title":"Additional Information"},{"location":"modules/manager/droneci/","text":"Renovate supports updating Droneci dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/).drone.yml$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: docker . Additional Information \u00b6 Extracts Docker-type dependencies from DroneCI config files. If you need to change the versioning format, read the versioning documentation to learn more.","title":"Automated Dependency Updates for Droneci"},{"location":"modules/manager/droneci/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/).drone.yml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/droneci/#supported-datasources","text":"This manager supports extracting the following datasources: docker .","title":"Supported datasources"},{"location":"modules/manager/droneci/#additional-information","text":"Extracts Docker-type dependencies from DroneCI config files. If you need to change the versioning format, read the versioning documentation to learn more.","title":"Additional Information"},{"location":"modules/manager/flux/","text":"Renovate supports updating Flux dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)flux-system/gotk-components\\.yaml$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: github-releases , helm . Additional Information \u00b6 This manager parses Flux YAML manifests and: Extracts helm dependencies from HelmRelease resources Extracts github-releases dependencies from system manifests ( flux-system/gotk-components.yaml files) and regenerates them when new versions of Flux are available The flux manager will only extract helm dependencies for HelmRelease resources linked to HelmRepository sources. HelmRelease resources linked to other kinds of sources like GitRepository or Bucket will be ignored. For the flux manager to properly link HelmRelease and HelmRepository resources, both of the following conditions must be met: The HelmRelease resource must either have its metadata.namespace property set or its spec.chart.spec.sourceRef.namespace property set The referenced HelmRepository resource must have its metadata.namespace property set Namespaces will not be inferred from the context (e.g. from the parent Kustomization ). Updating system manifests requires that either: The flux tool is pre-installed, or You run a Docker image based on containerbase/buildpack , such as the official Renovate images, and have binarySource=install configured By default, the flux manager will only match flux-system/gotk-components.yaml (i.e. system manifest) files. This is because there is no commonly accepted file/directory naming convention for Flux manifests and we don't want to check every single *.yaml file in repositories just in case some of them have Flux definitions. If most .yaml files in your repository are Flux manifests, then you could add this to your config: { \"flux\" : { \"fileMatch\" : [ \"\\\\.yaml$\" ] } } If instead you have all your Flux manifests inside a flux/ directory, you would add this: { \"flux\" : { \"fileMatch\" : [ \"flux/.+\\\\.yaml$\" ] } } If you need to change the versioning format, read the versioning documentation to learn more.","title":"Automated Dependency Updates for Flux"},{"location":"modules/manager/flux/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)flux-system/gotk-components\\.yaml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/flux/#supported-datasources","text":"This manager supports extracting the following datasources: github-releases , helm .","title":"Supported datasources"},{"location":"modules/manager/flux/#additional-information","text":"This manager parses Flux YAML manifests and: Extracts helm dependencies from HelmRelease resources Extracts github-releases dependencies from system manifests ( flux-system/gotk-components.yaml files) and regenerates them when new versions of Flux are available The flux manager will only extract helm dependencies for HelmRelease resources linked to HelmRepository sources. HelmRelease resources linked to other kinds of sources like GitRepository or Bucket will be ignored. For the flux manager to properly link HelmRelease and HelmRepository resources, both of the following conditions must be met: The HelmRelease resource must either have its metadata.namespace property set or its spec.chart.spec.sourceRef.namespace property set The referenced HelmRepository resource must have its metadata.namespace property set Namespaces will not be inferred from the context (e.g. from the parent Kustomization ). Updating system manifests requires that either: The flux tool is pre-installed, or You run a Docker image based on containerbase/buildpack , such as the official Renovate images, and have binarySource=install configured By default, the flux manager will only match flux-system/gotk-components.yaml (i.e. system manifest) files. This is because there is no commonly accepted file/directory naming convention for Flux manifests and we don't want to check every single *.yaml file in repositories just in case some of them have Flux definitions. If most .yaml files in your repository are Flux manifests, then you could add this to your config: { \"flux\" : { \"fileMatch\" : [ \"\\\\.yaml$\" ] } } If instead you have all your Flux manifests inside a flux/ directory, you would add this: { \"flux\" : { \"fileMatch\" : [ \"flux/.+\\\\.yaml$\" ] } } If you need to change the versioning format, read the versioning documentation to learn more.","title":"Additional Information"},{"location":"modules/manager/fvm/","text":"Renovate supports updating Fvm dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|\\/)\\.fvm\\/fvm_config\\.json$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: flutter-version . Additional Information \u00b6 Keeps the .fvm/fvm_config.json file updated.","title":"Automated Dependency Updates for Fvm"},{"location":"modules/manager/fvm/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|\\/)\\.fvm\\/fvm_config\\.json$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/fvm/#supported-datasources","text":"This manager supports extracting the following datasources: flutter-version .","title":"Supported datasources"},{"location":"modules/manager/fvm/#additional-information","text":"Keeps the .fvm/fvm_config.json file updated.","title":"Additional Information"},{"location":"modules/manager/git-submodules/","text":"Renovate supports updating Git Submodules dependencies. Enabling \u00b6 Git Submodules functionality is currently in beta testing so you must opt in to test it out. To enable it, add a configuration like this to either your bot config or your renovate.json : { \"git-submodules\": { \"enabled\": true } } If you find any bugs, please raise a bug report . If you find that it works well, then feedback on that would be welcome too. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/).gitmodules$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: git-refs . Additional Information \u00b6 Keeps publicly accessible Git submodules updated within a repository. Renovate does not support updating Git submodules that are hosted on a private repository. Subscribe to issue #10149 on GitHub to keep track of our progress towards supporting private Git submodules. You can customize the per-submodule checks of the git-submodules manager like this: { \"ignoreDeps\" : [ \"path/to/submodule\" , \"path/to/submodule2\" ], \"git-submodules\" : { \"enabled\" : true } }","title":"Automated Dependency Updates for Git Submodules"},{"location":"modules/manager/git-submodules/#enabling","text":"Git Submodules functionality is currently in beta testing so you must opt in to test it out. To enable it, add a configuration like this to either your bot config or your renovate.json : { \"git-submodules\": { \"enabled\": true } } If you find any bugs, please raise a bug report . If you find that it works well, then feedback on that would be welcome too.","title":"Enabling"},{"location":"modules/manager/git-submodules/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/).gitmodules$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/git-submodules/#supported-datasources","text":"This manager supports extracting the following datasources: git-refs .","title":"Supported datasources"},{"location":"modules/manager/git-submodules/#additional-information","text":"Keeps publicly accessible Git submodules updated within a repository. Renovate does not support updating Git submodules that are hosted on a private repository. Subscribe to issue #10149 on GitHub to keep track of our progress towards supporting private Git submodules. You can customize the per-submodule checks of the git-submodules manager like this: { \"ignoreDeps\" : [ \"path/to/submodule\" , \"path/to/submodule2\" ], \"git-submodules\" : { \"enabled\" : true } }","title":"Additional Information"},{"location":"modules/manager/github-actions/","text":"Renovate supports updating Github Actions dependencies. File Matching \u00b6 By default, Renovate will check any files matching any of the following regular expressions: ^(workflow-templates|\\.github\\/workflows)\\/[^/]+\\.ya?ml$ (^|\\/)action\\.ya?ml$ For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: github-tags , docker . Additional Information \u00b6 The github-actions manager extracts dependencies from GitHub Actions workflow and workflow template files. If you like to use digest pinning but want to follow the action version tag, you can use the following sample: name : build on : [ push ] jobs : build : runs-on : ubuntu-latest steps : - uses : actions/checkout@af513c7a016048ae468971c52ed77d9562c7c819 # renovate: tag=v1.0.0 Renovate will update the commit SHA but follow the GitHub tag you specified. Renovate can update digests that use SHA1 and SHA256 algorithms. If you want to automatically pin action digests add the helpers:pinGitHubActionDigests preset to the extends array: { \"extends\" : [ \"helpers:pinGitHubActionDigests\" ] }","title":"Automated Dependency Updates for Github Actions"},{"location":"modules/manager/github-actions/#file-matching","text":"By default, Renovate will check any files matching any of the following regular expressions: ^(workflow-templates|\\.github\\/workflows)\\/[^/]+\\.ya?ml$ (^|\\/)action\\.ya?ml$ For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/github-actions/#supported-datasources","text":"This manager supports extracting the following datasources: github-tags , docker .","title":"Supported datasources"},{"location":"modules/manager/github-actions/#additional-information","text":"The github-actions manager extracts dependencies from GitHub Actions workflow and workflow template files. If you like to use digest pinning but want to follow the action version tag, you can use the following sample: name : build on : [ push ] jobs : build : runs-on : ubuntu-latest steps : - uses : actions/checkout@af513c7a016048ae468971c52ed77d9562c7c819 # renovate: tag=v1.0.0 Renovate will update the commit SHA but follow the GitHub tag you specified. Renovate can update digests that use SHA1 and SHA256 algorithms. If you want to automatically pin action digests add the helpers:pinGitHubActionDigests preset to the extends array: { \"extends\" : [ \"helpers:pinGitHubActionDigests\" ] }","title":"Additional Information"},{"location":"modules/manager/gitlabci/","text":"Renovate supports updating Gitlabci dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: \\.gitlab-ci\\.yml$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: docker . Additional Information \u00b6 Extracts Docker dependencies from gitlab-ci.yml files. If you need to change the versioning format, read the versioning documentation to learn more. If you use Gitlab Dependency Proxy usage of the predefined variables CI_DEPENDENCY_PROXY_GROUP_IMAGE_PREFIX and CI_DEPENDENCY_PROXY_DIRECT_GROUP_IMAGE_PREFIX as image prefix is supported.","title":"Automated Dependency Updates for Gitlabci"},{"location":"modules/manager/gitlabci/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: \\.gitlab-ci\\.yml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/gitlabci/#supported-datasources","text":"This manager supports extracting the following datasources: docker .","title":"Supported datasources"},{"location":"modules/manager/gitlabci/#additional-information","text":"Extracts Docker dependencies from gitlab-ci.yml files. If you need to change the versioning format, read the versioning documentation to learn more. If you use Gitlab Dependency Proxy usage of the predefined variables CI_DEPENDENCY_PROXY_GROUP_IMAGE_PREFIX and CI_DEPENDENCY_PROXY_DIRECT_GROUP_IMAGE_PREFIX as image prefix is supported.","title":"Additional Information"},{"location":"modules/manager/gitlabci-include/","text":"Renovate supports updating Gitlabci Include dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: \\.gitlab-ci\\.yml$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: gitlab-tags . Additional Information \u00b6 Extracts \"includes\" dependencies from gitlab-ci.yml files.","title":"Automated Dependency Updates for Gitlabci Include"},{"location":"modules/manager/gitlabci-include/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: \\.gitlab-ci\\.yml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/gitlabci-include/#supported-datasources","text":"This manager supports extracting the following datasources: gitlab-tags .","title":"Supported datasources"},{"location":"modules/manager/gitlabci-include/#additional-information","text":"Extracts \"includes\" dependencies from gitlab-ci.yml files.","title":"Additional Information"},{"location":"modules/manager/gomod/","text":"Renovate supports updating Gomod dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)go.mod$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: go . Additional Information \u00b6 You might be interested in the following postUpdateOptions : gomodTidy - if you'd like Renovate to run go mod tidy after every update before raising the PR. This is implicitly enabled for major updates if the user has enabled the option gomodUpdateImportPaths gomodTidy1.17 - if you'd like Renovate to run go mod tidy -compat=1.17 after every update before raising the PR. gomodUpdateImportPaths - if you'd like Renovate to update your source import paths on major updates before raising the PR. gomodMassage - to enable massaging of all replace statements prior to running go so that they will be ignored. When Renovate is running using binarySource=docker (such as in the hosted Mend Renovate app) then it will pick the latest compatible version of Go to run, i.e. the latest 1.x release. Even if the go.mod has a version like go 1.14 , Renovate will treat it as a ^1.14 constraint and not =1.14 .","title":"Automated Dependency Updates for Gomod"},{"location":"modules/manager/gomod/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)go.mod$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/gomod/#supported-datasources","text":"This manager supports extracting the following datasources: go .","title":"Supported datasources"},{"location":"modules/manager/gomod/#additional-information","text":"You might be interested in the following postUpdateOptions : gomodTidy - if you'd like Renovate to run go mod tidy after every update before raising the PR. This is implicitly enabled for major updates if the user has enabled the option gomodUpdateImportPaths gomodTidy1.17 - if you'd like Renovate to run go mod tidy -compat=1.17 after every update before raising the PR. gomodUpdateImportPaths - if you'd like Renovate to update your source import paths on major updates before raising the PR. gomodMassage - to enable massaging of all replace statements prior to running go so that they will be ignored. When Renovate is running using binarySource=docker (such as in the hosted Mend Renovate app) then it will pick the latest compatible version of Go to run, i.e. the latest 1.x release. Even if the go.mod has a version like go 1.14 , Renovate will treat it as a ^1.14 constraint and not =1.14 .","title":"Additional Information"},{"location":"modules/manager/gradle/","text":"Renovate supports updating Gradle dependencies. File Matching \u00b6 By default, Renovate will check any files matching any of the following regular expressions: \\.gradle(\\.kts)?$ (^|\\/)gradle\\.properties$ (^|\\/)gradle\\/.+\\.toml$ \\.versions\\.toml$ For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: maven . Additional Information \u00b6 The gradle manager uses a custom parser written in JavaScript, similar to many others managers. It does not call gradle directly in order to extract a list of dependencies.","title":"Automated Dependency Updates for Gradle"},{"location":"modules/manager/gradle/#file-matching","text":"By default, Renovate will check any files matching any of the following regular expressions: \\.gradle(\\.kts)?$ (^|\\/)gradle\\.properties$ (^|\\/)gradle\\/.+\\.toml$ \\.versions\\.toml$ For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/gradle/#supported-datasources","text":"This manager supports extracting the following datasources: maven .","title":"Supported datasources"},{"location":"modules/manager/gradle/#additional-information","text":"The gradle manager uses a custom parser written in JavaScript, similar to many others managers. It does not call gradle directly in order to extract a list of dependencies.","title":"Additional Information"},{"location":"modules/manager/gradle-wrapper/","text":"Renovate supports updating Gradle Wrapper dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)gradle/wrapper/gradle-wrapper.properties$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: gradle-version . Additional Information \u00b6 Configuration for Gradle Wrapper updates. Changes here affect how Renovate updates the version of gradle in the wrapper, not how it uses the wrapper.","title":"Automated Dependency Updates for Gradle Wrapper"},{"location":"modules/manager/gradle-wrapper/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)gradle/wrapper/gradle-wrapper.properties$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/gradle-wrapper/#supported-datasources","text":"This manager supports extracting the following datasources: gradle-version .","title":"Supported datasources"},{"location":"modules/manager/gradle-wrapper/#additional-information","text":"Configuration for Gradle Wrapper updates. Changes here affect how Renovate updates the version of gradle in the wrapper, not how it uses the wrapper.","title":"Additional Information"},{"location":"modules/manager/helm-requirements/","text":"Renovate supports updating Helm Requirements dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)requirements\\.yaml$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: helm . Additional Information \u00b6 Renovate supports updating Helm Chart references within requirements.yaml files. If your Helm charts make use of repository Aliases then you will need to configure an aliases object in your config to tell Renovate where to look for them. If you need to change the versioning format, read the versioning documentation to learn more. To learn how to use Helm with private packages, read private package support, Package Manager Credentials for Artifact Updating, helm .","title":"Automated Dependency Updates for Helm Requirements"},{"location":"modules/manager/helm-requirements/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)requirements\\.yaml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/helm-requirements/#supported-datasources","text":"This manager supports extracting the following datasources: helm .","title":"Supported datasources"},{"location":"modules/manager/helm-requirements/#additional-information","text":"Renovate supports updating Helm Chart references within requirements.yaml files. If your Helm charts make use of repository Aliases then you will need to configure an aliases object in your config to tell Renovate where to look for them. If you need to change the versioning format, read the versioning documentation to learn more. To learn how to use Helm with private packages, read private package support, Package Manager Credentials for Artifact Updating, helm .","title":"Additional Information"},{"location":"modules/manager/helm-values/","text":"Renovate supports updating Helm Values dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)values.yaml$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: docker . Additional Information \u00b6 Renovate supports updating of Docker dependencies within Helm Chart values.yaml files or other YAML files that use the same format (via fileMatch configuration). Updates are performed if the files follow the conventional format used in most of the Helm charts: image : repository : 'some-docker/dependency' tag : v1.0.0 registry : registry.example.com # optional key, will default to \"docker.io\" coreImage : registry : docker.io repository : bitnami/harbor-core tag : 2.1.3-debian-10-r38 If you need to change the versioning format, read the versioning documentation to learn more.","title":"Automated Dependency Updates for Helm Values"},{"location":"modules/manager/helm-values/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)values.yaml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/helm-values/#supported-datasources","text":"This manager supports extracting the following datasources: docker .","title":"Supported datasources"},{"location":"modules/manager/helm-values/#additional-information","text":"Renovate supports updating of Docker dependencies within Helm Chart values.yaml files or other YAML files that use the same format (via fileMatch configuration). Updates are performed if the files follow the conventional format used in most of the Helm charts: image : repository : 'some-docker/dependency' tag : v1.0.0 registry : registry.example.com # optional key, will default to \"docker.io\" coreImage : registry : docker.io repository : bitnami/harbor-core tag : 2.1.3-debian-10-r38 If you need to change the versioning format, read the versioning documentation to learn more.","title":"Additional Information"},{"location":"modules/manager/helmfile/","text":"Renovate supports updating Helmfile dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)helmfile.yaml$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: helm , docker . Additional Information \u00b6 Checks helmfile.yaml files and extracts dependencies for the helm datasource. If your Helm charts make use of repository Aliases then you will need to configure an aliases object in your config to tell Renovate where to look for them. If you need to change the versioning format, read the versioning documentation to learn more.","title":"Automated Dependency Updates for Helmfile"},{"location":"modules/manager/helmfile/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)helmfile.yaml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/helmfile/#supported-datasources","text":"This manager supports extracting the following datasources: helm , docker .","title":"Supported datasources"},{"location":"modules/manager/helmfile/#additional-information","text":"Checks helmfile.yaml files and extracts dependencies for the helm datasource. If your Helm charts make use of repository Aliases then you will need to configure an aliases object in your config to tell Renovate where to look for them. If you need to change the versioning format, read the versioning documentation to learn more.","title":"Additional Information"},{"location":"modules/manager/helmsman/","text":"Renovate supports updating Helmsman dependencies. File Matching \u00b6 Because file names for helmsman cannot be easily determined automatically, Renovate will not attempt to match any helmsman files by default. For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: helm . Additional Information \u00b6 The helmsman manager is currently limited and does not support the full feature set of Helmsman , read about the limitations below. Non-configured fileMatch \u00b6 By default the helmsman manager has an empty array for its fileMatch configuration option, because there is no convention for file naming in practice. This means that helmsman won't search for any files, and you won't get any updates from the manager. To enable the helmsman manager, provide a valid fileMatch yourself, for example: { \"helmsman\" : { \"fileMatch\" : [ \"(^|/)desired_state\\\\.yaml$\" ] } } File format \u00b6 Currently, state files must be in the .yaml format. The .toml format is not supported.","title":"Automated Dependency Updates for Helmsman"},{"location":"modules/manager/helmsman/#file-matching","text":"Because file names for helmsman cannot be easily determined automatically, Renovate will not attempt to match any helmsman files by default. For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/helmsman/#supported-datasources","text":"This manager supports extracting the following datasources: helm .","title":"Supported datasources"},{"location":"modules/manager/helmsman/#additional-information","text":"The helmsman manager is currently limited and does not support the full feature set of Helmsman , read about the limitations below.","title":"Additional Information"},{"location":"modules/manager/helmsman/#non-configured-filematch","text":"By default the helmsman manager has an empty array for its fileMatch configuration option, because there is no convention for file naming in practice. This means that helmsman won't search for any files, and you won't get any updates from the manager. To enable the helmsman manager, provide a valid fileMatch yourself, for example: { \"helmsman\" : { \"fileMatch\" : [ \"(^|/)desired_state\\\\.yaml$\" ] } }","title":"Non-configured fileMatch"},{"location":"modules/manager/helmsman/#file-format","text":"Currently, state files must be in the .yaml format. The .toml format is not supported.","title":"File format"},{"location":"modules/manager/helmv3/","text":"Renovate supports updating Helmv3 dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)Chart.yaml$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: docker , helm . Additional Information \u00b6 Renovate supports updating Helm Chart references within requirements.yaml (Helm v2) and Chart.yaml (Helm v3) files. If your Helm charts make use of repository Aliases then you will need to configure an aliases object in your config to tell Renovate where to look for them. If you need to change the versioning format, read the versioning documentation to learn more. Private repositories and registries \u00b6 To use private sources of Helm charts, you must set the password and username you use to authenticate to the private source. For this you use a custom hostRules array. OCI registries \u00b6 { hostRules: [ { // global login matchHost: 'registry.gitlab.com', hostType: 'docker', username: '<some-username>', password: '<some-password>', }, { // for repository string oci://registry.gitlab.com/user/oci-helm-test matchHost: 'https://registry.gitlab.com/user/oci-helm-test', hostType: 'docker', username: '<some-username>', password: '<some-password>', }, ], } Helm repository \u00b6 { hostRules: [ { // global login matchHost: 'gitlab.com', username: '<some-username>', password: '<some-password>', }, { // specific repository matchHost: 'https://gitlab.com/api/v4/projects/xxxxxxx/packages/helm/stable', username: '<some-username>', password: '<some-password>', }, ], }","title":"Automated Dependency Updates for Helmv3"},{"location":"modules/manager/helmv3/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)Chart.yaml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/helmv3/#supported-datasources","text":"This manager supports extracting the following datasources: docker , helm .","title":"Supported datasources"},{"location":"modules/manager/helmv3/#additional-information","text":"Renovate supports updating Helm Chart references within requirements.yaml (Helm v2) and Chart.yaml (Helm v3) files. If your Helm charts make use of repository Aliases then you will need to configure an aliases object in your config to tell Renovate where to look for them. If you need to change the versioning format, read the versioning documentation to learn more.","title":"Additional Information"},{"location":"modules/manager/helmv3/#private-repositories-and-registries","text":"To use private sources of Helm charts, you must set the password and username you use to authenticate to the private source. For this you use a custom hostRules array.","title":"Private repositories and registries"},{"location":"modules/manager/helmv3/#oci-registries","text":"{ hostRules: [ { // global login matchHost: 'registry.gitlab.com', hostType: 'docker', username: '<some-username>', password: '<some-password>', }, { // for repository string oci://registry.gitlab.com/user/oci-helm-test matchHost: 'https://registry.gitlab.com/user/oci-helm-test', hostType: 'docker', username: '<some-username>', password: '<some-password>', }, ], }","title":"OCI registries"},{"location":"modules/manager/helmv3/#helm-repository","text":"{ hostRules: [ { // global login matchHost: 'gitlab.com', username: '<some-username>', password: '<some-password>', }, { // specific repository matchHost: 'https://gitlab.com/api/v4/projects/xxxxxxx/packages/helm/stable', username: '<some-username>', password: '<some-password>', }, ], }","title":"Helm repository"},{"location":"modules/manager/homebrew/","text":"Renovate supports updating Homebrew dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: ^Formula/[^/]+[.]rb$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: github-tags . Additional Information \u00b6","title":"Automated Dependency Updates for Homebrew"},{"location":"modules/manager/homebrew/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: ^Formula/[^/]+[.]rb$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/homebrew/#supported-datasources","text":"This manager supports extracting the following datasources: github-tags .","title":"Supported datasources"},{"location":"modules/manager/homebrew/#additional-information","text":"","title":"Additional Information"},{"location":"modules/manager/html/","text":"Renovate supports updating Html dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: \\.html?$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: cdnjs . Additional Information \u00b6 The html manager extracts scripts and CSS includes pointing to cdnjs. It differs from the cdnjs manager in that it detects if an integrity hash is already present and updates it too if found.","title":"Automated Dependency Updates for Html"},{"location":"modules/manager/html/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: \\.html?$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/html/#supported-datasources","text":"This manager supports extracting the following datasources: cdnjs .","title":"Supported datasources"},{"location":"modules/manager/html/#additional-information","text":"The html manager extracts scripts and CSS includes pointing to cdnjs. It differs from the cdnjs manager in that it detects if an integrity hash is already present and updates it too if found.","title":"Additional Information"},{"location":"modules/manager/jenkins/","text":"Renovate supports updating Jenkins dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)plugins\\.(txt|ya?ml)$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: jenkins-plugins . Additional Information \u00b6 The Jenkins manager supports a custom text or YAML format of the plugin list as described here . Only versions from the main Jenkins update center are supported. There are no strict filename rules, the convention is to name the file plugins.txt or plugins.yaml .","title":"Automated Dependency Updates for Jenkins"},{"location":"modules/manager/jenkins/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)plugins\\.(txt|ya?ml)$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/jenkins/#supported-datasources","text":"This manager supports extracting the following datasources: jenkins-plugins .","title":"Supported datasources"},{"location":"modules/manager/jenkins/#additional-information","text":"The Jenkins manager supports a custom text or YAML format of the plugin list as described here . Only versions from the main Jenkins update center are supported. There are no strict filename rules, the convention is to name the file plugins.txt or plugins.yaml .","title":"Additional Information"},{"location":"modules/manager/jsonnet-bundler/","text":"Renovate supports updating Jsonnet Bundler dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)jsonnetfile.json$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: git-tags . Additional Information \u00b6 Extracts dependencies from jsonnetfile.json files, updates jsonnetfile.lock.json and updates the vendor directory. Supports lock file maintenance . This plugin requires jsonnet-bundler >= v0.4.0 since previous versions don't support updating single dependencies.","title":"Automated Dependency Updates for Jsonnet Bundler"},{"location":"modules/manager/jsonnet-bundler/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)jsonnetfile.json$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/jsonnet-bundler/#supported-datasources","text":"This manager supports extracting the following datasources: git-tags .","title":"Supported datasources"},{"location":"modules/manager/jsonnet-bundler/#additional-information","text":"Extracts dependencies from jsonnetfile.json files, updates jsonnetfile.lock.json and updates the vendor directory. Supports lock file maintenance . This plugin requires jsonnet-bundler >= v0.4.0 since previous versions don't support updating single dependencies.","title":"Additional Information"},{"location":"modules/manager/kubernetes/","text":"Renovate supports updating Kubernetes dependencies. File Matching \u00b6 Because file names for kubernetes cannot be easily determined automatically, Renovate will not attempt to match any kubernetes files by default. For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: docker . Additional Information \u00b6 The kubernetes manager has no fileMatch default patterns, so it won't match any files until you configure it with a pattern. This is because there is no commonly accepted file/directory naming convention for Kubernetes YAML files and we don't want to check every single *.yaml file in repositories just in case any of them have Kubernetes definitions. If most .yaml files in your repository are Kubernetes ones, then you could add this to your config: { \"kubernetes\" : { \"fileMatch\" : [ \"\\\\.yaml$\" ] } } If instead you have them all inside a k8s/ directory, you would add this: { \"kubernetes\" : { \"fileMatch\" : [ \"k8s/.+\\\\.yaml$\" ] } } Or if it's just a single file then something like this: { \"kubernetes\" : { \"fileMatch\" : [ \"^config/k8s\\\\.yaml$\" ] } } If you need to change the versioning format, read the versioning documentation to learn more.","title":"Automated Dependency Updates for Kubernetes"},{"location":"modules/manager/kubernetes/#file-matching","text":"Because file names for kubernetes cannot be easily determined automatically, Renovate will not attempt to match any kubernetes files by default. For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/kubernetes/#supported-datasources","text":"This manager supports extracting the following datasources: docker .","title":"Supported datasources"},{"location":"modules/manager/kubernetes/#additional-information","text":"The kubernetes manager has no fileMatch default patterns, so it won't match any files until you configure it with a pattern. This is because there is no commonly accepted file/directory naming convention for Kubernetes YAML files and we don't want to check every single *.yaml file in repositories just in case any of them have Kubernetes definitions. If most .yaml files in your repository are Kubernetes ones, then you could add this to your config: { \"kubernetes\" : { \"fileMatch\" : [ \"\\\\.yaml$\" ] } } If instead you have them all inside a k8s/ directory, you would add this: { \"kubernetes\" : { \"fileMatch\" : [ \"k8s/.+\\\\.yaml$\" ] } } Or if it's just a single file then something like this: { \"kubernetes\" : { \"fileMatch\" : [ \"^config/k8s\\\\.yaml$\" ] } } If you need to change the versioning format, read the versioning documentation to learn more.","title":"Additional Information"},{"location":"modules/manager/kustomize/","text":"Renovate supports updating Kustomize dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)kustomization\\.ya?ml$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: docker , git-tags , github-tags , helm . Additional Information \u00b6 This package will manage the following parts of the kustomization.yaml file: remote resources image tags components helm charts remote bases (deprecated since kustomize v2.1.0) How It Works Renovate will search each repository for any kustomization.yaml files. Existing dependencies will be extracted from remote bases, image tags & Helm charts Renovate will resolve the dependency's source repository and check for SemVer tags if found. If an update was found, Renovate will update kustomization.yaml This manager uses three depType s to allow a fine-grained control of which dependencies are upgraded: Component Kustomization HelmChart Limitations Currently this hasn't been tested using HTTPS to fetch the repos The keys for the image tags can be in any order - name : image/name newTag : v0.0.1 # or - newTag : v0.0.1 name : image/name Digests can be pinned in newTag or digest : - name : image/name newTag : v0.0.1@sha256:3eeba3e2caa30d2aba0fd78a34c1bbeebaa1b96c7aa3c95ec9bac44163c5ca4f # without a version, digests are tracked as :latest - name : image/name digest : sha256:3eeba3e2caa30d2aba0fd78a34c1bbeebaa1b96c7aa3c95ec9bac44163c5ca4f The image's repository can be changed with newName : - name : image/name newName : custom-image/name:v0.0.1 - name : image/name newName : custom-image/name:v0.0.1@sha256:3eeba3e2caa30d2aba0fd78a34c1bbeebaa1b96c7aa3c95ec9bac44163c5ca4f - name : image/name newName : custom-image/name@sha256:3eeba3e2caa30d2aba0fd78a34c1bbeebaa1b96c7aa3c95ec9bac44163c5ca4f - name : image/name newName : custom-image/name newTag : v0.0.1@sha256:3eeba3e2caa30d2aba0fd78a34c1bbeebaa1b96c7aa3c95ec9bac44163c5ca4f - name : image/name newName : custom-image/name digest : sha256:3eeba3e2caa30d2aba0fd78a34c1bbeebaa1b96c7aa3c95ec9bac44163c5ca4f Images with values ignored by Kustomize will be skipped to avoid ambiguity: # bad: skipped because newTag: is ignored when digest: is set - name : image/name newTag : v0.0.1 digest : sha256:3eeba3e2caa30d2aba0fd78a34c1bbeebaa1b96c7aa3c95ec9bac44163c5ca4f # good: - name : image/name newTag : v0.0.1@sha256:3eeba3e2caa30d2aba0fd78a34c1bbeebaa1b96c7aa3c95ec9bac44163c5ca4f","title":"Automated Dependency Updates for Kustomize"},{"location":"modules/manager/kustomize/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)kustomization\\.ya?ml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/kustomize/#supported-datasources","text":"This manager supports extracting the following datasources: docker , git-tags , github-tags , helm .","title":"Supported datasources"},{"location":"modules/manager/kustomize/#additional-information","text":"This package will manage the following parts of the kustomization.yaml file: remote resources image tags components helm charts remote bases (deprecated since kustomize v2.1.0) How It Works Renovate will search each repository for any kustomization.yaml files. Existing dependencies will be extracted from remote bases, image tags & Helm charts Renovate will resolve the dependency's source repository and check for SemVer tags if found. If an update was found, Renovate will update kustomization.yaml This manager uses three depType s to allow a fine-grained control of which dependencies are upgraded: Component Kustomization HelmChart Limitations Currently this hasn't been tested using HTTPS to fetch the repos The keys for the image tags can be in any order - name : image/name newTag : v0.0.1 # or - newTag : v0.0.1 name : image/name Digests can be pinned in newTag or digest : - name : image/name newTag : v0.0.1@sha256:3eeba3e2caa30d2aba0fd78a34c1bbeebaa1b96c7aa3c95ec9bac44163c5ca4f # without a version, digests are tracked as :latest - name : image/name digest : sha256:3eeba3e2caa30d2aba0fd78a34c1bbeebaa1b96c7aa3c95ec9bac44163c5ca4f The image's repository can be changed with newName : - name : image/name newName : custom-image/name:v0.0.1 - name : image/name newName : custom-image/name:v0.0.1@sha256:3eeba3e2caa30d2aba0fd78a34c1bbeebaa1b96c7aa3c95ec9bac44163c5ca4f - name : image/name newName : custom-image/name@sha256:3eeba3e2caa30d2aba0fd78a34c1bbeebaa1b96c7aa3c95ec9bac44163c5ca4f - name : image/name newName : custom-image/name newTag : v0.0.1@sha256:3eeba3e2caa30d2aba0fd78a34c1bbeebaa1b96c7aa3c95ec9bac44163c5ca4f - name : image/name newName : custom-image/name digest : sha256:3eeba3e2caa30d2aba0fd78a34c1bbeebaa1b96c7aa3c95ec9bac44163c5ca4f Images with values ignored by Kustomize will be skipped to avoid ambiguity: # bad: skipped because newTag: is ignored when digest: is set - name : image/name newTag : v0.0.1 digest : sha256:3eeba3e2caa30d2aba0fd78a34c1bbeebaa1b96c7aa3c95ec9bac44163c5ca4f # good: - name : image/name newTag : v0.0.1@sha256:3eeba3e2caa30d2aba0fd78a34c1bbeebaa1b96c7aa3c95ec9bac44163c5ca4f","title":"Additional Information"},{"location":"modules/manager/leiningen/","text":"Renovate supports updating Leiningen dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)project\\.clj$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: clojure . Additional Information \u00b6 Extracts Maven-type dependencies.","title":"Automated Dependency Updates for Leiningen"},{"location":"modules/manager/leiningen/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)project\\.clj$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/leiningen/#supported-datasources","text":"This manager supports extracting the following datasources: clojure .","title":"Supported datasources"},{"location":"modules/manager/leiningen/#additional-information","text":"Extracts Maven-type dependencies.","title":"Additional Information"},{"location":"modules/manager/maven/","text":"Renovate supports updating Maven dependencies. File Matching \u00b6 By default, Renovate will check any files matching any of the following regular expressions: (^|/|\\.)pom\\.xml$ ^(((\\.mvn)|(\\.m2))/)?settings\\.xml$ For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: maven . Additional Information \u00b6 The maven manager focuses on extracting dependencies from pom.xml . It uses the official Maven versioning scheme.","title":"Automated Dependency Updates for Maven"},{"location":"modules/manager/maven/#file-matching","text":"By default, Renovate will check any files matching any of the following regular expressions: (^|/|\\.)pom\\.xml$ ^(((\\.mvn)|(\\.m2))/)?settings\\.xml$ For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/maven/#supported-datasources","text":"This manager supports extracting the following datasources: maven .","title":"Supported datasources"},{"location":"modules/manager/maven/#additional-information","text":"The maven manager focuses on extracting dependencies from pom.xml . It uses the official Maven versioning scheme.","title":"Additional Information"},{"location":"modules/manager/meteor/","text":"Renovate supports updating Meteor dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)package.js$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: npm . Additional Information \u00b6","title":"Automated Dependency Updates for Meteor"},{"location":"modules/manager/meteor/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)package.js$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/meteor/#supported-datasources","text":"This manager supports extracting the following datasources: npm .","title":"Supported datasources"},{"location":"modules/manager/meteor/#additional-information","text":"","title":"Additional Information"},{"location":"modules/manager/mix/","text":"Renovate supports updating Mix dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)mix\\.exs$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: hex . Additional Information \u00b6 The mix manager extracts dependencies for the hex datasource and uses Renovate's implementation of Hex SemVer to evaluate updates. The mix package manager itself is also used to keep the lock file up-to-date.","title":"Automated Dependency Updates for Mix"},{"location":"modules/manager/mix/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)mix\\.exs$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/mix/#supported-datasources","text":"This manager supports extracting the following datasources: hex .","title":"Supported datasources"},{"location":"modules/manager/mix/#additional-information","text":"The mix manager extracts dependencies for the hex datasource and uses Renovate's implementation of Hex SemVer to evaluate updates. The mix package manager itself is also used to keep the lock file up-to-date.","title":"Additional Information"},{"location":"modules/manager/nodenv/","text":"Renovate supports updating Nodenv dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/).node-version$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: github-tags . Additional Information \u00b6 Simply keeps the .node-version file updated.","title":"Automated Dependency Updates for Nodenv"},{"location":"modules/manager/nodenv/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/).node-version$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/nodenv/#supported-datasources","text":"This manager supports extracting the following datasources: github-tags .","title":"Supported datasources"},{"location":"modules/manager/nodenv/#additional-information","text":"Simply keeps the .node-version file updated.","title":"Additional Information"},{"location":"modules/manager/npm/","text":"Renovate supports updating Npm dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)package.json$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: github-tags , npm . Additional Information \u00b6 The following depTypes are currently supported by the npm manager : dependencies devDependencies optionalDependencies peerDependencies engines : Renovate will update any node , npm and yarn version specified under engines . volta : Renovate will update any node , npm and yarn version specified under volta . packageManager","title":"Automated Dependency Updates for Npm"},{"location":"modules/manager/npm/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)package.json$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/npm/#supported-datasources","text":"This manager supports extracting the following datasources: github-tags , npm .","title":"Supported datasources"},{"location":"modules/manager/npm/#additional-information","text":"The following depTypes are currently supported by the npm manager : dependencies devDependencies optionalDependencies peerDependencies engines : Renovate will update any node , npm and yarn version specified under engines . volta : Renovate will update any node , npm and yarn version specified under volta . packageManager","title":"Additional Information"},{"location":"modules/manager/nuget/","text":"Renovate supports updating Nuget dependencies. File Matching \u00b6 By default, Renovate will check any files matching any of the following regular expressions: \\.(?:cs|fs|vb)proj$ \\.(?:props|targets)$ (^|\\/)dotnet-tools\\.json$ (^|\\/)global\\.json$ For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: nuget . Additional Information \u00b6 The nuget configuration object is used to control settings for the NuGet package manager. The NuGet package manager supports a SDK-style .csproj / .fsproj / .vbproj / .props / .targets format, as described here . This means that .NET Core projects are all supported but any .NET Framework projects need to be updated to the new .csproj / .fsproj / .vbproj / .props / .targets format in order to be detected and supported by Renovate. The NuGet manager also supports global.json and dotnet-tools.json SDK files.","title":"Automated Dependency Updates for Nuget"},{"location":"modules/manager/nuget/#file-matching","text":"By default, Renovate will check any files matching any of the following regular expressions: \\.(?:cs|fs|vb)proj$ \\.(?:props|targets)$ (^|\\/)dotnet-tools\\.json$ (^|\\/)global\\.json$ For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/nuget/#supported-datasources","text":"This manager supports extracting the following datasources: nuget .","title":"Supported datasources"},{"location":"modules/manager/nuget/#additional-information","text":"The nuget configuration object is used to control settings for the NuGet package manager. The NuGet package manager supports a SDK-style .csproj / .fsproj / .vbproj / .props / .targets format, as described here . This means that .NET Core projects are all supported but any .NET Framework projects need to be updated to the new .csproj / .fsproj / .vbproj / .props / .targets format in order to be detected and supported by Renovate. The NuGet manager also supports global.json and dotnet-tools.json SDK files.","title":"Additional Information"},{"location":"modules/manager/nvm/","text":"Renovate supports updating Nvm dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)\\.nvmrc$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: github-tags . Additional Information \u00b6 Simply keeps the .nvmrc file updated.","title":"Automated Dependency Updates for Nvm"},{"location":"modules/manager/nvm/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)\\.nvmrc$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/nvm/#supported-datasources","text":"This manager supports extracting the following datasources: github-tags .","title":"Supported datasources"},{"location":"modules/manager/nvm/#additional-information","text":"Simply keeps the .nvmrc file updated.","title":"Additional Information"},{"location":"modules/manager/pip-compile/","text":"Renovate supports updating Pip Compile dependencies. File Matching \u00b6 Because file names for pip-compile cannot be easily determined automatically, Renovate will not attempt to match any pip-compile files by default. For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: pypi . Additional Information \u00b6 Due to limited functionality, the pip-compile manager should be considered in an \"alpha\" stage, which means it's not ready for production use for the majority of end users. We welcome feedback and bug reports! The current implementation has some limitations. Read the full document before you start using the pip-compile manager. Non-configured fileMatch \u00b6 The pip-compile manager has an empty array for default fileMatch , meaning it won't match any files ever by default. You can \"activate\" the manager by specifying a fileMatch pattern such as: { \"pip-compile\" : { \"fileMatch\" : [ \"(^|/)requirements\\\\.in$\" ] } } Assumption of .in / .txt \u00b6 If Renovate matches/extracts a file, it assumes that the corresponding output file is found by swapping the .in for .txt . e.g. requirements.in => requirements.txt It will not work if files are in separate directories, including input/requirements.in and output/requirements.txt . If no .in suffix is found, then a .txt suffix is appended for the output file, e.g. foo.file would look for a corresponding foo.file.txt . We intend to make the mapping configurable in future iterations. Configuration of Python version \u00b6 By default Renovate uses the latest version of Python. To get Renovate to use another version of Python, add a contraints` rule to the Renovate config: { \"constraints\" : { \"python\" : \"3.7\" } } pip-compile arguments \u00b6 Renovate reads the requirements.txt file and extracts these pip-compile arguments: --generate-hashes --allow-unsafe --no-emit-index-url","title":"Automated Dependency Updates for Pip Compile"},{"location":"modules/manager/pip-compile/#file-matching","text":"Because file names for pip-compile cannot be easily determined automatically, Renovate will not attempt to match any pip-compile files by default. For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/pip-compile/#supported-datasources","text":"This manager supports extracting the following datasources: pypi .","title":"Supported datasources"},{"location":"modules/manager/pip-compile/#additional-information","text":"Due to limited functionality, the pip-compile manager should be considered in an \"alpha\" stage, which means it's not ready for production use for the majority of end users. We welcome feedback and bug reports! The current implementation has some limitations. Read the full document before you start using the pip-compile manager.","title":"Additional Information"},{"location":"modules/manager/pip-compile/#non-configured-filematch","text":"The pip-compile manager has an empty array for default fileMatch , meaning it won't match any files ever by default. You can \"activate\" the manager by specifying a fileMatch pattern such as: { \"pip-compile\" : { \"fileMatch\" : [ \"(^|/)requirements\\\\.in$\" ] } }","title":"Non-configured fileMatch"},{"location":"modules/manager/pip-compile/#assumption-of-intxt","text":"If Renovate matches/extracts a file, it assumes that the corresponding output file is found by swapping the .in for .txt . e.g. requirements.in => requirements.txt It will not work if files are in separate directories, including input/requirements.in and output/requirements.txt . If no .in suffix is found, then a .txt suffix is appended for the output file, e.g. foo.file would look for a corresponding foo.file.txt . We intend to make the mapping configurable in future iterations.","title":"Assumption of .in/.txt"},{"location":"modules/manager/pip-compile/#configuration-of-python-version","text":"By default Renovate uses the latest version of Python. To get Renovate to use another version of Python, add a contraints` rule to the Renovate config: { \"constraints\" : { \"python\" : \"3.7\" } }","title":"Configuration of Python version"},{"location":"modules/manager/pip-compile/#pip-compile-arguments","text":"Renovate reads the requirements.txt file and extracts these pip-compile arguments: --generate-hashes --allow-unsafe --no-emit-index-url","title":"pip-compile arguments"},{"location":"modules/manager/pip_requirements/","text":"Renovate supports updating Pip_requirements dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)([\\w-]*)requirements\\.(txt|pip)$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: pypi , git-tags . Additional Information \u00b6 Supports requirements.txt and requirements.pip files. The default file pattern is fairly flexible in an attempt to catch similarly named ones too but may be extended/changed.","title":"Automated Dependency Updates for Pip_requirements"},{"location":"modules/manager/pip_requirements/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)([\\w-]*)requirements\\.(txt|pip)$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/pip_requirements/#supported-datasources","text":"This manager supports extracting the following datasources: pypi , git-tags .","title":"Supported datasources"},{"location":"modules/manager/pip_requirements/#additional-information","text":"Supports requirements.txt and requirements.pip files. The default file pattern is fairly flexible in an attempt to catch similarly named ones too but may be extended/changed.","title":"Additional Information"},{"location":"modules/manager/pip_setup/","text":"Renovate supports updating Pip_setup dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)setup.py$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: pypi . Additional Information \u00b6 setup.py files are parsed by calling out to python and then using a mock to detect imported modules.","title":"Automated Dependency Updates for Pip_setup"},{"location":"modules/manager/pip_setup/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)setup.py$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/pip_setup/#supported-datasources","text":"This manager supports extracting the following datasources: pypi .","title":"Supported datasources"},{"location":"modules/manager/pip_setup/#additional-information","text":"setup.py files are parsed by calling out to python and then using a mock to detect imported modules.","title":"Additional Information"},{"location":"modules/manager/pipenv/","text":"Renovate supports updating Pipenv dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)Pipfile$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: pypi . Additional Information \u00b6 Pipenv.lock updating is supported. The following depTypes are supported by the Pipenv manager: packages dev-packages","title":"Automated Dependency Updates for Pipenv"},{"location":"modules/manager/pipenv/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)Pipfile$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/pipenv/#supported-datasources","text":"This manager supports extracting the following datasources: pypi .","title":"Supported datasources"},{"location":"modules/manager/pipenv/#additional-information","text":"Pipenv.lock updating is supported. The following depTypes are supported by the Pipenv manager: packages dev-packages","title":"Additional Information"},{"location":"modules/manager/poetry/","text":"Renovate supports updating Poetry dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)pyproject\\.toml$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: pypi . Additional Information \u00b6 Both Poetry 0.x and 1.x versions are supported. Whenever the pyproject.toml file is updated, the Poetry lock file will be checked for updates as well. The following depTypes are supported by the Poetry manager: dependencies dev-dependencies extras","title":"Automated Dependency Updates for Poetry"},{"location":"modules/manager/poetry/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)pyproject\\.toml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/poetry/#supported-datasources","text":"This manager supports extracting the following datasources: pypi .","title":"Supported datasources"},{"location":"modules/manager/poetry/#additional-information","text":"Both Poetry 0.x and 1.x versions are supported. Whenever the pyproject.toml file is updated, the Poetry lock file will be checked for updates as well. The following depTypes are supported by the Poetry manager: dependencies dev-dependencies extras","title":"Additional Information"},{"location":"modules/manager/pre-commit/","text":"Renovate supports updating Pre Commit dependencies. Enabling \u00b6 Pre Commit functionality is currently in beta testing so you must opt in to test it out. To enable it, add a configuration like this to either your bot config or your renovate.json : { \"pre-commit\": { \"enabled\": true } } If you find any bugs, please raise a bug report . If you find that it works well, then feedback on that would be welcome too. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)\\.pre-commit-config\\.yaml$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: github-tags , gitlab-tags . Additional Information \u00b6 Important note : The pre-commit manager is disabled by default and must be opted into through config. Renovate's approach to version updating is not fully aligned with pre-commit upgrade and this has caused frustration for pre-commit 's creator/maintainer. Attempts to work with the pre-commit project to fix these gaps have been rejected, so we have chosen to disable the manager by default indefinitely. Please do not contact the pre-commit project/maintainer about any Renovate-related topic. To view a list of open issues related to the pre-commit manager in Renovate, see the filtered list using the manager:pre-commit label . When enabled, Renovate supports updating of Git dependencies within pre-commit configuration .pre-commit-config.yaml files or other YAML files that use the same format (via fileMatch configuration). Updates are performed if the files follow the conventional format used in typical pre-commit files: repos : - repo : https://github.com/pre-commit/pre-commit-hooks rev : v1.0.0 hooks : - id : some-hook-id To enable the pre-commit manager, add the following config: { \"pre-commit\" : { \"enabled\" : true } } Alternatively, add :enablePreCommit to your extends array.","title":"Automated Dependency Updates for Pre Commit"},{"location":"modules/manager/pre-commit/#enabling","text":"Pre Commit functionality is currently in beta testing so you must opt in to test it out. To enable it, add a configuration like this to either your bot config or your renovate.json : { \"pre-commit\": { \"enabled\": true } } If you find any bugs, please raise a bug report . If you find that it works well, then feedback on that would be welcome too.","title":"Enabling"},{"location":"modules/manager/pre-commit/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)\\.pre-commit-config\\.yaml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/pre-commit/#supported-datasources","text":"This manager supports extracting the following datasources: github-tags , gitlab-tags .","title":"Supported datasources"},{"location":"modules/manager/pre-commit/#additional-information","text":"Important note : The pre-commit manager is disabled by default and must be opted into through config. Renovate's approach to version updating is not fully aligned with pre-commit upgrade and this has caused frustration for pre-commit 's creator/maintainer. Attempts to work with the pre-commit project to fix these gaps have been rejected, so we have chosen to disable the manager by default indefinitely. Please do not contact the pre-commit project/maintainer about any Renovate-related topic. To view a list of open issues related to the pre-commit manager in Renovate, see the filtered list using the manager:pre-commit label . When enabled, Renovate supports updating of Git dependencies within pre-commit configuration .pre-commit-config.yaml files or other YAML files that use the same format (via fileMatch configuration). Updates are performed if the files follow the conventional format used in typical pre-commit files: repos : - repo : https://github.com/pre-commit/pre-commit-hooks rev : v1.0.0 hooks : - id : some-hook-id To enable the pre-commit manager, add the following config: { \"pre-commit\" : { \"enabled\" : true } } Alternatively, add :enablePreCommit to your extends array.","title":"Additional Information"},{"location":"modules/manager/pub/","text":"Renovate supports updating Pub dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)pubspec\\.ya?ml$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: dart . Additional Information \u00b6 This manager is used to keep pubspec files up-to-date.","title":"Automated Dependency Updates for Pub"},{"location":"modules/manager/pub/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)pubspec\\.ya?ml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/pub/#supported-datasources","text":"This manager supports extracting the following datasources: dart .","title":"Supported datasources"},{"location":"modules/manager/pub/#additional-information","text":"This manager is used to keep pubspec files up-to-date.","title":"Additional Information"},{"location":"modules/manager/pyenv/","text":"Renovate supports updating Pyenv dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/).python-version$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: docker . Additional Information \u00b6 Simply keeps the .python-version file updated.","title":"Automated Dependency Updates for Pyenv"},{"location":"modules/manager/pyenv/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/).python-version$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/pyenv/#supported-datasources","text":"This manager supports extracting the following datasources: docker .","title":"Supported datasources"},{"location":"modules/manager/pyenv/#additional-information","text":"Simply keeps the .python-version file updated.","title":"Additional Information"},{"location":"modules/manager/regex/","text":"The regex manager is designed to allow users to manually configure Renovate for how to find dependencies that aren't detected by the built-in package managers. This manager is unique in Renovate in that: It is configurable via regex named capture groups Through the use of the regexManagers config, multiple \"regex managers\" can be created for the same repository It can extract any datasource Required Fields \u00b6 The first two required fields are fileMatch and matchStrings . fileMatch works the same as any manager, while matchStrings is a regexManagers concept and is used for configuring a regular expression with named capture groups. In order for Renovate to look up a dependency and decide about updates, it then needs the following information about each dependency: The dependency's name Which datasource to look up (e.g. npm, Docker, GitHub tags, etc) Which version scheme to apply (defaults to semver , but also may be other values like pep440 ) Configuration-wise, it works like this: You must capture the currentValue of the dependency in a named capture group You must have either a depName capture group or a depNameTemplate config field You can optionally have a packageName capture group or a packageNameTemplate if it differs from depName You must have either a datasource capture group or a datasourceTemplate config field You can optionally have a depType capture group or a depTypeTemplate config field You can optionally have a versioning capture group or a versioningTemplate config field. If neither are present, semver will be used as the default You can optionally have an extractVersion capture group or an extractVersionTemplate config field You can optionally have a currentDigest capture group. You can optionally have a registryUrl capture group or a registryUrlTemplate config field If it's a valid URL, it will be converted to the registryUrls field as a single-length array. Regular Expression Capture Groups \u00b6 To be fully effective with the regex manager, you will need to understand regular expressions and named capture groups, although sometimes enough examples can compensate for lack of experience. Consider this Dockerfile : FROM node:12 ENV YARN_VERSION = 1 .19.1 RUN curl -o- -L https://yarnpkg.com/install.sh | bash -s -- --version ${ YARN_VERSION } You would need to capture the currentValue using a named capture group, like so: ENV YARN_VERSION=(?<currentValue>.*?)\\\\n . If you're looking for an online regex testing tool that supports capture groups, try https://regex101.com/ . Be aware that backslashes ( '\\' ) of the resulting regex have to still be escaped e.g. \\n\\s --> \\\\n\\\\s . You can use the Code Generator in the sidebar and copy the regex in the generated \"Alternative syntax\" comment into JSON. Configuration templates \u00b6 In many cases, named capture groups alone won't be enough and you'll need to configure Renovate with additional information about how to look up a dependency. Continuing the above example with Yarn, here is the full config: { \"regexManagers\" : [ { \"fileMatch\" : [ \"^Dockerfile$\" ], \"matchStrings\" : [ \"ENV YARN_VERSION=(?<currentValue>.*?)\\\\n\" ], \"depNameTemplate\" : \"yarn\" , \"datasourceTemplate\" : \"npm\" } ] } Advanced Capture \u00b6 Let's say that your Dockerfile has many ENV variables you want to keep updated and you prefer not to write one regexManagers rule per variable. Instead you could enhance your Dockerfile like the following: ARG IMAGE = node:12@sha256:6e5264cd4cfaefd7174b2bc10c7f9a1c2b99d98d127fc57a802d264da9fb43bd FROM ${IMAGE} # renovate: datasource = github-tags depName = nodejs/node versioning = node ENV NODE_VERSION = 10 .19.0 # renovate: datasource = github-releases depName = composer/composer ENV COMPOSER_VERSION = 1 .9.3 # renovate: datasource=docker depName=docker versioning=docker ENV DOCKER_VERSION = 19 .03.1 # renovate: datasource=npm depName=yarn ENV YARN_VERSION = 1 .19.1 The above (obviously not a complete Dockerfile , but abbreviated for this example), could then be supported accordingly: { \"regexManagers\" : [ { \"fileMatch\" : [ \"^Dockerfile$\" ], \"matchStrings\" : [ \"datasource=(?<datasource>.*?) depName=(?<depName>.*?)( versioning=(?<versioning>.*?))?\\\\sENV .*?_VERSION=(?<currentValue>.*)\\\\s\" ], \"versioningTemplate\" : \"{{#if versioning}}{{{versioning}}}{{else}}semver{{/if}}\" }, { \"fileMatch\" : [ \"^Dockerfile$\" ], \"matchStrings\" : [ \"ARG IMAGE=(?<depName>.*?):(?<currentValue>.*?)@(?<currentDigest>sha256:[a-f0-9]+)s\" ], \"datasourceTemplate\" : \"docker\" } ] } In the above the versioningTemplate is not actually necessary because Renovate already defaults to semver versioning, but it has been included to help illustrate why we call these fields templates . They are named this way because they are compiled using Handlebars and so can be composed from values you collect in named capture groups. You will usually want to use the tripe brace {{{ }}} template (e.v. {{{versioning}}} to be safe because Handlebars escapes special characters by default with double braces. By adding the comments to the Dockerfile , you can see that instead of four separate regexManagers being required, there is now only one - and the Dockerfile itself is now somewhat better documented too. The syntax we used there is completely arbitrary and you may choose your own instead if you prefer - just be sure to update your matchStrings regex.","title":"Custom Manager Support using Regex"},{"location":"modules/manager/regex/#required-fields","text":"The first two required fields are fileMatch and matchStrings . fileMatch works the same as any manager, while matchStrings is a regexManagers concept and is used for configuring a regular expression with named capture groups. In order for Renovate to look up a dependency and decide about updates, it then needs the following information about each dependency: The dependency's name Which datasource to look up (e.g. npm, Docker, GitHub tags, etc) Which version scheme to apply (defaults to semver , but also may be other values like pep440 ) Configuration-wise, it works like this: You must capture the currentValue of the dependency in a named capture group You must have either a depName capture group or a depNameTemplate config field You can optionally have a packageName capture group or a packageNameTemplate if it differs from depName You must have either a datasource capture group or a datasourceTemplate config field You can optionally have a depType capture group or a depTypeTemplate config field You can optionally have a versioning capture group or a versioningTemplate config field. If neither are present, semver will be used as the default You can optionally have an extractVersion capture group or an extractVersionTemplate config field You can optionally have a currentDigest capture group. You can optionally have a registryUrl capture group or a registryUrlTemplate config field If it's a valid URL, it will be converted to the registryUrls field as a single-length array.","title":"Required Fields"},{"location":"modules/manager/regex/#regular-expression-capture-groups","text":"To be fully effective with the regex manager, you will need to understand regular expressions and named capture groups, although sometimes enough examples can compensate for lack of experience. Consider this Dockerfile : FROM node:12 ENV YARN_VERSION = 1 .19.1 RUN curl -o- -L https://yarnpkg.com/install.sh | bash -s -- --version ${ YARN_VERSION } You would need to capture the currentValue using a named capture group, like so: ENV YARN_VERSION=(?<currentValue>.*?)\\\\n . If you're looking for an online regex testing tool that supports capture groups, try https://regex101.com/ . Be aware that backslashes ( '\\' ) of the resulting regex have to still be escaped e.g. \\n\\s --> \\\\n\\\\s . You can use the Code Generator in the sidebar and copy the regex in the generated \"Alternative syntax\" comment into JSON.","title":"Regular Expression Capture Groups"},{"location":"modules/manager/regex/#configuration-templates","text":"In many cases, named capture groups alone won't be enough and you'll need to configure Renovate with additional information about how to look up a dependency. Continuing the above example with Yarn, here is the full config: { \"regexManagers\" : [ { \"fileMatch\" : [ \"^Dockerfile$\" ], \"matchStrings\" : [ \"ENV YARN_VERSION=(?<currentValue>.*?)\\\\n\" ], \"depNameTemplate\" : \"yarn\" , \"datasourceTemplate\" : \"npm\" } ] }","title":"Configuration templates"},{"location":"modules/manager/regex/#advanced-capture","text":"Let's say that your Dockerfile has many ENV variables you want to keep updated and you prefer not to write one regexManagers rule per variable. Instead you could enhance your Dockerfile like the following: ARG IMAGE = node:12@sha256:6e5264cd4cfaefd7174b2bc10c7f9a1c2b99d98d127fc57a802d264da9fb43bd FROM ${IMAGE} # renovate: datasource = github-tags depName = nodejs/node versioning = node ENV NODE_VERSION = 10 .19.0 # renovate: datasource = github-releases depName = composer/composer ENV COMPOSER_VERSION = 1 .9.3 # renovate: datasource=docker depName=docker versioning=docker ENV DOCKER_VERSION = 19 .03.1 # renovate: datasource=npm depName=yarn ENV YARN_VERSION = 1 .19.1 The above (obviously not a complete Dockerfile , but abbreviated for this example), could then be supported accordingly: { \"regexManagers\" : [ { \"fileMatch\" : [ \"^Dockerfile$\" ], \"matchStrings\" : [ \"datasource=(?<datasource>.*?) depName=(?<depName>.*?)( versioning=(?<versioning>.*?))?\\\\sENV .*?_VERSION=(?<currentValue>.*)\\\\s\" ], \"versioningTemplate\" : \"{{#if versioning}}{{{versioning}}}{{else}}semver{{/if}}\" }, { \"fileMatch\" : [ \"^Dockerfile$\" ], \"matchStrings\" : [ \"ARG IMAGE=(?<depName>.*?):(?<currentValue>.*?)@(?<currentDigest>sha256:[a-f0-9]+)s\" ], \"datasourceTemplate\" : \"docker\" } ] } In the above the versioningTemplate is not actually necessary because Renovate already defaults to semver versioning, but it has been included to help illustrate why we call these fields templates . They are named this way because they are compiled using Handlebars and so can be composed from values you collect in named capture groups. You will usually want to use the tripe brace {{{ }}} template (e.v. {{{versioning}}} to be safe because Handlebars escapes special characters by default with double braces. By adding the comments to the Dockerfile , you can see that instead of four separate regexManagers being required, there is now only one - and the Dockerfile itself is now somewhat better documented too. The syntax we used there is completely arbitrary and you may choose your own instead if you prefer - just be sure to update your matchStrings regex.","title":"Advanced Capture"},{"location":"modules/manager/ruby-version/","text":"Renovate supports updating Ruby Version dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)\\.ruby-version$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: ruby-version . Additional Information \u00b6 This will maintain .ruby-version files. Available versions will be determined from the official Ruby downloads page.","title":"Automated Dependency Updates for Ruby Version"},{"location":"modules/manager/ruby-version/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)\\.ruby-version$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/ruby-version/#supported-datasources","text":"This manager supports extracting the following datasources: ruby-version .","title":"Supported datasources"},{"location":"modules/manager/ruby-version/#additional-information","text":"This will maintain .ruby-version files. Available versions will be determined from the official Ruby downloads page.","title":"Additional Information"},{"location":"modules/manager/sbt/","text":"Renovate supports updating Sbt dependencies. File Matching \u00b6 By default, Renovate will check any files matching any of the following regular expressions: \\.sbt$ project/[^/]*.scala$ For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: maven , sbt-package , sbt-plugin . Additional Information \u00b6 Extracts Maven artifact dependencies for SBT.","title":"Automated Dependency Updates for Sbt"},{"location":"modules/manager/sbt/#file-matching","text":"By default, Renovate will check any files matching any of the following regular expressions: \\.sbt$ project/[^/]*.scala$ For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/sbt/#supported-datasources","text":"This manager supports extracting the following datasources: maven , sbt-package , sbt-plugin .","title":"Supported datasources"},{"location":"modules/manager/sbt/#additional-information","text":"Extracts Maven artifact dependencies for SBT.","title":"Additional Information"},{"location":"modules/manager/setup-cfg/","text":"Renovate supports updating Setup Cfg dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)setup\\.cfg$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: pypi . Additional Information \u00b6 Updates dependencies for Python setup.cfg files.","title":"Automated Dependency Updates for Setup Cfg"},{"location":"modules/manager/setup-cfg/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)setup\\.cfg$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/setup-cfg/#supported-datasources","text":"This manager supports extracting the following datasources: pypi .","title":"Supported datasources"},{"location":"modules/manager/setup-cfg/#additional-information","text":"Updates dependencies for Python setup.cfg files.","title":"Additional Information"},{"location":"modules/manager/swift/","text":"Renovate supports updating Swift dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)Package\\.swift . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: git-tags . Additional Information \u00b6 Anything other than .exact(<...>) will be treated as range with respect to Swift specific. Because of this, some PR descriptions will look like from: <...> => <...> . Examples: package ( name : \"<...>\" , from : \"1.2.3\" ) // => from: \"2.0.0\" package ( name : \"<...>\" , \"1.2.3\" ...) // => \"2.0.0\"... package ( name : \"<...>\" , \"1.2.3\" ... \"1.3.0\" ) // => \"1.2.3\"...\"2.0.0\" package ( name : \"<...>\" , \"1.2.3\" .. < \"1.3.0\" ) // => \"1.2.3\"..<\"2.0.0\" package ( name : \"<...>\" , ... \"1.2.3\" ) // => ...\"2.0.0\" package ( name : \"<...>\" , .. < \"1.2.3\" ) // => ..<\"2.0.0\"","title":"Automated Dependency Updates for Swift"},{"location":"modules/manager/swift/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)Package\\.swift . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/swift/#supported-datasources","text":"This manager supports extracting the following datasources: git-tags .","title":"Supported datasources"},{"location":"modules/manager/swift/#additional-information","text":"Anything other than .exact(<...>) will be treated as range with respect to Swift specific. Because of this, some PR descriptions will look like from: <...> => <...> . Examples: package ( name : \"<...>\" , from : \"1.2.3\" ) // => from: \"2.0.0\" package ( name : \"<...>\" , \"1.2.3\" ...) // => \"2.0.0\"... package ( name : \"<...>\" , \"1.2.3\" ... \"1.3.0\" ) // => \"1.2.3\"...\"2.0.0\" package ( name : \"<...>\" , \"1.2.3\" .. < \"1.3.0\" ) // => \"1.2.3\"..<\"2.0.0\" package ( name : \"<...>\" , ... \"1.2.3\" ) // => ...\"2.0.0\" package ( name : \"<...>\" , .. < \"1.2.3\" ) // => ..<\"2.0.0\"","title":"Additional Information"},{"location":"modules/manager/terraform/","text":"Renovate supports updating Terraform dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: \\.tf$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: bitbucket-tags , git-tags , github-tags , github-releases , helm , terraform-module , terraform-provider . Additional Information \u00b6 Currently, Terraform supports renovating the following dependencies, where sub points represent hosting options of the dependencies: modules GitTags GithubTags TerraformRegistry ( Public and Private ) providers ( deprecated in Terraform 0.13.0 ) TerraformRegistry ( Public and Private ) required_providers block ( Terraform >= 0.13.0) TerraformRegistry ( Public and Private ) required_version helm_release chart repository ( Public and Private ) docker_* Docker registry ( Public and Private ) tfe_workspace ( terraform_version argument ) Terraform range constraints are supported: >= 1.2.0 : version 1.2.0 or newer <= 1.2.0 : version 1.2.0 or older ~> 1.2.0 : any non-beta version >= 1.2.0 and < 1.3.0, e.g. 1.2.X ~> 1.2 : any non-beta version >= 1.2.0 and < 2.0.0, e.g. 1.X.Y >= 1.0.0, <= 2.0.0 : any version between 1.0.0 and 2.0.0 inclusive For fine-grained control, e.g. to turn off only parts of this manager, you can use the following depTypes : resource depType Notes Terraform provider provider required Terraform provider required_provider required Terraform version required_version This handles the required_version in terraform blocks TFE workspace tfe_workspace This handles the terraform_version argument in tfe_workspace resources Terraform module module Helm release helm_release Docker container docker_container Docker image docker_image Docker service docker_service If you need to change the versioning format, read the versioning documentation to learn more.","title":"Automated Dependency Updates for Terraform"},{"location":"modules/manager/terraform/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: \\.tf$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/terraform/#supported-datasources","text":"This manager supports extracting the following datasources: bitbucket-tags , git-tags , github-tags , github-releases , helm , terraform-module , terraform-provider .","title":"Supported datasources"},{"location":"modules/manager/terraform/#additional-information","text":"Currently, Terraform supports renovating the following dependencies, where sub points represent hosting options of the dependencies: modules GitTags GithubTags TerraformRegistry ( Public and Private ) providers ( deprecated in Terraform 0.13.0 ) TerraformRegistry ( Public and Private ) required_providers block ( Terraform >= 0.13.0) TerraformRegistry ( Public and Private ) required_version helm_release chart repository ( Public and Private ) docker_* Docker registry ( Public and Private ) tfe_workspace ( terraform_version argument ) Terraform range constraints are supported: >= 1.2.0 : version 1.2.0 or newer <= 1.2.0 : version 1.2.0 or older ~> 1.2.0 : any non-beta version >= 1.2.0 and < 1.3.0, e.g. 1.2.X ~> 1.2 : any non-beta version >= 1.2.0 and < 2.0.0, e.g. 1.X.Y >= 1.0.0, <= 2.0.0 : any version between 1.0.0 and 2.0.0 inclusive For fine-grained control, e.g. to turn off only parts of this manager, you can use the following depTypes : resource depType Notes Terraform provider provider required Terraform provider required_provider required Terraform version required_version This handles the required_version in terraform blocks TFE workspace tfe_workspace This handles the terraform_version argument in tfe_workspace resources Terraform module module Helm release helm_release Docker container docker_container Docker image docker_image Docker service docker_service If you need to change the versioning format, read the versioning documentation to learn more.","title":"Additional Information"},{"location":"modules/manager/terraform-version/","text":"Renovate supports updating Terraform Version dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)\\.terraform-version$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: github-releases . Additional Information \u00b6 This will maintain .terraform-version files. Available versions will be determined from the official Terraform downloads page.","title":"Automated Dependency Updates for Terraform Version"},{"location":"modules/manager/terraform-version/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)\\.terraform-version$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/terraform-version/#supported-datasources","text":"This manager supports extracting the following datasources: github-releases .","title":"Supported datasources"},{"location":"modules/manager/terraform-version/#additional-information","text":"This will maintain .terraform-version files. Available versions will be determined from the official Terraform downloads page.","title":"Additional Information"},{"location":"modules/manager/terragrunt/","text":"Renovate supports updating Terragrunt dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)terragrunt\\.hcl$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: git-tags , github-tags , terraform-module . Additional Information \u00b6 Currently by default, Terragrunt support is limited to Terraform registry sources and GitHub sources that include SemVer refs, e.g. like github.com/hashicorp/example?ref=v1.0.0 . You can create a custom versioning config to support non-SemVer references. For example, if you want to reference a tag like module-v1.2.5 , a block like this would work: { \"terraform\" : { \"versioning\" : \"regex:^((?<compatibility>.*)-v|v*)(?<major>\\\\d+)\\\\.(?<minor>\\\\d+)\\\\.(?<patch>\\\\d+)$\" } } Pinned Terragrunt dependencies like the following will get a PR whenever there is a newer version available: terraform { source = \"github.com/hashicorp/example?ref=v1.0.0\" }","title":"Automated Dependency Updates for Terragrunt"},{"location":"modules/manager/terragrunt/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)terragrunt\\.hcl$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/terragrunt/#supported-datasources","text":"This manager supports extracting the following datasources: git-tags , github-tags , terraform-module .","title":"Supported datasources"},{"location":"modules/manager/terragrunt/#additional-information","text":"Currently by default, Terragrunt support is limited to Terraform registry sources and GitHub sources that include SemVer refs, e.g. like github.com/hashicorp/example?ref=v1.0.0 . You can create a custom versioning config to support non-SemVer references. For example, if you want to reference a tag like module-v1.2.5 , a block like this would work: { \"terraform\" : { \"versioning\" : \"regex:^((?<compatibility>.*)-v|v*)(?<major>\\\\d+)\\\\.(?<minor>\\\\d+)\\\\.(?<patch>\\\\d+)$\" } } Pinned Terragrunt dependencies like the following will get a PR whenever there is a newer version available: terraform { source = \"github.com/hashicorp/example?ref=v1.0.0\" }","title":"Additional Information"},{"location":"modules/manager/terragrunt-version/","text":"Renovate supports updating Terragrunt Version dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/)\\.terragrunt-version$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: github-releases . Additional Information \u00b6 This will maintain .terragrunt-version files. Available versions will be determined from gruntwork-io/terragrunt GitHub releases.","title":"Automated Dependency Updates for Terragrunt Version"},{"location":"modules/manager/terragrunt-version/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/)\\.terragrunt-version$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/terragrunt-version/#supported-datasources","text":"This manager supports extracting the following datasources: github-releases .","title":"Supported datasources"},{"location":"modules/manager/terragrunt-version/#additional-information","text":"This will maintain .terragrunt-version files. Available versions will be determined from gruntwork-io/terragrunt GitHub releases.","title":"Additional Information"},{"location":"modules/manager/travis/","text":"Renovate supports updating Travis dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: ^.travis.yml$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: github-tags . Additional Information \u00b6 This manager is intended to keep Travis config files ( .travis.yml ) up-to-date, this file controls the CI build environment. Currently Renovate can only update the node_js section of this file. Renovate \"understands\" Travis's Build Matrix concept as well, so it will try to update all found Node.js versions to the latest LTS, e.g. node_js: - - 8.10.0 - - 10.10.0 + - 16.13.0 + - 16.13.0 Due to this, major updates for Travis are disabled by default. If you enable major updates and use a version matrix, then you will likely need to manually fix any major update PRs raised by Renovate. Here's how to enable major updates in your Renovate config: { \"travis\" : { \"major\" : { \"enabled\" : true } } }","title":"Automated Dependency Updates for Travis"},{"location":"modules/manager/travis/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: ^.travis.yml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/travis/#supported-datasources","text":"This manager supports extracting the following datasources: github-tags .","title":"Supported datasources"},{"location":"modules/manager/travis/#additional-information","text":"This manager is intended to keep Travis config files ( .travis.yml ) up-to-date, this file controls the CI build environment. Currently Renovate can only update the node_js section of this file. Renovate \"understands\" Travis's Build Matrix concept as well, so it will try to update all found Node.js versions to the latest LTS, e.g. node_js: - - 8.10.0 - - 10.10.0 + - 16.13.0 + - 16.13.0 Due to this, major updates for Travis are disabled by default. If you enable major updates and use a version matrix, then you will likely need to manually fix any major update PRs raised by Renovate. Here's how to enable major updates in your Renovate config: { \"travis\" : { \"major\" : { \"enabled\" : true } } }","title":"Additional Information"},{"location":"modules/manager/velaci/","text":"Renovate supports updating Velaci dependencies. File Matching \u00b6 By default, Renovate will check any files matching the following regular expression: (^|/).vela.ya?ml$ . For details on how to extend a manager's fileMatch value, please follow this link . Supported datasources \u00b6 This manager supports extracting the following datasources: docker . Additional Information \u00b6 Extracts Docker-type dependencies from VelaCI config files. If you need to change the versioning format, read the versioning documentation to learn more.","title":"Automated Dependency Updates for Velaci"},{"location":"modules/manager/velaci/#file-matching","text":"By default, Renovate will check any files matching the following regular expression: (^|/).vela.ya?ml$ . For details on how to extend a manager's fileMatch value, please follow this link .","title":"File Matching"},{"location":"modules/manager/velaci/#supported-datasources","text":"This manager supports extracting the following datasources: docker .","title":"Supported datasources"},{"location":"modules/manager/velaci/#additional-information","text":"Extracts Docker-type dependencies from VelaCI config files. If you need to change the versioning format, read the versioning documentation to learn more.","title":"Additional Information"},{"location":"modules/platform/azure/","text":"Azure DevOps and Azure DevOps Server \u00b6 Authentication \u00b6 First, create a Personal Access Token for the bot account. Let Renovate use your PAT by doing one of the following: Set your PAT as a token in your config.js file Set your PAT as an environment variable RENOVATE_TOKEN Set your PAT when you run Renovate in the CLI with --token= Remember to set platform=azure somewhere in your Renovate config file. Features awaiting implementation \u00b6 The automergeStrategy configuration option has not been implemented for this platform, and all values behave as if the value auto was used. Renovate will use the merge strategy configured in the Azure Repos repository itself, and this cannot be overridden yet","title":"Azure DevOps and Azure DevOps Server"},{"location":"modules/platform/azure/#azure-devops-and-azure-devops-server","text":"","title":"Azure DevOps and Azure DevOps Server"},{"location":"modules/platform/azure/#authentication","text":"First, create a Personal Access Token for the bot account. Let Renovate use your PAT by doing one of the following: Set your PAT as a token in your config.js file Set your PAT as an environment variable RENOVATE_TOKEN Set your PAT when you run Renovate in the CLI with --token= Remember to set platform=azure somewhere in your Renovate config file.","title":"Authentication"},{"location":"modules/platform/azure/#features-awaiting-implementation","text":"The automergeStrategy configuration option has not been implemented for this platform, and all values behave as if the value auto was used. Renovate will use the merge strategy configured in the Azure Repos repository itself, and this cannot be overridden yet","title":"Features awaiting implementation"},{"location":"modules/platform/bitbucket/","text":"Bitbucket Cloud \u00b6 Authentication \u00b6 First, create an app password for the bot account. Give the bot app password the following permission scopes: Permission Scope account Account: Read team Workspace membership: Read issue:write Issues: Write pullrequest:write Pull requests: Write The bot also needs to validate the workspace membership status of pull-request reviewers, for that, create a new user group in the workspace with the Create repositories permission and add the bot user to it. Let Renovate use your app password by doing one of the following: Set your app password as a password in your config.js file Set your app password as an environment variable RENOVATE_PASSWORD Set your app password when you run Renovate in the CLI with --password= Remember to: Set the username for the bot account Set platform=bitbucket somewhere in your Renovate config file Unsupported platform features/concepts \u00b6 Adding assignees to PRs not supported (does not seem to be a Bitbucket concept) automergeStrategy=rebase not supported by BitBucket Cloud, see Jira issue BCLOUD-16610 Features requiring implementation \u00b6 Creating issues not implemented yet, e.g. when there is a config error Adding comments to PRs not implemented yet, e.g. when a PR has been edited or has a lockfile error","title":"Bitbucket Cloud"},{"location":"modules/platform/bitbucket/#bitbucket-cloud","text":"","title":"Bitbucket Cloud"},{"location":"modules/platform/bitbucket/#authentication","text":"First, create an app password for the bot account. Give the bot app password the following permission scopes: Permission Scope account Account: Read team Workspace membership: Read issue:write Issues: Write pullrequest:write Pull requests: Write The bot also needs to validate the workspace membership status of pull-request reviewers, for that, create a new user group in the workspace with the Create repositories permission and add the bot user to it. Let Renovate use your app password by doing one of the following: Set your app password as a password in your config.js file Set your app password as an environment variable RENOVATE_PASSWORD Set your app password when you run Renovate in the CLI with --password= Remember to: Set the username for the bot account Set platform=bitbucket somewhere in your Renovate config file","title":"Authentication"},{"location":"modules/platform/bitbucket/#unsupported-platform-featuresconcepts","text":"Adding assignees to PRs not supported (does not seem to be a Bitbucket concept) automergeStrategy=rebase not supported by BitBucket Cloud, see Jira issue BCLOUD-16610","title":"Unsupported platform features/concepts"},{"location":"modules/platform/bitbucket/#features-requiring-implementation","text":"Creating issues not implemented yet, e.g. when there is a config error Adding comments to PRs not implemented yet, e.g. when a PR has been edited or has a lockfile error","title":"Features requiring implementation"},{"location":"modules/platform/bitbucket-server/","text":"Bitbucket Server Support \u00b6 Authentication \u00b6 First, create a HTTP access token for the bot account. Let Renovate use your HTTP access token by doing one of the following: Set your HTTP access token as a password in your config.js file Set your HTTP access token as an environment variable RENOVATE_PASSWORD Set your HTTP access token when you run Renovate in the CLI with --password= Remember to set platform=bitbucket-server somewhere in your Renovate config file. If you're not using @renovate-bot as username then set your custom username for the bot account. If you use MySQL or MariaDB you must set unicodeEmoji to false in the global bot config ( RENOVATE_CONFIG_FILE ) to prevent issues with emojis. Unsupported platform features/concepts \u00b6 Adding assignees to PRs not supported (does not seem to be a Bitbucket concept) Adding/removing labels (Bitbucket limitation) Features awaiting implementation \u00b6 Creating issues not implemented yet, used to alert users when there is a config error The automergeStrategy configuration option has not been implemented for this platform, and all values behave as if the value auto was used. Renovate will implicitly use the merge strategy configured as 'default' in the Bitbucket Server repository itself, and this cannot be overridden yet Testing \u00b6 If you want a test Bitbucket server locally rather than with your production server, Atlassian's Bitbucket Server Docker image is really convenient. In line with their instructions, the following commands bring up a new server: docker volume create --name bitbucketVolume docker run -v bitbucketVolume:/var/atlassian/application-data/bitbucket --name=\"bitbucket\" -d -p 7990:7990 -p 7999:7999 atlassian/bitbucket-server:5.12.3 Once it's running and initialized, the quickest way to testing with Renovate is: Create the admin user as prompted Create a new project and a repository for that project Make sure the repository has a package file in it for Renovate to find, e.g. .nvmrc or package.json Create a dedicated Renovate user @renovate-bot and grant it write access to the project Note down the password for @renovate-bot and use it in the Renovate CLI At this point you should have a project ready for Renovate, and the @renovate-bot account ready to run on it. You can then run like this: yarn start --platform=bitbucket-server --endpoint=http://localhost:7990 --git-fs=http --username=renovate-bot --password=abc123456789! --log-level=debug --autodiscover=true Alternatively using env: export RENOVATE_PLATFORM=bitbucket-server export RENOVATE_ENDPOINT=http://localhost:7990 export RENOVATE_GIT_FS=http export RENOVATE_USERNAME=renovate-bot export RENOVATE_PASSWORD=abc123456789! export LOG_LEVEL=debug yarn start --autodiscover=true You should then get a \"Configure Renovate\" onboarding PR in any projects that @renovate-bot has been invited to. Supported versions \u00b6 We support all Bitbucket Server versions which are not EOL. See Atlassian Support End of Life Policy for uptodate versions.","title":"Bitbucket Server Support"},{"location":"modules/platform/bitbucket-server/#bitbucket-server-support","text":"","title":"Bitbucket Server Support"},{"location":"modules/platform/bitbucket-server/#authentication","text":"First, create a HTTP access token for the bot account. Let Renovate use your HTTP access token by doing one of the following: Set your HTTP access token as a password in your config.js file Set your HTTP access token as an environment variable RENOVATE_PASSWORD Set your HTTP access token when you run Renovate in the CLI with --password= Remember to set platform=bitbucket-server somewhere in your Renovate config file. If you're not using @renovate-bot as username then set your custom username for the bot account. If you use MySQL or MariaDB you must set unicodeEmoji to false in the global bot config ( RENOVATE_CONFIG_FILE ) to prevent issues with emojis.","title":"Authentication"},{"location":"modules/platform/bitbucket-server/#unsupported-platform-featuresconcepts","text":"Adding assignees to PRs not supported (does not seem to be a Bitbucket concept) Adding/removing labels (Bitbucket limitation)","title":"Unsupported platform features/concepts"},{"location":"modules/platform/bitbucket-server/#features-awaiting-implementation","text":"Creating issues not implemented yet, used to alert users when there is a config error The automergeStrategy configuration option has not been implemented for this platform, and all values behave as if the value auto was used. Renovate will implicitly use the merge strategy configured as 'default' in the Bitbucket Server repository itself, and this cannot be overridden yet","title":"Features awaiting implementation"},{"location":"modules/platform/bitbucket-server/#testing","text":"If you want a test Bitbucket server locally rather than with your production server, Atlassian's Bitbucket Server Docker image is really convenient. In line with their instructions, the following commands bring up a new server: docker volume create --name bitbucketVolume docker run -v bitbucketVolume:/var/atlassian/application-data/bitbucket --name=\"bitbucket\" -d -p 7990:7990 -p 7999:7999 atlassian/bitbucket-server:5.12.3 Once it's running and initialized, the quickest way to testing with Renovate is: Create the admin user as prompted Create a new project and a repository for that project Make sure the repository has a package file in it for Renovate to find, e.g. .nvmrc or package.json Create a dedicated Renovate user @renovate-bot and grant it write access to the project Note down the password for @renovate-bot and use it in the Renovate CLI At this point you should have a project ready for Renovate, and the @renovate-bot account ready to run on it. You can then run like this: yarn start --platform=bitbucket-server --endpoint=http://localhost:7990 --git-fs=http --username=renovate-bot --password=abc123456789! --log-level=debug --autodiscover=true Alternatively using env: export RENOVATE_PLATFORM=bitbucket-server export RENOVATE_ENDPOINT=http://localhost:7990 export RENOVATE_GIT_FS=http export RENOVATE_USERNAME=renovate-bot export RENOVATE_PASSWORD=abc123456789! export LOG_LEVEL=debug yarn start --autodiscover=true You should then get a \"Configure Renovate\" onboarding PR in any projects that @renovate-bot has been invited to.","title":"Testing"},{"location":"modules/platform/bitbucket-server/#supported-versions","text":"We support all Bitbucket Server versions which are not EOL. See Atlassian Support End of Life Policy for uptodate versions.","title":"Supported versions"},{"location":"modules/platform/gitea/","text":"Gitea \u00b6 Renovate uses modern Git upload filters to suppress large blob downloads. For Gitea you need to manually enable upload filters. Read the official Gitea docs for more information. Authentication \u00b6 First, create a Personal Access Token for the bot account. Let Renovate use your PAT by doing one of the following: Set your PAT as a token in your config.js file Set your PAT as an environment variable RENOVATE_TOKEN Set your PAT when you run Renovate in the CLI with --token= Remember to set platform=gitea somewhere in your Renovate config file. Unsupported platform features/concepts \u00b6 Adding reviewers to PRs not supported : Gitea versions older than v1.14.0 do not have the required API. Features awaiting implementation \u00b6 The automergeStrategy configuration option has not been implemented for this platform, and all values behave as if the value auto was used. Renovate will use the merge strategy configured in the Gitea repository itself, and this cannot be overridden yet","title":"Gitea"},{"location":"modules/platform/gitea/#gitea","text":"Renovate uses modern Git upload filters to suppress large blob downloads. For Gitea you need to manually enable upload filters. Read the official Gitea docs for more information.","title":"Gitea"},{"location":"modules/platform/gitea/#authentication","text":"First, create a Personal Access Token for the bot account. Let Renovate use your PAT by doing one of the following: Set your PAT as a token in your config.js file Set your PAT as an environment variable RENOVATE_TOKEN Set your PAT when you run Renovate in the CLI with --token= Remember to set platform=gitea somewhere in your Renovate config file.","title":"Authentication"},{"location":"modules/platform/gitea/#unsupported-platform-featuresconcepts","text":"Adding reviewers to PRs not supported : Gitea versions older than v1.14.0 do not have the required API.","title":"Unsupported platform features/concepts"},{"location":"modules/platform/gitea/#features-awaiting-implementation","text":"The automergeStrategy configuration option has not been implemented for this platform, and all values behave as if the value auto was used. Renovate will use the merge strategy configured in the Gitea repository itself, and this cannot be overridden yet","title":"Features awaiting implementation"},{"location":"modules/platform/github/","text":"GitHub and GitHub Enterprise Server \u00b6 Authentication \u00b6 First, create a Personal Access Token for the bot account, select repo scope. Let Renovate use your PAT by doing one of the following: Set your PAT as a token in your config.js file Set your PAT as an environment variable RENOVATE_TOKEN Set your PAT when you run Renovate in the CLI with --token= Remember to set platform=github somewhere in your Renovate config file. If you use GitHub Enterprise Server then endpoint must point to https://github.enterprise.com/api/v3/ . You can choose where you want to set endpoint : In your config.js file In a environment variable In a CLI parameter Running as a GitHub App \u00b6 Instead of a bot account with a Personal Access Token you can run renovate as a self-hosted GitHub App . When creating the GitHub App give it the following permissions: Permission Scope Checks read + write Commit statuses read + write Contents read + write Issues read + write Pull requests read + write Workflows read + write Dependabot alerts read Members read Metadata read Other values like Homepage URL, User authorization callback URL and webhooks can be disabled or filled with dummy values. Inside your config.js you need to set the following values, assuming the name of your app is self-hosted-renovate : username:\"self-hosted-renovate[bot]\" The slug name of your app with [bot] appended gitAuthor:\"Self-hosted Renovate Bot <123456+self-hosted-renovate[bot]@users.noreply.github.enterprise.com>\" The GitHub App associated email to match commits to the bot. It needs to have the user id and the username followed by the users.noreply. -domain of either github.com or the GitHub Enterprise Server. A way to get the user id of a GitHub app is to query the user API at api.github.com/user/self-hosted-renovate[bot] (github.com) or github.enterprise.com/api/v3/uer/self-hosted-renovate[bot] (GitHub Enterprise Server). token:\"x-access-token:${github-app-installation}\" The token needs to be prefixed with x-access-token and be a GitHub App Installation token . Note The installation tokens expire after 1 hour and need to be regenerated regularly. Alternatively as environment variable RENOVATE_TOKEN , or via CLI --token= . repositories: [\"orgname/repo-1\",\"orgname/repo-2\"] List of repositories to run on. Alternatively as comma-separated environment variable RENOVATE_REPOSITORIES . The GitHub App installation token is scoped at most to a single organization and running on multiple organizations requires multiple invocations of renovate with different token and repositories parameters. Features awaiting implementation \u00b6 The automergeStrategy configuration option has not been implemented for this platform, and all values behave as if the value auto was used. Renovate will use the merge strategy configured in the GitHub repository itself, and this cannot be overridden yet","title":"GitHub and GitHub Enterprise Server"},{"location":"modules/platform/github/#github-and-github-enterprise-server","text":"","title":"GitHub and GitHub Enterprise Server"},{"location":"modules/platform/github/#authentication","text":"First, create a Personal Access Token for the bot account, select repo scope. Let Renovate use your PAT by doing one of the following: Set your PAT as a token in your config.js file Set your PAT as an environment variable RENOVATE_TOKEN Set your PAT when you run Renovate in the CLI with --token= Remember to set platform=github somewhere in your Renovate config file. If you use GitHub Enterprise Server then endpoint must point to https://github.enterprise.com/api/v3/ . You can choose where you want to set endpoint : In your config.js file In a environment variable In a CLI parameter","title":"Authentication"},{"location":"modules/platform/github/#running-as-a-github-app","text":"Instead of a bot account with a Personal Access Token you can run renovate as a self-hosted GitHub App . When creating the GitHub App give it the following permissions: Permission Scope Checks read + write Commit statuses read + write Contents read + write Issues read + write Pull requests read + write Workflows read + write Dependabot alerts read Members read Metadata read Other values like Homepage URL, User authorization callback URL and webhooks can be disabled or filled with dummy values. Inside your config.js you need to set the following values, assuming the name of your app is self-hosted-renovate : username:\"self-hosted-renovate[bot]\" The slug name of your app with [bot] appended gitAuthor:\"Self-hosted Renovate Bot <123456+self-hosted-renovate[bot]@users.noreply.github.enterprise.com>\" The GitHub App associated email to match commits to the bot. It needs to have the user id and the username followed by the users.noreply. -domain of either github.com or the GitHub Enterprise Server. A way to get the user id of a GitHub app is to query the user API at api.github.com/user/self-hosted-renovate[bot] (github.com) or github.enterprise.com/api/v3/uer/self-hosted-renovate[bot] (GitHub Enterprise Server). token:\"x-access-token:${github-app-installation}\" The token needs to be prefixed with x-access-token and be a GitHub App Installation token . Note The installation tokens expire after 1 hour and need to be regenerated regularly. Alternatively as environment variable RENOVATE_TOKEN , or via CLI --token= . repositories: [\"orgname/repo-1\",\"orgname/repo-2\"] List of repositories to run on. Alternatively as comma-separated environment variable RENOVATE_REPOSITORIES . The GitHub App installation token is scoped at most to a single organization and running on multiple organizations requires multiple invocations of renovate with different token and repositories parameters.","title":"Running as a GitHub App"},{"location":"modules/platform/github/#features-awaiting-implementation","text":"The automergeStrategy configuration option has not been implemented for this platform, and all values behave as if the value auto was used. Renovate will use the merge strategy configured in the GitHub repository itself, and this cannot be overridden yet","title":"Features awaiting implementation"},{"location":"modules/platform/gitlab/","text":"GitLab \u00b6 Authentication \u00b6 First, create a Personal Access Token for the bot account. For real runs, give the PAT these scopes: read_user api write_repository For dry runs, give the PAT these scopes: read_user read_api read_repository Let Renovate use your PAT by doing one of the following: Set your PAT as a token in your config.js file Set your PAT as an environment variable RENOVATE_TOKEN Set your PAT when you run Renovate in the CLI with --token= Remember to set platform=gitlab somewhere in your Renovate config file. Features awaiting implementation \u00b6 The automergeStrategy configuration option has not been implemented for this platform, and all values behave as if the value auto was used. Renovate will accept the Merge Request without further configuration, and respect the strategy defined in the Merge Request, and this cannot be overridden yet Server version dependent features \u00b6 We use the GitLab version API to fetch the server version. You can use the experimental feature flag RENOVATE_X_PLATFORM_VERSION to set a specific server version. By setting the server version yourself, you save a API call that fetches the server version. Use Draft: MR prefix instead of WIP: prefix since v13.2.0 Do not truncate Markdown body to 25K chars since v13.4.0 Allow configure reviewers since v13.9.0 Multiple merge request assignees \u00b6 Due to licensing restrictions multiple assignees are only available in GitLab Premium self-managed, GitLab Premium SaaS, and higher tiers. Because of a safeguard in GitLab's API if multiple assignees are set, but not available to the project, only the first assignee will be applied.","title":"GitLab"},{"location":"modules/platform/gitlab/#gitlab","text":"","title":"GitLab"},{"location":"modules/platform/gitlab/#authentication","text":"First, create a Personal Access Token for the bot account. For real runs, give the PAT these scopes: read_user api write_repository For dry runs, give the PAT these scopes: read_user read_api read_repository Let Renovate use your PAT by doing one of the following: Set your PAT as a token in your config.js file Set your PAT as an environment variable RENOVATE_TOKEN Set your PAT when you run Renovate in the CLI with --token= Remember to set platform=gitlab somewhere in your Renovate config file.","title":"Authentication"},{"location":"modules/platform/gitlab/#features-awaiting-implementation","text":"The automergeStrategy configuration option has not been implemented for this platform, and all values behave as if the value auto was used. Renovate will accept the Merge Request without further configuration, and respect the strategy defined in the Merge Request, and this cannot be overridden yet","title":"Features awaiting implementation"},{"location":"modules/platform/gitlab/#server-version-dependent-features","text":"We use the GitLab version API to fetch the server version. You can use the experimental feature flag RENOVATE_X_PLATFORM_VERSION to set a specific server version. By setting the server version yourself, you save a API call that fetches the server version. Use Draft: MR prefix instead of WIP: prefix since v13.2.0 Do not truncate Markdown body to 25K chars since v13.4.0 Allow configure reviewers since v13.9.0","title":"Server version dependent features"},{"location":"modules/platform/gitlab/#multiple-merge-request-assignees","text":"Due to licensing restrictions multiple assignees are only available in GitLab Premium self-managed, GitLab Premium SaaS, and higher tiers. Because of a safeguard in GitLab's API if multiple assignees are set, but not available to the project, only the first assignee will be applied.","title":"Multiple merge request assignees"}]}